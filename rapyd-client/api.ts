/* tslint:disable */
/* eslint-disable */
/**
 * Rapyd API
 * This is a Beta release of the OpenAPI specification for Rapyd\'s API methods. It is recommended to initially run the methods in the sandbox environment. For the most up to date documentation of Rapyd\'s methods, see the [online API Reference](https://docs.rapyd.net/en/index-en.html). <BR> For required signature, see [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
 *
 * The version of the OpenAPI document: 1.0.12
 * Contact: rapyd_support@rapyd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Three-letter ISO 4217 code for the currency of the account.
     * @type {string}
     * @memberof Account
     */
    'alias'?: string;
    /**
     * Available funds in the account.
     * @type {number}
     * @memberof Account
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'currency'?: string;
    /**
     * ID of the account. UUID
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'limit'?: string;
    /**
     * 
     * @type {Array<Limit>}
     * @memberof Account
     */
    'limits'?: Array<Limit>;
    /**
     * Amount in the on-hold balance of the account.
     * @type {number}
     * @memberof Account
     */
    'on_hold_balance'?: number;
    /**
     * Amount of escrow funds in the account.
     * @type {number}
     * @memberof Account
     */
    'received_balance'?: number;
    /**
     * Amount in the reserve balance of the account.
     * @type {number}
     * @memberof Account
     */
    'reserve_balance'?: number;
}
/**
 * 
 * @export
 * @interface AccountDepositBody
 */
export interface AccountDepositBody {
    /**
     * Amount of the transaction. Decimal.
     * @type {number}
     * @memberof AccountDepositBody
     */
    'amount': number;
    /**
     * Three-letter ISO 4217 code for the currency used in the `amount` field.
     * @type {string}
     * @memberof AccountDepositBody
     */
    'currency': string;
    /**
     * ID of the Rapyd Wallet. String starting with **ewallet_**.
     * @type {object}
     * @memberof AccountDepositBody
     */
    'ewallet': object;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof AccountDepositBody
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface AccountLimitsBody
 */
export interface AccountLimitsBody {
    /**
     * The ID of the account within the wallet.
     * @type {string}
     * @memberof AccountLimitsBody
     */
    'account_id'?: string;
    /**
     * The amount of the limit.
     * @type {string}
     * @memberof AccountLimitsBody
     */
    'amount': string;
    /**
     * Three-letter ISO 4217 code for the currency of an existing account.
     * @type {string}
     * @memberof AccountLimitsBody
     */
    'currency': string;
    /**
     * The limit type.
     * @type {string}
     * @memberof AccountLimitsBody
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface AccountTransferBody
 */
export interface AccountTransferBody {
    /**
     * Amount of the transfer. Decimal.
     * @type {number}
     * @memberof AccountTransferBody
     */
    'amount': number;
    /**
     * Three-letter ISO 4217 code for the currency used in the amount field. Uppercase.
     * @type {string}
     * @memberof AccountTransferBody
     */
    'currency': string;
    /**
     * ID of the wallet receiving the money. String starting with **ewallet_**.
     * @type {string}
     * @memberof AccountTransferBody
     */
    'destination_ewallet': string;
    /**
     * Determines the day the ewallet funds transfer expires, in Unix time. Acceptance of the ewallet transfer must be completed before the start of this day. The default setting is 14 days from the date the ewallet transfer was created.
     * @type {string}
     * @memberof AccountTransferBody
     */
    'expiration'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof AccountTransferBody
     */
    'metadata'?: object;
    /**
     * ID of the wallet sending the money. String starting with **ewallet_**.
     * @type {string}
     * @memberof AccountTransferBody
     */
    'source_ewallet': string;
}
/**
 * 
 * @export
 * @interface AccountWithdrawBody
 */
export interface AccountWithdrawBody {
    /**
     * Amount of the transaction. Decimal.
     * @type {number}
     * @memberof AccountWithdrawBody
     */
    'amount': number;
    /**
     * Three-letter ISO 4217 code for the currency used in the `amount` field.
     * @type {string}
     * @memberof AccountWithdrawBody
     */
    'currency': string;
    /**
     * ID of the Rapyd Wallet. String starting with **ewallet_**.
     * @type {object}
     * @memberof AccountWithdrawBody
     */
    'ewallet': object;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof AccountWithdrawBody
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface AddCardtoGooglePayResponse
 */
export interface AddCardtoGooglePayResponse {
    /**
     * The base64 encoded string that contains the encrypted object for Push Provisioning. Required for adding the card to the Google Pay wallet by using the Google Pay `pushTokenizeRequest` method. For more information refer to the Google Pay Provisioning developer documentation .Details of an account funding transaction (AFT), which transfers funds from a card to a cardholder\'s wallet.
     * @type {string}
     * @memberof AddCardtoGooglePayResponse
     */
    'PaymentInstrumentData'?: string;
    /**
     * 
     * @type {AddCardtoGooglePayResponseUserAddress}
     * @memberof AddCardtoGooglePayResponse
     */
    'UserAddress'?: AddCardtoGooglePayResponseUserAddress;
}
/**
 * The base64 encoded string that contains the encrypted object for Push Provisioning. Required for adding the card to the Google Pay wallet by using the Google Pay `pushTokenizeRequest` method. For more information refer to the Google Pay Provisioning developer documentation .Details of an account funding transaction (AFT), which transfers funds from a card to a cardholder\'s wallet.
 * @export
 * @interface AddCardtoGooglePayResponseUserAddress
 */
export interface AddCardtoGooglePayResponseUserAddress {
    /**
     * First part address.
     * @type {string}
     * @memberof AddCardtoGooglePayResponseUserAddress
     */
    'firstPartAddress'?: string;
    /**
     * Second part address.
     * @type {string}
     * @memberof AddCardtoGooglePayResponseUserAddress
     */
    'secondPartAddress'?: string;
    /**
     * Two character Country code.
     * @type {string}
     * @memberof AddCardtoGooglePayResponseUserAddress
     */
    'countryCode'?: string;
    /**
     * Locality such as city, town, etc.
     * @type {string}
     * @memberof AddCardtoGooglePayResponseUserAddress
     */
    'locality'?: string;
}
/**
 * address associated with this specific Rapyd entity Payment/Customer etc...
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Name of the canton administrative subdivision, as used in banking.
     * @type {string}
     * @memberof Address
     */
    'canton'?: string;
    /**
     * City portion of the address. Required for issuance of a card to the wallet contact.
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * Time of creation of the payment, in Unix time. Response only.
     * @type {number}
     * @memberof Address
     */
    'created_at'?: number;
    /**
     * Name of the district administrative subdivision, as used in banking.
     * @type {string}
     * @memberof Address
     */
    'district'?: string;
    /**
     * ID of the Address object. String starting with **address_**.
     * @type {string}
     * @memberof Address
     */
    'id'?: string;
    /**
     * Line 1 of the address, such as a building number and street name.
     * @type {string}
     * @memberof Address
     */
    'line_1': string;
    /**
     * Line 2 of the address, such as a suite or apartment number, or the name of a named building.
     * @type {string}
     * @memberof Address
     */
    'line_2'?: string;
    /**
     * Line 3 of the address, such as a suite or apartment number, or the name of a named building.
     * @type {string}
     * @memberof Address
     */
    'line_3'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Address
     */
    'metadata'?: object;
    /**
     * The name of a contact person or an \'in care of\' person at this address. For a **personal** wallet contact type, alphabetic characters and spaces.A JSON object defined by the client.
     * @type {string}
     * @memberof Address
     */
    'name': string;
    /**
     * Phone number associated with this specific address in E.164 format. Must be unique.
     * @type {string}
     * @memberof Address
     */
    'phone_number'?: string;
    /**
     * State or province portion of the address.
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * Postal code portion of the address.
     * @type {string}
     * @memberof Address
     */
    'zip'?: string;
}
/**
 * address associated with this specific Rapyd entity Payment/Customer etc.
 * @export
 * @interface Address1
 */
export interface Address1 {
    /**
     * Name of the canton administrative subdivision, as used in banking
     * @type {string}
     * @memberof Address1
     */
    'canton'?: string;
    /**
     * City name portion of the address. Required for issuance of a card to an eWallet contact
     * @type {string}
     * @memberof Address1
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'country'?: string;
    /**
     * Time of creation of the payment, in Unix time. Response only.
     * @type {number}
     * @memberof Address1
     */
    'created_at'?: number;
    /**
     * Name of the district administrative subdivision, as used in banking
     * @type {string}
     * @memberof Address1
     */
    'district'?: string;
    /**
     * ID of the Address object. String starting with address_
     * @type {string}
     * @memberof Address1
     */
    'id'?: string;
    /**
     * Line 1 of the address, such as a building number and street name
     * @type {string}
     * @memberof Address1
     */
    'line_1'?: string;
    /**
     * Line 2 of the address, such as a suite or apartment number, or the name of a named building
     * @type {string}
     * @memberof Address1
     */
    'line_2'?: string;
    /**
     * Line 3 of the address
     * @type {string}
     * @memberof Address1
     */
    'line_3'?: string;
    /**
     * A JSON object defined by the client
     * @type {object}
     * @memberof Address1
     */
    'metadata'?: object;
    /**
     * The name of a contact person or an `in care of` person at this address
     * @type {string}
     * @memberof Address1
     */
    'name'?: string;
    /**
     * Phone number associated with this specific address in E.164 format. Must be unique
     * @type {string}
     * @memberof Address1
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'state'?: string;
    /**
     * Postal code portion of the address
     * @type {string}
     * @memberof Address1
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * Name of the canton administrative subdivision, as used in banking.
     * @type {string}
     * @memberof AddressResponse
     */
    'canton'?: string;
    /**
     * City portion of the address.
     * @type {string}
     * @memberof AddressResponse
     */
    'city'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof AddressResponse
     */
    'country'?: string;
    /**
     * Time of creation of the object, in Unix time.
     * @type {number}
     * @memberof AddressResponse
     */
    'created_at'?: number;
    /**
     * Name of the district administrative subdivision, as used in banking.
     * @type {string}
     * @memberof AddressResponse
     */
    'district'?: string;
    /**
     * ID of the `address` object.
     * @type {string}
     * @memberof AddressResponse
     */
    'id'?: string;
    /**
     * Line 1 of the address, such as a building number and street name.
     * @type {string}
     * @memberof AddressResponse
     */
    'line_1'?: string;
    /**
     * Line 2 of the address, such as a suite or apartment number, or the name of a named building.
     * @type {string}
     * @memberof AddressResponse
     */
    'line_2'?: string;
    /**
     * Line 2 of the address, such as a suite or apartment number, or the name of a named building.
     * @type {string}
     * @memberof AddressResponse
     */
    'line_3'?: string;
    /**
     * A JSON object defined by the client.
     * @type {any}
     * @memberof AddressResponse
     */
    'metadata'?: any;
    /**
     * The name of a contact person or an \'in care of\' person at this address. For a **personal** wallet contact type, alphabetic characters and spaces.A JSON object defined by the client.
     * @type {string}
     * @memberof AddressResponse
     */
    'name'?: string;
    /**
     * Phone number associated with this specific address in E.164 format. Must be unique.
     * @type {string}
     * @memberof AddressResponse
     */
    'phone_number'?: string;
    /**
     * State or province portion of the address.
     * @type {string}
     * @memberof AddressResponse
     */
    'state'?: string;
    /**
     * Postal code portion of the address.
     * @type {string}
     * @memberof AddressResponse
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface ApplePayObject
 */
export interface ApplePayObject {
    /**
     * The canonical name for the client\'s business, suitable for display. 64 or fewer UTF-8 characters. Relevant to Apple Pay.
     * @type {string}
     * @memberof ApplePayObject
     */
    'display_name': string;
    /**
     * The client\'s fully qualified domain name, without the final period. For example, **acmegeneralproducts.rapyd.net**
     * @type {string}
     * @memberof ApplePayObject
     */
    'initiative_context': string;
}
/**
 * 
 * @export
 * @interface ApplePayObjectResponse
 */
export interface ApplePayObjectResponse {
    /**
     * The canonical name for the client\'s business, suitable for display. 64 or fewer UTF-8 characters. Relevant to Apple Pay.
     * @type {string}
     * @memberof ApplePayObjectResponse
     */
    'display_name'?: string;
    /**
     * The domain name of the client\'s ecommerce site.
     * @type {string}
     * @memberof ApplePayObjectResponse
     */
    'domainName'?: string;
    /**
     * Time of creation of the Apple Pay session, in Unix time.
     * @type {number}
     * @memberof ApplePayObjectResponse
     */
    'epochTimestamp'?: number;
    /**
     * Time of expiration of the Apple Pay session, in Unix time.
     * @type {number}
     * @memberof ApplePayObjectResponse
     */
    'expiresAt'?: number;
    /**
     * Your Apple Pay merchant ID.
     * @type {string}
     * @memberof ApplePayObjectResponse
     */
    'merchantIdentifier'?: string;
    /**
     * Your Apple Pay session ID.
     * @type {string}
     * @memberof ApplePayObjectResponse
     */
    'merchantSessionIdentifier'?: string;
    /**
     * A string that uniquely identifies each call to Apple Pay.
     * @type {string}
     * @memberof ApplePayObjectResponse
     */
    'nonce'?: string;
    /**
     * The number of previous attempts to get an Apple Pay Session object.
     * @type {number}
     * @memberof ApplePayObjectResponse
     */
    'retries'?: number;
    /**
     * Digital signature that validates the authenticity and integrity of a digital wallet payment.
     * @type {string}
     * @memberof ApplePayObjectResponse
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationsHostedBody
 */
export interface ApplicationsHostedBody {
    /**
     * Code for the type of application.
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'application_type'?: string;
    /**
     * The country where the company is domiciled. Two-letter ISO 3166-1 ALPHA-2 code. The hosted application displays the country as the default setting.
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'country': string;
    /**
     * The ID of the Rapyd wallet of the company. String starting with ewallet_.
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'rapyd_entity_token': string;
    /**
     * The phone number of the applicant. This is the phone number where an authentication code is sent. Must have a leading plus sign (+).
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'phone_number': string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof ApplicationsHostedBody
     */
    'metadata'?: object;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'client_reference_id'?: string;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing Close to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof ApplicationsHostedBody
     */
    'complete_url'?: string;
}
/**
 * 
 * @export
 * @interface BalanceHoldBody
 */
export interface BalanceHoldBody {
    /**
     * Amount of the transfer. Decimal.
     * @type {number}
     * @memberof BalanceHoldBody
     */
    'amount': number;
    /**
     * Three-letter ISO 4217 code for the currency used in the `amount` field.
     * @type {string}
     * @memberof BalanceHoldBody
     */
    'currency'?: string;
    /**
     * ID of the wallet associated with the contact. String starting with **ewallet_**.
     * @type {string}
     * @memberof BalanceHoldBody
     */
    'ewallet'?: string;
}
/**
 * 
 * @export
 * @interface BankaccountsBankaccounttransfertobankaccountBody
 */
export interface BankaccountsBankaccounttransfertobankaccountBody {
    /**
     * The amount of the transaction, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {string}
     * @memberof BankaccountsBankaccounttransfertobankaccountBody
     */
    'amount': string;
    /**
     * Currency of the transaction. Three-letter ISO 4217 code. Must be the same as the currency of the virtual account.
     * @type {string}
     * @memberof BankaccountsBankaccounttransfertobankaccountBody
     */
    'currency': string;
    /**
     * ID of the Virtual Account Number object. String starting with **issuing_**
     * @type {string}
     * @memberof BankaccountsBankaccounttransfertobankaccountBody
     */
    'issued_bank_account': string;
}
/**
 * 
 * @export
 * @interface BankaccountsVirtualAccountIdBody
 */
export interface BankaccountsVirtualAccountIdBody {
    /**
     * 
     * @type {string}
     * @memberof BankaccountsVirtualAccountIdBody
     */
    'requesting_currency'?: string;
}
/**
 * 
 * @export
 * @interface Beneficiary
 */
export interface Beneficiary {
    /**
     * American Bankers Association routing transit number. United States.
     * @type {string}
     * @memberof Beneficiary
     */
    'aba'?: string;
    /**
     * The person\'s account number.
     * @type {string}
     * @memberof Beneficiary
     */
    'account_number'?: string;
    /**
     * Automated Clearing House (ACH) code.
     * @type {string}
     * @memberof Beneficiary
     */
    'ach_code'?: string;
    /**
     * Additional data required by the payout method. Object.
     * @type {object}
     * @memberof Beneficiary
     */
    'additional_data'?: object;
    /**
     * The person\'s second last name.
     * @type {string}
     * @memberof Beneficiary
     */
    'additional_last_name'?: string;
    /**
     * Street and number portion of the person\'s address.
     * @type {string}
     * @memberof Beneficiary
     */
    'address'?: string;
    /**
     * Name of the account holder.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_account_holder_name'?: string;
    /**
     * Type of bank account, such as checking or savings.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_account_type'?: string;
    /**
     * Street and number portion of the bank\'s address.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_address'?: string;
    /**
     * Identifier for the bank branch.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_branch_code'?: string;
    /**
     * Name of the bank branch.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_branch_name'?: string;
    /**
     * City portion of the bank\'s address.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_city'?: string;
    /**
     * Domestic identifier of the bank.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_code'?: string;
    /**
     * Two-letter ISO 3166-1 ALPHA-2 code for the bank\'s country.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_country'?: string;
    /**
     * Name of the bank.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_name'?: string;
    /**
     * State or province portion of the bank\'s address.
     * @type {string}
     * @memberof Beneficiary
     */
    'bank_province'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'beneficiary_bic_local'?: string;
    /**
     * Relationship between the sender and the beneficiary.
     * @type {string}
     * @memberof Beneficiary
     */
    'beneficiary_relationship'?: string;
    /**
     * BIC (SWIFT) code for the bank account.
     * @type {string}
     * @memberof Beneficiary
     */
    'bic_swift'?: string;
    /**
     * Bank State Branch code for Australia.
     * @type {string}
     * @memberof Beneficiary
     */
    'bsb_code'?: string;
    /**
     * The cardâ€™s expiration month.
     * @type {string}
     * @memberof Beneficiary
     */
    'card_expiration_month'?: string;
    /**
     * The cardâ€™s expiration year.
     * @type {string}
     * @memberof Beneficiary
     */
    'card_expiration_year'?: string;
    /**
     * The card number.
     * @type {string}
     * @memberof Beneficiary
     */
    'card_number'?: string;
    /**
     * 
     * @type {Category}
     * @memberof Beneficiary
     */
    'category'?: Category;
    /**
     * City portion of the address.
     * @type {string}
     * @memberof Beneficiary
     */
    'city'?: string;
    /**
     * Standardized bank code for Mexico.
     * @type {string}
     * @memberof Beneficiary
     */
    'clabe'?: string;
    /**
     * China National Advanced Payments System (CNAPS) code number.
     * @type {string}
     * @memberof Beneficiary
     */
    'cnaps'?: string;
    /**
     * Name of the beneficiary company. Relevant when entity_type is company.
     * @type {string}
     * @memberof Beneficiary
     */
    'company_name'?: string;
    /**
     * Indicates whether the beneficiary must respond to accept or decline a payout. Default is false. Relevant to the rapyd_ewallet payout method type
     * @type {boolean}
     * @memberof Beneficiary
     */
    'confirmation_required'?: boolean;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof Beneficiary
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Beneficiary
     */
    'currency'?: string;
    /**
     * The person\'s date of birth.
     * @type {string}
     * @memberof Beneficiary
     */
    'date_of_birth'?: string;
    /**
     * Date of incorporation of the corporation.
     * @type {string}
     * @memberof Beneficiary
     */
    'date_of_incorporation'?: string;
    /**
     * The type of payout method for the beneficiary. The two-letter prefix must match the beneficiary country code.
     * @type {string}
     * @memberof Beneficiary
     */
    'default_payout_method_type'?: string;
    /**
     * The person\'s email address.
     * @type {string}
     * @memberof Beneficiary
     */
    'email'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof Beneficiary
     */
    'entity_type'?: EntityType;
    /**
     * ID of the wallet that the money is transferred to. String starting with **ewallet_**. Relevant to payout to Rapyd Wallet.
     * @type {string}
     * @memberof Beneficiary
     */
    'ewallet'?: string;
    /**
     * First name of the beneficiary. Relevant when **entity_type** is individual.
     * @type {string}
     * @memberof Beneficiary
     */
    'first_name'?: string;
    /**
     * International Bank Account Number.
     * @type {string}
     * @memberof Beneficiary
     */
    'iban'?: string;
    /**
     * ID of the \'beneficiary\' object. String starting with **beneficiary_**. Response only.
     * @type {string}
     * @memberof Beneficiary
     */
    'id'?: string;
    /**
     * The date of issuance of the person\'s identification document.
     * @type {string}
     * @memberof Beneficiary
     */
    'id_date_of_issue'?: string;
    /**
     * The government agency that issued the person\'s identification document.
     * @type {string}
     * @memberof Beneficiary
     */
    'id_issue_authority'?: string;
    /**
     * The location where the person\'s identification document was issued.
     * @type {string}
     * @memberof Beneficiary
     */
    'id_issue_location'?: string;
    /**
     * Type of identification document for the beneficiary. When entity_type is company, this field must be company_registered_number. When entity_type is individual, one of the following values: * drivers_license * identification_id * international_passport * residence_permit* social_security * work_permit 
     * @type {string}
     * @memberof Beneficiary
     */
    'identification_type'?: string;
    /**
     * identification number on the document mentioned in identification_type.
     * @type {string}
     * @memberof Beneficiary
     */
    'identification_value'?: string;
    /**
     * Indian Financial System Code for a bank branch.
     * @type {string}
     * @memberof Beneficiary
     */
    'ifsc'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'issuer_code'?: string;
    /**
     * Last name of the beneficiary. Relevant when `entity_type` is individual.
     * @type {string}
     * @memberof Beneficiary
     */
    'last_name'?: string;
    /**
     * ID defined by the merchant. Rapyd does not validate this value to enforce uniqueness.
     * @type {string}
     * @memberof Beneficiary
     */
    'merchant_reference_id'?: string;
    /**
     * The person\'s middle name.
     * @type {string}
     * @memberof Beneficiary
     */
    'middle_name'?: string;
    /**
     * Mobile phone number in E.164 format.
     * @type {string}
     * @memberof Beneficiary
     */
    'mobile_number'?: string;
    /**
     * The person\'s full name.
     * @type {string}
     * @memberof Beneficiary
     */
    'name'?: string;
    /**
     * The person\'s nationality.
     * @type {string}
     * @memberof Beneficiary
     */
    'nationality'?: string;
    /**
     * Additional classification of the type of payment, as required by the bank. Possible values: priority , regular
     * @type {string}
     * @memberof Beneficiary
     */
    'payment_type'?: string;
    /**
     * The country code of the person\'s phone.
     * @type {string}
     * @memberof Beneficiary
     */
    'phone_country_code'?: string;
    /**
     * Phone number in E.164 format.
     * @type {string}
     * @memberof Beneficiary
     */
    'phone_number'?: string;
    /**
     * Postal code portion of the address.
     * @type {string}
     * @memberof Beneficiary
     */
    'postcode'?: string;
    /**
     * Province portion of the address.
     * @type {string}
     * @memberof Beneficiary
     */
    'province'?: string;
    /**
     * Purpose of the transaction.
     * @type {string}
     * @memberof Beneficiary
     */
    'purpose_code'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'routing_code_type_1'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'routing_code_type_2'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'routing_code_type_3'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'routing_code_value_1'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'routing_code_value_2'?: string;
    /**
     * NA.
     * @type {string}
     * @memberof Beneficiary
     */
    'routing_code_value_3'?: string;
    /**
     * Routing number for the UK.
     * @type {string}
     * @memberof Beneficiary
     */
    'sort_code'?: string;
    /**
     * State portion of the address.
     * @type {string}
     * @memberof Beneficiary
     */
    'state'?: string;
    /**
     * Additional description suitable for a customer transaction statement.
     * @type {string}
     * @memberof Beneficiary
     */
    'statement_narrative'?: string;
    /**
     * District of the sender\'s or beneficiary\'s city.
     * @type {string}
     * @memberof Beneficiary
     */
    'suburb'?: string;
    /**
     * Tax identification number.
     * @type {string}
     * @memberof Beneficiary
     */
    'tax_id'?: string;
    /**
     * Virtual Payment Address.
     * @type {string}
     * @memberof Beneficiary
     */
    'vpa'?: string;
}


/**
 * 
 * @export
 * @interface BeneficiaryBeneficiaryIdBody
 */
export interface BeneficiaryBeneficiaryIdBody {
    /**
     * Beneficiary\'s street address including the build number.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'address'?: string;
    /**
     * City of the beneficiary.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'city'?: string;
    /**
     * Name of the beneficiary company. Relevant when `entity_type` is **company**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'company_name'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'country'?: string;
    /**
     * The country where the company was registered. Two-letter ISO 3166-1 ALPHA-2 code. Relevant when `entity_type` is **company**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'country_of_incorporation'?: string;
    /**
     * Date of birth of the individual. Format: DD/MM/YYYY. Relevant when `entity_type` is **individual**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'date_of_birth'?: string;
    /**
     * The date when the company was registered. Format: DD/MM/YYYY. Relevant when `entity_type` is **company**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'date_of_incorporation'?: string;
    /**
     * The type of payout method for the beneficiary. The two-letter prefix must match the beneficiary country code.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'default_payout_method_type'?: string;
    /**
     * First name of the beneficiary. Relevant when `entity_type` is **individual**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'first_name'?: string;
    /**
     * Gender of the individual. Relevant when `entity_type` is **individual**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'gender'?: BeneficiaryBeneficiaryIdBodyGenderEnum;
    /**
     * Type of identification document for the beneficiary. When `entity_type` is **company**, this field must be**company_registered_number**. When `entity_type` is **individual**:
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'identification_type'?: BeneficiaryBeneficiaryIdBodyIdentificationTypeEnum;
    /**
     * Identification number on the document mentioned in `identification_type`.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'identification_value'?: string;
    /**
     * Family name of the beneficiary. Relevant when `entity_type` is **individual**. Required when `entity_type` is **individual**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'last_name'?: string;
    /**
     * ID defined by the client.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'merchant_reference_id'?: string;
    /**
     * The citizenship of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code for the country. To determine the code for a country, see \'List Countries\'. Relevant when `entity_type` is **individual**.
     * @type {string}
     * @memberof BeneficiaryBeneficiaryIdBody
     */
    'nationality'?: string;
}

export const BeneficiaryBeneficiaryIdBodyGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other',
    NotApplicable: 'not_applicable'
} as const;

export type BeneficiaryBeneficiaryIdBodyGenderEnum = typeof BeneficiaryBeneficiaryIdBodyGenderEnum[keyof typeof BeneficiaryBeneficiaryIdBodyGenderEnum];
export const BeneficiaryBeneficiaryIdBodyIdentificationTypeEnum = {
    DriversLicense: 'drivers_license',
    IdentificationId: 'identification_id',
    InternationalPassport: 'international_passport',
    ResidencePermit: 'residence_permit',
    SocialSecurity: 'social_security',
    WorkPermit: 'work_permit'
} as const;

export type BeneficiaryBeneficiaryIdBodyIdentificationTypeEnum = typeof BeneficiaryBeneficiaryIdBodyIdentificationTypeEnum[keyof typeof BeneficiaryBeneficiaryIdBodyIdentificationTypeEnum];

/**
 * 
 * @export
 * @interface BeneficiaryValidateBody
 */
export interface BeneficiaryValidateBody {
    /**
     * Maximum payout amount to validate, in units of the currency defined in `sender_currency`. Decimal.
     * @type {number}
     * @memberof BeneficiaryValidateBody
     */
    'amount': number;
    /**
     * 
     * @type {BeneficiaryValidateBodyBeneficiary}
     * @memberof BeneficiaryValidateBody
     */
    'beneficiary': BeneficiaryValidateBodyBeneficiary;
    /**
     * Identifier type of beneficiary
     * @type {string}
     * @memberof BeneficiaryValidateBody
     */
    'identifier_type'?: string;
    /**
     * Identifier value to filter with
     * @type {string}
     * @memberof BeneficiaryValidateBody
     */
    'identifier_value'?: string;
    /**
     * The type of the payout method. Set to a value included in the response to List Payout Method Types. The two-letter prefix must match the beneficiary country code.
     * @type {string}
     * @memberof BeneficiaryValidateBody
     */
    'payout_method_type': string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof BeneficiaryValidateBody
     */
    'sender_country': string;
    /**
     * 
     * @type {string}
     * @memberof BeneficiaryValidateBody
     */
    'sender_currency': string;
    /**
     * 
     * @type {EntityType}
     * @memberof BeneficiaryValidateBody
     */
    'sender_entity_type': EntityType;
}


/**
 * @type BeneficiaryValidateBodyBeneficiary
 * String starting with **beneficiary_** or the object describing the beneficiary.
 * @export
 */
export type BeneficiaryValidateBodyBeneficiary = Beneficiary | string;

/**
 * Bank Identification Number (BIN) details. Read-only. Object containing the following fields - * bin_number - BIN number * country - The two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase. * funding - Type of card funding. One of the following [credit, debit, prepaid, unknown] * bank - Name of the issuing bank. Relevant to cards
 * @export
 * @interface BinDetails
 */
export interface BinDetails {
    /**
     * 
     * @type {string}
     * @memberof BinDetails
     */
    'brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof BinDetails
     */
    'bin_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof BinDetails
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BinDetails
     */
    'issuer'?: string;
    /**
     * 
     * @type {string}
     * @memberof BinDetails
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof BinDetails
     */
    'level'?: string;
}
/**
 * 
 * @export
 * @interface CardDetailsCardTokenBody
 */
export interface CardDetailsCardTokenBody {
    /**
     * The color of the card, specified by one of the following formats: `hexadecimal value`  `CSS color name` `RGB` `RGBA`  `black`
     * @type {string}
     * @memberof CardDetailsCardTokenBody
     */
    'card_color'?: string;
    /**
     * Determines the default language of the hosted page. When this parameter is null, the language of the user\'s browser is used. If the language of the user\'s browser cannot be determined, the default language is English
     * @type {string}
     * @memberof CardDetailsCardTokenBody
     */
    'language'?: string;
    /**
     * The URL of the logo image that appears on the card. If the logo is not specified, the name of the merchant appears.
     * @type {string}
     * @memberof CardDetailsCardTokenBody
     */
    'logo'?: string;
    /**
     * The orientation of the logo on the card:   `landscape`  `square` `portrait`      Default value: `landscape` 
     * @type {string}
     * @memberof CardDetailsCardTokenBody
     */
    'logo_orientation'?: string;
}
/**
 * 
 * @export
 * @interface CardDetailsResponse
 */
export interface CardDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof CardDetailsResponse
     */
    'card'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetailsResponse
     */
    'country'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof CardDetailsResponse
     */
    'currency'?: string;
    /**
     * ID of the customer, a string starting with **cus_**.
     * @type {string}
     * @memberof CardDetailsResponse
     */
    'customer'?: string;
    /**
     * ID of the card token hosted page, a string starting with hp_card_
     * @type {string}
     * @memberof CardDetailsResponse
     */
    'id'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If page_expiration is not set, the hosted page expires 14 days after creation. Range is 1 minute to 30 days.
     * @type {number}
     * @memberof CardDetailsResponse
     */
    'page_expiration'?: number;
    /**
     * Limits the page to a specific type of payment method. For example, dk_visa_card
     * @type {string}
     * @memberof CardDetailsResponse
     */
    'payment_method_type'?: string;
    /**
     * 
     * @type {PaymentParams}
     * @memberof CardDetailsResponse
     */
    'payment_params'?: PaymentParams;
    /**
     * 
     * @type {CustomerPaymentMethod}
     * @memberof CardDetailsResponse
     */
    'customer_card_payment_methods'?: CustomerPaymentMethod;
}
/**
 * 
 * @export
 * @interface CardIssuing
 */
export interface CardIssuing {
    /**
     * Time that the card was activated, in Unix time. Response only.
     * @type {number}
     * @memberof CardIssuing
     */
    'activated_at'?: number;
    /**
     * Time that the card was assigned to a cardholder, in Unix time. Response only.
     * @type {number}
     * @memberof CardIssuing
     */
    'assigned_at'?: number;
    /**
     * Reason for blocking the card.
     * @type {string}
     * @memberof CardIssuing
     */
    'blocked_reason'?: string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardIssuing
     */
    'card_id'?: string;
    /**
     * ID of the card program that the card is issued from. String starting with **cardprog_**.
     * @type {string}
     * @memberof CardIssuing
     */
    'card_program'?: string;
    /**
     * The country where the card is issued. Two-letter ISO 3166-1 ALPHA-2 code. Response only.
     * @type {string}
     * @memberof CardIssuing
     */
    'country_iso_alpha_2'?: string;
    /**
     * Time of creation of the issued card object, in Unix time. Response only.
     * @type {number}
     * @memberof CardIssuing
     */
    'created_at'?: number;
    /**
     * 
     * @type {Contact}
     * @memberof CardIssuing
     */
    'ewallet_contact'?: Contact;
    /**
     * ID of the Issued Card object. String starting with **ci_**.
     * @type {string}
     * @memberof CardIssuing
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof CardIssuing
     */
    'metadata'?: object;
    /**
     * Details of the issued card.
     * @type {object}
     * @memberof CardIssuing
     */
    'public_details'?: object;
    /**
     * Status of the card
     * @type {string}
     * @memberof CardIssuing
     */
    'status'?: string;
    /**
     * Reserved
     * @type {string}
     * @memberof CardIssuing
     */
    'card_tracking_id'?: string;
}
/**
 * 
 * @export
 * @interface CardIssuingMasked
 */
export interface CardIssuingMasked {
    /**
     * Time that the card was activated, in Unix time. Response only.
     * @type {number}
     * @memberof CardIssuingMasked
     */
    'activated_at'?: number;
    /**
     * Time that the card was assigned to a cardholder, in Unix time. Response only.
     * @type {number}
     * @memberof CardIssuingMasked
     */
    'assigned_at'?: number;
    /**
     * Reason for blocking the card.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'blocked_reason'?: string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'card_id'?: string;
    /**
     * ID of the card program that the card is issued from. String starting with **cardprog_**.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'card_program'?: string;
    /**
     * Reserved. Webhook only.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'configuration'?: string;
    /**
     * The country where the card is issued. Two-letter ISO 3166-1 ALPHA-2 code. Response only.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'country_iso_alpha_2'?: string;
    /**
     * Time of creation of the issued card object, in Unix time. Response only.
     * @type {number}
     * @memberof CardIssuingMasked
     */
    'created_at'?: number;
    /**
     * 
     * @type {Contact}
     * @memberof CardIssuingMasked
     */
    'ewallet_contact'?: Contact;
    /**
     * ID of the Issued Card object. String starting with **ci_**.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'metadata'?: string;
    /**
     * Details of the issued card.
     * @type {object}
     * @memberof CardIssuingMasked
     */
    'public_details'?: object;
    /**
     * Status of the card
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'status'?: string;
    /**
     * Reserved
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'card_tracking_id'?: string;
    /**
     * Actual card number
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'card_number'?: string;
    /**
     * Card security code
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'cvv'?: string;
    /**
     * Expiration month of the card. Two digits. Relevant when the card issuer supports it for the country.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'expiration_month'?: string;
    /**
     * Expiration year of the card. Two digits. Relevant when the card issuer supports it for the country.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'expiration_year'?: string;
    /**
     * Bank Identifier Number for the institution issuing the card. Response only.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'bin'?: string;
    /**
     * Two-digit code.
     * @type {string}
     * @memberof CardIssuingMasked
     */
    'sub_bin'?: string;
}
/**
 * 
 * @export
 * @interface CardTokenResponse
 */
export interface CardTokenResponse {
    /**
     * Indicates whether the hosted page displays address fields to fill in.<BR> * **true** - The address fields are displayed. <BR> * **false** - The address fields are displayed only for country codes **US**, **GB** and **CA**.
     * @type {boolean}
     * @memberof CardTokenResponse
     */
    'billing_address_collect'?: boolean;
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'cancel_url'?: string;
    /**
     * 
     * @type {CardTokenResponseCardFields}
     * @memberof CardTokenResponse
     */
    'card_fields'?: CardTokenResponseCardFields;
    /**
     * Category of payment method: **card**.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'category'?: string;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'complete_url'?: string;
    /**
     * URL where the customer is redirected when payment is successful, after returning from an external page such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'complete_payment_url'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'country'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code. <BR> In FX transactions: <BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet. <BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer. <BR> See also `fixed_side` and `requested_currency` fields.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'currency'?: string;
    /**
     * ID of a specific customer. String starting with **cus_**.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'customer'?: string;
    /**
     * Relevant error message and ID number of the error.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'error_code'?: string;
    /**
     * URL where the customer is redirected when payment is not successful, after returning from an external page, such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'error_payment_url'?: string;
    /**
     * ID of the card token hosted page, a string starting with **hp_card_**.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see [List Supported Languages](https://docs.rapyd.net/en/list-supported-languages.html). <BR> * When this parameter is null, the language of the user\'s browser is used. <BR> If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'language'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal. See [Customizing Your Hosted Page](https://docs.rapyd.net/en/customizing-your-hosted-page.html).
     * @type {string}
     * @memberof CardTokenResponse
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof CardTokenResponse
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when one or both of the following fields is unset: <BR>* `cancel_url` <BR>* `complete_url`.<BR> To configure this field, use the **Fallback URL** field in the Client Portal. See [Customizing Your Hosted Page](https://docs.rapyd.net/en/customizing-your-hosted-page.html).
     * @type {string}
     * @memberof CardTokenResponse
     */
    'merchant_website'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation. Range: 1 minute to 30 days.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'page_expiration'?: string;
    /**
     * Limits the page to a specific type of payment method. For example, **dk_visa_card**. For a list of payment methods, use []List Payment Methods by Country](https://docs.rapyd.net/en/list-payment-methods-by-country.html).
     * @type {string}
     * @memberof CardTokenResponse
     */
    'payment_method_type'?: string;
    /**
     * 
     * @type {CardTokenResponsePaymentParams}
     * @memberof CardTokenResponse
     */
    'payment_params'?: CardTokenResponsePaymentParams;
    /**
     * URL of the hosted page that is shown to the customer.Contains the following fields. When these fields do not include values, the user is redirected to the hosted page, and a related status message appears at the top of the page.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'redirect_url'?: string;
    /**
     * Status of the hosted page. One of the following: <BR> * **NEW** - The hosted page was created. <BR> * **DON** - Done. The card was added to the customer profile. <BR> * **EXP** - The hosted page expired.URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof CardTokenResponse
     */
    'status'?: string;
}
/**
 * Contains details about the card.
 * @export
 * @interface CardTokenResponseCardFields
 */
export interface CardTokenResponseCardFields {
    /**
     * Specifies the primary intended purpose of the saved payment method. See Saving a European Card While Creating a Payment. One of the following values: <BR> * **installment - Regular payments for a defined number of payment cycles.** <BR> * **recurring** - Regular payments for an indefinite period. <BR> * **unscheduled** - Individual unrelated payments.
     * @type {string}
     * @memberof CardTokenResponseCardFields
     */
    'recurrence_type'?: string;
}
/**
 * Contains the following fields. When these fields do not include values, the user is redirected to the hosted page, and a related status message appears at the top of the page.
 * @export
 * @interface CardTokenResponsePaymentParams
 */
export interface CardTokenResponsePaymentParams {
    /**
     * URL where the customer is redirected when payment is successful, after returning from an external page such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CardTokenResponsePaymentParams
     */
    'complete_payment_url'?: string;
    /**
     * URL where the customer is redirected when payment is not successful, after returning from an external page, such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CardTokenResponsePaymentParams
     */
    'error_payment_url'?: string;
}
/**
 * 
 * @export
 * @interface CardTokensGooglePayBody
 */
export interface CardTokensGooglePayBody {
    /**
     * Stable device identification set by the wallet provider. Could be a computer identifier or an ID tied to hardware such as TEE_ID or SE_ID.
     * @type {string}
     * @memberof CardTokensGooglePayBody
     */
    'client_device_id': string;
    /**
     * The token requester’s Id (TRID).
     * @type {string}
     * @memberof CardTokensGooglePayBody
     */
    'client_wallet_provider': string;
    /**
     * Client provided consumer ID that identifies the wallet account holder entity.
     * @type {string}
     * @memberof CardTokensGooglePayBody
     */
    'client_wallet_account_id': string;
}
/**
 * 
 * @export
 * @interface CardTransaction
 */
export interface CardTransaction {
    /**
     * Amount of the transaction, in units defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. Response only.
     * @type {number}
     * @memberof CardTransaction
     */
    'amount'?: number;
    /**
     * Authorization code sent to the merchant. Relevant to authorizations approved by Rapyd. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'auth_code'?: string;
    /**
     * Approver of the transaction when remote authorization is used. See Remote Authorization.
     * @type {string}
     * @memberof CardTransaction
     */
    'authorization_approved_by'?: string;
    /**
     * The first 6 digits of the card number. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'bin'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransaction
     */
    'card_authorization'?: string;
    /**
     * ID of the card. String starting with card_. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'card_id'?: string;
    /**
     * ID of the card program that the card is issued from. String starting with **cardprog_**. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'card_program'?: string;
    /**
     * Time of creation of the transaction object, in Unix time. Response only.
     * @type {number}
     * @memberof CardTransaction
     */
    'created_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardTransaction
     */
    'currency'?: string;
    /**
     * The exchange rate. Response only.
     * @type {number}
     * @memberof CardTransaction
     */
    'fx_rate'?: number;
    /**
     * ID of the issued card transaction object. String starting with **cit_**.
     * @type {string}
     * @memberof CardTransaction
     */
    'id'?: string;
    /**
     * Type of the transaction.
     * @type {string}
     * @memberof CardTransaction
     */
    'issuing_txn_type'?: string;
    /**
     * The last 4 digits of the card number. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'last4'?: string;
    /**
     * Four-digit merchant category code (MCC) of the initiator of the transaction, as defined in ISO 18245. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'merchant_category_code'?: string;
    /**
     * Name and location of the merchant. Maximum 40 characters. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'merchant_name_location'?: string;
    /**
     * ID of the original card transaction. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'original_transaction_id'?: string;
    /**
     * Original amount for FX transactions, when currency is different from original_txn_currency. Response only.
     * @type {number}
     * @memberof CardTransaction
     */
    'original_txn_amount'?: number;
    /**
     * Original currency in FX transaction. Three-letter ISO 4217 code. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'original_txn_currency'?: string;
    /**
     * The mode of the POS entry. One of the following
     * @type {string}
     * @memberof CardTransaction
     */
    'pos_entry_mode'?: CardTransactionPosEntryModeEnum;
    /**
     * Reserved.
     * @type {string}
     * @memberof CardTransaction
     */
    'retrieval_reference_number'?: string;
    /**
     * Reserved
     * @type {string}
     * @memberof CardTransaction
     */
    'systems_trace_audit_number'?: string;
    /**
     * ID of the wallet transaction. String starting with **wt_**. Response only.
     * @type {string}
     * @memberof CardTransaction
     */
    'wallet_transaction_id'?: string;
}

export const CardTransactionPosEntryModeEnum = {
    Magstripe: 'magstripe',
    ManualEntered: 'manual_entered',
    Emv: 'emv',
    EmvStandin: 'emv_standin',
    Nfc: 'nfc',
    NetworkToken: 'network_token',
    Ecommerce: 'ecommerce',
    _3dsEcommerce: '3ds_ecommerce',
    Adjustment: 'adjustment'
} as const;

export type CardTransactionPosEntryModeEnum = typeof CardTransactionPosEntryModeEnum[keyof typeof CardTransactionPosEntryModeEnum];

/**
 * 
 * @export
 * @interface CardsActivateBody
 */
export interface CardsActivateBody {
    /**
     * The card token, which is a string starting with \'card_\'. If the client is PCI-certified, you can use the actual card number.
     * @type {string}
     * @memberof CardsActivateBody
     */
    'card': string;
}
/**
 * 
 * @export
 * @interface CardsAdjustmentBody
 */
export interface CardsAdjustmentBody {
    /**
     * The amount of the adjustment, in units of the `currency` defined in currency. Decimal.
     * @type {number}
     * @memberof CardsAdjustmentBody
     */
    'amount': number;
    /**
     * ID of the authorization. String starting with **cardauth_**. Use the value of `id` in the response to \'Simulate a Card Transaction Authorization Request - EEA\'.
     * @type {string}
     * @memberof CardsAdjustmentBody
     */
    'authorization_id': string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardsAdjustmentBody
     */
    'card_id': string;
    /**
     * The adjustment currency. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof CardsAdjustmentBody
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface CardsAuthorizationBody
 */
export interface CardsAuthorizationBody {
    /**
     * The amount of the authorization, in units of the `currency` defined in currency. Decimal.
     * @type {number}
     * @memberof CardsAuthorizationBody
     */
    'amount': number;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardsAuthorizationBody
     */
    'card_id': string;
    /**
     * The currency supported by the card. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof CardsAuthorizationBody
     */
    'currency': string;
    /**
     * Indicates the financial impact of the transaction.
     * @type {string}
     * @memberof CardsAuthorizationBody
     */
    'financial_impact': CardsAuthorizationBodyFinancialImpactEnum;
}

export const CardsAuthorizationBodyFinancialImpactEnum = {
    Credit: 'credit',
    Debit: 'debit'
} as const;

export type CardsAuthorizationBodyFinancialImpactEnum = typeof CardsAuthorizationBodyFinancialImpactEnum[keyof typeof CardsAuthorizationBodyFinancialImpactEnum];

/**
 * 
 * @export
 * @interface CardsClearingBody
 */
export interface CardsClearingBody {
    /**
     * The amount of the authorization, in units of the `currency` defined in currency. Decimal.
     * @type {number}
     * @memberof CardsClearingBody
     */
    'amount': number;
    /**
     * ID of the authorization. String starting with **cardauth_**. Use the value of `id` in the response to Simulate a Card Transaction Authorization Request - EEA.
     * @type {string}
     * @memberof CardsClearingBody
     */
    'authorization_id': string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardsClearingBody
     */
    'card_id': string;
    /**
     * Type of charge: **ATM**. Required when `fee_amount` is set.
     * @type {string}
     * @memberof CardsClearingBody
     */
    'category'?: string;
    /**
     * Defines the currency for the transaction. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof CardsClearingBody
     */
    'currency': string;
    /**
     * The amount of the fee charged for the transaction, in units of the currency defined in `currency`. Decimal. Required when `category` is set.
     * @type {string}
     * @memberof CardsClearingBody
     */
    'fee_amount'?: string;
}
/**
 * 
 * @export
 * @interface CardsPersonalizeBody
 */
export interface CardsPersonalizeBody {
    /**
     * The card token, which is a string starting with **card_**. If the client is PCI-certified, you can use the actual card number.
     * @type {string}
     * @memberof CardsPersonalizeBody
     */
    'card': string;
    /**
     * ID of the wallet contact that the card is issued to. String starting with **cont_**.
     * @type {string}
     * @memberof CardsPersonalizeBody
     */
    'ewallet_contact': string;
}
/**
 * 
 * @export
 * @interface CardsPinBody
 */
export interface CardsPinBody {
    /**
     * Card number or card ID.
     * @type {string}
     * @memberof CardsPinBody
     */
    'card': string;
    /**
     * PIN code. Numeric string.
     * @type {string}
     * @memberof CardsPinBody
     */
    'new_pin': string;
}
/**
 * 
 * @export
 * @interface CardsRefundBody
 */
export interface CardsRefundBody {
    /**
     * The amount of the refund, in units of the `currency` defined in currency. Decimal.
     * @type {number}
     * @memberof CardsRefundBody
     */
    'amount': number;
    /**
     * ID of the authorization. String starting with **cardauth_**. Use the value of `id` in the response to \'Simulate a Card Transaction Authorization Request - EEA\'.
     * @type {string}
     * @memberof CardsRefundBody
     */
    'authorization_id': string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardsRefundBody
     */
    'card_id': string;
    /**
     * The refund currency. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof CardsRefundBody
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface CardsReversalBody
 */
export interface CardsReversalBody {
    /**
     * The amount of the authorization, in units of the `currency` defined in currency. Decimal.
     * @type {number}
     * @memberof CardsReversalBody
     */
    'amount'?: number;
    /**
     * ID of the authorization. String starting with **cardauth_**. Use the value of `id` in the response to Simulate a Card Transaction Authorization Request - EEA.
     * @type {string}
     * @memberof CardsReversalBody
     */
    'authorization_id': string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardsReversalBody
     */
    'card_id': string;
    /**
     * Defines the currency for the transaction. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof CardsReversalBody
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface CardsSimulateBlockBody
 */
export interface CardsSimulateBlockBody {
    /**
     * Reason for blocking the card.
     * @type {string}
     * @memberof CardsSimulateBlockBody
     */
    'blocked_reason'?: string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof CardsSimulateBlockBody
     */
    'card_id': string;
}
/**
 * 
 * @export
 * @interface CardsStatusBody
 */
export interface CardsStatusBody {
    /**
     * Reason for blocking the card. Relevant when the value of status is block.
     * @type {string}
     * @memberof CardsStatusBody
     */
    'blocked_reason'?: string;
    /**
     * The card token, which is a string starting with **card_**. If the client is PCI-certified, you can use the actual card number.
     * @type {string}
     * @memberof CardsStatusBody
     */
    'card': string;
    /**
     * Status of the card. One of the following, block/unblock
     * @type {string}
     * @memberof CardsStatusBody
     */
    'status': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Category = {
    Bank: 'bank',
    Card: 'card',
    Cash: 'cash',
    Ewallet: 'ewallet',
    RapydEwallet: 'rapyd_ewallet',
    BankRedirect: 'bank_redirect',
    BankTransfer: 'bank_transfer'
} as const;

export type Category = typeof Category[keyof typeof Category];


/**
 * 
 * @export
 * @interface CheckoutPageResponse
 */
export interface CheckoutPageResponse {
    /**
     * Determines the default language of the hosted page. When this parameter is null, the language of the user\'s browser is used. If the language of the user\'s browser cannot be determined, the default language is English
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'language'?: string;
    /**
     * Reserved, the default name is Rapyd
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof CheckoutPageResponse
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_logo'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when one or both of the following fields is unset: <BR>* `cancel_url` <BR>* `complete_url`.<BR> To configure this field, use the Client Portal
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_website'?: string;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'redirect_url'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Portal
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_terms'?: string;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing Close to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'complete_url'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_privacy_policy'?: string;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof CheckoutPageResponse
     */
    'page_expiration'?: number;
    /**
     * 
     * @type {HostedPageStatus}
     * @memberof CheckoutPageResponse
     */
    'status'?: HostedPageStatus;
    /**
     * Details of an account funding transaction (AFT), which transfers funds from a card to a cardholder\'s wallet.
     * @type {object}
     * @memberof CheckoutPageResponse
     */
    'account_funding_transaction'?: object;
    /**
     * The amount of the payment, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {number}
     * @memberof CheckoutPageResponse
     */
    'amount'?: number;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'cancel_checkout_url'?: string;
    /**
     * 
     * @type {HostedPageAdditionalResponseCartItems}
     * @memberof CheckoutPageResponse
     */
    'cart_items'?: HostedPageAdditionalResponseCartItems;
    /**
     * URL where the customer is redirected after pressing Finish to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'complete_checkout_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'country'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'currency'?: string;
    /**
     * Description of the payment transaction. To display the description, set display_description to true in custom_elements.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'customer'?: string;
    /**
     * Determines whether the payment is held in escrow for later release.
     * @type {boolean}
     * @memberof CheckoutPageResponse
     */
    'escrow'?: boolean;
    /**
     * Determines the number of days after creation of the payment that funds are released from escrow. Funds are released at 5:00 pm GMT on the day indicated. Integer, range: 1-90.
     * @type {number}
     * @memberof CheckoutPageResponse
     */
    'escrow_release_days'?: number;
    /**
     * ID of the Rapyd checkout page. String starting with **checkout_**.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'id'?: string;
    /**
     * A string that represents the text on the main Call to Action (CTA) button. One of the following:<BR>* place_your_order - Place Your Order.<BR>* pay - Pay.<BR>* pay_now - Pay Now.<BR>* make_payment - Make Payment.<BR>* purchase - Purchase.<BR>* buy - Buy.<BR>* donate - Donate.<BR>* To configure this button, use the Client Portal.
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'merchant_main_button'?: string;
    /**
     * 
     * @type {HostedPageAdditionalResponseCustomElements}
     * @memberof CheckoutPageResponse
     */
    'custom_elements'?: HostedPageAdditionalResponseCustomElements;
    /**
     * 
     * @type {Payment}
     * @memberof CheckoutPageResponse
     */
    'payment'?: Payment;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof CheckoutPageResponse
     */
    'payment_expiration'?: number;
    /**
     * The type of the payment method. For example, **it_visa_card**
     * @type {string}
     * @memberof CheckoutPageResponse
     */
    'payment_method_type'?: string;
    /**
     * A list of the categories of payment method that are supported on the checkout page. The categories appear on the page in the order provided
     * @type {Array<string>}
     * @memberof CheckoutPageResponse
     */
    'payment_method_type_categories'?: Array<string>;
    /**
     * List of payment methods that are excluded from display on the checkout page.
     * @type {Array<string>}
     * @memberof CheckoutPageResponse
     */
    'payment_method_types_exclude'?: Array<string>;
    /**
     * List of payment methods that are displayed on the checkout page. The payment methods appear on the page in the order provided.
     * @type {Array<string>}
     * @memberof CheckoutPageResponse
     */
    'payment_method_types_include'?: Array<string>;
    /**
     * Time of creation of the checkout page, in Unix time.
     * @type {number}
     * @memberof CheckoutPageResponse
     */
    'timestamp'?: number;
}


/**
 * 
 * @export
 * @interface CheckoutSubscriptionsBody
 */
export interface CheckoutSubscriptionsBody {
    /**
     * Determines the method of billing. Set to **pay_automatically**.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'billing': string;
    /**
     * Determines the last date that charges accrue.<BR>* **true** - Charges accrue until the end of the current billing period, then the subscription is canceled. When no trial period is set, after this parameter is set to **true** the subscription will not be renewed at the next interval. When a trial period is set after this parameter is set to true, the subscription will not begin.<BR>* **false** - When the subscription is created, no end is defined. When Cancel Subscription is run, charges stop immediately and the subscription is canceled.
     * @type {boolean}
     * @memberof CheckoutSubscriptionsBody
     */
    'cancel_at_period_end'?: boolean;
    /**
     * URL where the customer is redirected when payment is successful, after returning from an external page such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'complete_payment_url'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'country'?: string;
    /**
     * The ID of a coupon to apply a discount to the subscription. If the coupon defines a fixed monetary discount, it must use the same currency as the subscription. String starting with **coupon_**.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'coupon'?: string;
    /**
     * ID of the customer who pays for this subscription. String starting with **cus_**.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'customer': string;
    /**
     * Number of days from the invoice date for customer to complete the payment.
     * @type {number}
     * @memberof CheckoutSubscriptionsBody
     */
    'days_until_due'?: number;
    /**
     * URL where the customer is redirected when payment is not successful, after returning from an external page, such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'error_payment_url'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see \'List Supported Languages\'. <BR> * When this parameter is null, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'language'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof CheckoutSubscriptionsBody
     */
    'metadata'?: object;
    /**
     * Defines the text for the call-to-action button on the subscription checkout page.<BR> * When there is no trial period, the values are: **subscribe** (default), **purchase**, **pay** <BR> When there is a trial period, the value is **start_trial** (default).
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'merchant_main_button'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof CheckoutSubscriptionsBody
     */
    'merchant_reference_id'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If page_expiration is not set, the hosted page expires 14 days after creation.<BR> Range: 1 minute to 30 days.
     * @type {number}
     * @memberof CheckoutSubscriptionsBody
     */
    'page_expiration'?: number;
    /**
     * 
     * @type {Fee}
     * @memberof CheckoutSubscriptionsBody
     */
    'payment_fees'?: Fee | null;
    /**
     * 
     * @type {Payment}
     * @memberof CheckoutSubscriptionsBody
     */
    'payment_fields'?: Payment;
    /**
     * 
     * @type {CheckoutSubscriptionsBodyPaymentMethod}
     * @memberof CheckoutSubscriptionsBody
     */
    'payment_method'?: CheckoutSubscriptionsBodyPaymentMethod;
    /**
     * Array of subscription items. Each item contains a plan (required) and a quantity
     * @type {Array<V1paymentssubscriptionsSubscriptionItems>}
     * @memberof CheckoutSubscriptionsBody
     */
    'subscription_items': Array<V1paymentssubscriptionsSubscriptionItems>;
    /**
     * The percentage of tax that is applied to the entire amount of the invoice.
     * @type {number}
     * @memberof CheckoutSubscriptionsBody
     */
    'tax_percent'?: number;
    /**
     * The date and time of the end of the customer\'s free trial period, in Unix time, or the string **now**. Takes precedence over `trial_period_days`. If `trial_end` is not set by the client, Rapyd calculates this date by adding `trial_period_days` to the date in `created_at`. <BR> Relevant when `trial_period_days` is not defined.
     * @type {number}
     * @memberof CheckoutSubscriptionsBody
     */
    'trial_end'?: number;
    /**
     * Determines whether a free trial period can be defined in a \'plan\' object attached to the subscription.<BR> * **true** - Free trials can be defined in plans that are attached to the subscription. <BR> * **false** - Definitions of free trial in plans are ignored.
     * @type {boolean}
     * @memberof CheckoutSubscriptionsBody
     */
    'trial_from_plan'?: boolean;
    /**
     * The number of days in the customer\'s free trial period. Integer. Range: 0-730. This value takes precedence over trial periods that are defined in a plan. Relevant when `trial_end` is not defined.The number of days in the customer\'s free trial period.
     * @type {number}
     * @memberof CheckoutSubscriptionsBody
     */
    'trial_period_days'?: number;
}
/**
 * @type CheckoutSubscriptionsBodyPaymentMethod
 * Payment Method object or ID.
 * @export
 */
export type CheckoutSubscriptionsBodyPaymentMethod = PaymentMethodType | string;

/**
 * 
 * @export
 * @interface CheckoutUrlResponse
 */
export interface CheckoutUrlResponse {
    /**
     * URL where the customer is redirected after pressing Finish to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutUrlResponse
     */
    'complete_checkout_url'?: string;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CheckoutUrlResponse
     */
    'cancel_checkout_url'?: string;
}
/**
 * Describes the fields in the client_details object in REST messages for payments. The client_details object describes the browser that the customer is using. The client collects this information and sends it as part of the Create Payment request. This information is used for processing the 3DS version 2 authentication of the customer. Note that Client Details information is not returned in the API response and it does not appear in any webhooks.
 * @export
 * @interface ClientDetailsObject
 */
export interface ClientDetailsObject {
    /**
     * IP address of the customer.
     * @type {string}
     * @memberof ClientDetailsObject
     */
    'ip_address'?: string;
    /**
     * Indicates whether the browser is enabled for Java.
     * @type {boolean}
     * @memberof ClientDetailsObject
     */
    'java_enabled'?: boolean;
    /**
     * Indicates whether the browser is enabled for JavaScript.
     * @type {boolean}
     * @memberof ClientDetailsObject
     */
    'java_script_enabled'?: boolean;
    /**
     * The language the browser is configured for, as defined in IETF BCP 47.
     * @type {string}
     * @memberof ClientDetailsObject
     */
    'language'?: string;
    /**
     * Indicates the screen color depth of the customer\'s browser, in bits.
     * @type {number}
     * @memberof ClientDetailsObject
     */
    'screen_color_depth'?: ClientDetailsObjectScreenColorDepthEnum;
    /**
     * Height of the customer\'s screen, in pixels. 1-6 digits.
     * @type {number}
     * @memberof ClientDetailsObject
     */
    'screen_height'?: number;
    /**
     * Width of the customer\'s screen, in pixels. 1-6 digits.
     * @type {number}
     * @memberof ClientDetailsObject
     */
    'screen_width'?: number;
    /**
     * Difference in minutes between UTC and the customer\'s time zone. Positive or negative integer.
     * @type {number}
     * @memberof ClientDetailsObject
     */
    'time_zone_offset'?: number;
}

export const ClientDetailsObjectScreenColorDepthEnum = {
    NUMBER_1: 1,
    NUMBER_4: 4,
    NUMBER_8: 8,
    NUMBER_15: 15,
    NUMBER_16: 16,
    NUMBER_24: 24,
    NUMBER_32: 32,
    NUMBER_48: 48
} as const;

export type ClientDetailsObjectScreenColorDepthEnum = typeof ClientDetailsObjectScreenColorDepthEnum[keyof typeof ClientDetailsObjectScreenColorDepthEnum];

/**
 * 
 * @export
 * @interface CnlTerminationQueryBody
 */
export interface CnlTerminationQueryBody {
    /**
     * ID of the merchant, defined by the partner.<BR>Length: 0-60
     * @type {string}
     * @memberof CnlTerminationQueryBody
     */
    'partner_merchant_reference': string;
    /**
     * Unique ID of the query request, defined by the partner.<BR>Length: 0-60
     * @type {string}
     * @memberof CnlTerminationQueryBody
     */
    'partner_query_reference': string;
    /**
     * 
     * @type {V1cnlterminationQuerySearchCriteria}
     * @memberof CnlTerminationQueryBody
     */
    'search_criteria'?: V1cnlterminationQuerySearchCriteria;
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchant}
     * @memberof CnlTerminationQueryBody
     */
    'queried_merchant': V1cnlterminationQueryQueriedMerchant;
}
/**
 * 
 * @export
 * @interface CollectCardBody
 */
export interface CollectCardBody {
    /**
     * Indicates whether the hosted page displays address fields to fill in.<BR> * **true** - The address fields are displayed. <BR> * **false** - The address fields are displayed only for country codes **US**, **GB** and **CA**.
     * @type {boolean}
     * @memberof CollectCardBody
     */
    'billing_address_collect'?: boolean;
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof CollectCardBody
     */
    'cancel_url'?: string;
    /**
     * 
     * @type {V1hostedcollectcardCardFields}
     * @memberof CollectCardBody
     */
    'card_fields'?: V1hostedcollectcardCardFields;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof CollectCardBody
     */
    'complete_url'?: string;
    /**
     * URL where the customer is redirected when payment is successful, after returning from an external page such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CollectCardBody
     */
    'complete_payment_url'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof CollectCardBody
     */
    'country': string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code. <BR> In FX transactions: <BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet. <BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer. <BR> See also `fixed_side` and `requested_currency` fields.
     * @type {string}
     * @memberof CollectCardBody
     */
    'currency'?: string;
    /**
     * ID of a specific customer. String starting with **cus_**. Restricts the payment link to the customer.
     * @type {string}
     * @memberof CollectCardBody
     */
    'customer': string;
    /**
     * URL where the customer is redirected when payment is not successful, after returning from an external page, such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof CollectCardBody
     */
    'error_payment_url'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see [List Supported Languages](https://docs.rapyd.net/en/list-supported-languages.html). <BR> * When this parameter is null, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof CollectCardBody
     */
    'language'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation. Range: 1 minute to 30 days.
     * @type {string}
     * @memberof CollectCardBody
     */
    'page_expiration'?: string;
    /**
     * Limits the page to a specific type of payment method. For example, **dk_visa_card**. For a list of payment methods, use [List Payment Methods by Country](https://docs.rapyd.net/en/list-payment-methods-by-country.html).
     * @type {string}
     * @memberof CollectCardBody
     */
    'payment_method_type'?: string;
}
/**
 * 
 * @export
 * @interface CollectPaymentsBody
 */
export interface CollectPaymentsBody {
    /**
     * The amount of the payment, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.<BR> On the hosted payment page, the customer: <BR> * Cannot modify the amount when amount_is_editable is false or not used. <BR> * Can modify the amount when amount_is_editable is true and amount has a positive value. <BR> * Must enter an amount when amount_is_editable is true and amount is 0, null, or not used.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'amount': string;
    /**
     * Determines whether the customer can edit the amount. <BR> * **true** - The customer can edit the amount. <BR> * **false** - The customer cannot edit the amount.
     * @type {boolean}
     * @memberof CollectPaymentsBody
     */
    'amount_is_editable'?: boolean;
    /**
     * Optional parameters for the checkout page.
     * @type {object}
     * @memberof CollectPaymentsBody
     */
    'checkout'?: object;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'country': string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code. <BR> In FX transactions: <BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet. <BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer. <BR> See also `fixed_side` and `requested_currency` fields.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'currency': string;
    /**
     * ID of a specific customer. String starting with **cus_**. Restricts the payment link to the customer.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'customer'?: string;
    /**
     * Indicates whether the FX rate is fixed for the buy side (seller) or for the sell side (buyer).<BR>* **buy** - The currency that the Rapyd Wallet receives for goods or services. Fixed side buy relates to the seller (merchant) funds. For example, a US-based merchant wants to charge 100 USD. The buyer (customer) pays the amount in MXN that converts to 100 USD.<BR>* **sell** - The currency that the buyer is charged for purchasing goods or services. Fixed side sell relates to the buyer (customer) funds. For example, a US-based merchant wants to charge a buyer 2,000 MXN and will accept whatever amount in USD that is converted from 2,000 MXN.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'fixed_side'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see \'List Supported Languages\'. <BR> * When this parameter is null, the language of the user\'s browser is used. <BR> If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'language'?: string;
    /**
     * Indicates the maximum number of times that the payment link can be used for payments. When not indicated, there is no limit.
     * @type {number}
     * @memberof CollectPaymentsBody
     */
    'max_payments'?: number;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'merchant_reference_id'?: string;
    /**
     * Currency for one side of an FX transaction. Three-letter ISO 4217 code. <BR><BR>* When `fixed_side` is **sell**, it is the currency received in the Rapyd Wallet. <BR><BR>* When `fixed_side` is **buy**, it is the currency charged to the buyer (customer).
     * @type {string}
     * @memberof CollectPaymentsBody
     */
    'requested_currency'?: string;
}
/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * Description of the condition
     * @type {string}
     * @memberof Condition
     */
    'description'?: string;
    /**
     * The name of a field, including the path. The field is the first operand of the condition. The path starts with one of the following - * payment - The field is a Create Payment body parameter. Not relevant to the payment_method and payment_method_options objects. * payment.payment_method_type - The field appears in the current Get Payment Method Required Fields response under fields or payment_method_options. * organization - The field relates to your organization, such as your merchant type category. Your organization specifies the field when activating your account. See Activating Your Account (KYB)
     * @type {string}
     * @memberof Condition
     */
    'element_name'?: string;
    /**
     * A symbol representing the operator of the condition. String starting with $. The operator determines the relationship between the operands See documentation - \"https://docs.rapyd.net/en/payment-method-type.html\"
     * @type {string}
     * @memberof Condition
     */
    'operator'?: string;
    /**
     * 
     * @type {ConditionThresholdValue}
     * @memberof Condition
     */
    'threshold_value'?: ConditionThresholdValue;
}
/**
 * @type ConditionThresholdValue
 * One or more possible values of the element_name field. The second operand of the condition \"https://docs.rapyd.net/en/payment-method-type.html\"
 * @export
 */
export type ConditionThresholdValue = number | string;

/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {Address}
     * @memberof Contact
     */
    'address'?: Address;
    /**
     * 
     * @type {ContactBusiness}
     * @memberof Contact
     */
    'business_details'?: ContactBusiness;
    /**
     * Indicates the degree to which this contact can use the wallet.
     * @type {number}
     * @memberof Contact
     */
    'compliance_profile'?: number;
    /**
     * Type of contact.
     * @type {string}
     * @memberof Contact
     */
    'contact_type'?: ContactContactTypeEnum;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof Contact
     */
    'country'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'created_at'?: number;
    /**
     * Date of birth of the individua
     * @type {string}
     * @memberof Contact
     */
    'date_of_birth'?: string;
    /**
     * Email address of the contact
     * @type {string}
     * @memberof Contact
     */
    'email'?: string;
    /**
     * ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @type {string}
     * @memberof Contact
     */
    'ewallet'?: string;
    /**
     * First name of the personal contact or primary person associated with the business contact.
     * @type {string}
     * @memberof Contact
     */
    'first_name'?: string;
    /**
     * Gender of the personal contact or primary person associated with the business contact
     * @type {string}
     * @memberof Contact
     */
    'gender'?: ContactGenderEnum;
    /**
     * Description of the type of residency at the contact\'s residence.
     * @type {string}
     * @memberof Contact
     */
    'house_type'?: ContactHouseTypeEnum;
    /**
     * ID of the contact object. String starting with cont_.
     * @type {string}
     * @memberof Contact
     */
    'id'?: string;
    /**
     * ID number as shown by the ID document.
     * @type {string}
     * @memberof Contact
     */
    'identification_number'?: string;
    /**
     * Type of the identification document associated with the contact. Uppercase.
     * @type {string}
     * @memberof Contact
     */
    'identification_type'?: string;
    /**
     * Describes additional information about the business contact for a company wallet.
     * @type {object}
     * @memberof Contact
     */
    'issued_card_data'?: object;
    /**
     * Family name of the personal contact or primary person associated with the business contact. Required for issuing a card to a personal contact.
     * @type {string}
     * @memberof Contact
     */
    'last_name'?: string;
    /**
     * Marital status of the personal contact or primary person associated with the business contact.
     * @type {string}
     * @memberof Contact
     */
    'marital_status'?: ContactMaritalStatusEnum;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Contact
     */
    'metadata'?: object;
    /**
     * Middle name of the personal contact or primary person associated with the business contact.
     * @type {string}
     * @memberof Contact
     */
    'middle_name'?: string;
    /**
     * Name of the contact\'s mother
     * @type {string}
     * @memberof Contact
     */
    'mothers_name'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof Contact
     */
    'nationality'?: string;
    /**
     * Phone number of the contact in E.164 format.
     * @type {string}
     * @memberof Contact
     */
    'phone_number'?: string;
    /**
     * Second last name of the personal contact or primary person associated with the business contact.
     * @type {string}
     * @memberof Contact
     */
    'second_last_name'?: string;
    /**
     * Determines whether Rapyd sends notifications to the contact. Default is false.
     * @type {boolean}
     * @memberof Contact
     */
    'send_notifications'?: boolean;
    /**
     * Result of the verification check.
     * @type {string}
     * @memberof Contact
     */
    'verification_status'?: ContactVerificationStatusEnum;
    /**
     * Reference ID for the contact. Limited to 45 characters. Should be unique per merchant per e-wallet.
     * @type {string}
     * @memberof Contact
     */
    'contact_reference_id'?: string;
}

export const ContactContactTypeEnum = {
    Personal: 'personal',
    Business: 'business'
} as const;

export type ContactContactTypeEnum = typeof ContactContactTypeEnum[keyof typeof ContactContactTypeEnum];
export const ContactGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other',
    NotApplicable: 'not_applicable'
} as const;

export type ContactGenderEnum = typeof ContactGenderEnum[keyof typeof ContactGenderEnum];
export const ContactHouseTypeEnum = {
    Lease: 'lease',
    LiveWithFamily: 'live_with_family',
    Own: 'own',
    Owner: 'owner',
    MonthToMonth: 'month_to_month',
    HousingProject: 'housing_project'
} as const;

export type ContactHouseTypeEnum = typeof ContactHouseTypeEnum[keyof typeof ContactHouseTypeEnum];
export const ContactMaritalStatusEnum = {
    Married: 'married',
    Single: 'single',
    Divorced: 'divorced',
    Widowed: 'widowed',
    Cohabiting: 'cohabiting',
    NotApplicable: 'not_applicable'
} as const;

export type ContactMaritalStatusEnum = typeof ContactMaritalStatusEnum[keyof typeof ContactMaritalStatusEnum];
export const ContactVerificationStatusEnum = {
    NotVerified: 'not verified',
    Kycd: 'KYCd'
} as const;

export type ContactVerificationStatusEnum = typeof ContactVerificationStatusEnum[keyof typeof ContactVerificationStatusEnum];

/**
 * 
 * @export
 * @interface ContactBusiness
 */
export interface ContactBusiness {
    /**
     * 
     * @type {Address}
     * @memberof ContactBusiness
     */
    'address'?: Address;
    /**
     * Annual revenue of the business in US dollars. Maximum value 100000000000000. Decimal.
     * @type {number}
     * @memberof ContactBusiness
     */
    'annual_revenue'?: number;
    /**
     * Business activity code of the business, according to the ClassificaÃ§Ã£o Nacional de Atividades EconÃ´micas of Brazil. Alphanumeric string. Maximum 7 characters.
     * @type {string}
     * @memberof ContactBusiness
     */
    'cnae_code'?: string;
    /**
     * Time of creation of the business_details object, in Unix time. Response only.
     * @type {number}
     * @memberof ContactBusiness
     */
    'created_at'?: number;
    /**
     * Type of business entity
     * @type {string}
     * @memberof ContactBusiness
     */
    'entity_type'?: ContactBusinessEntityTypeEnum;
    /**
     * Date that the business was established. Format YYYY-MM-DD
     * @type {string}
     * @memberof ContactBusiness
     */
    'establishment_date'?: string;
    /**
     * ID of the business_details object. String starting with busi_.
     * @type {string}
     * @memberof ContactBusiness
     */
    'id'?: string;
    /**
     * Name of the industry that this business belongs to. Required. Alphanumeric string with no special characters.
     * @type {string}
     * @memberof ContactBusiness
     */
    'industry_category'?: string;
    /**
     * Subcategory of the industry that this business belongs to.
     * @type {string}
     * @memberof ContactBusiness
     */
    'industry_sub_category'?: string;
    /**
     * Type of legal entity. Alphanumeric string.
     * @type {string}
     * @memberof ContactBusiness
     */
    'legal_entity_type'?: string;
    /**
     * Business name.
     * @type {string}
     * @memberof ContactBusiness
     */
    'name'?: string;
    /**
     * Registration number.
     * @type {string}
     * @memberof ContactBusiness
     */
    'registration_number'?: string;
}

export const ContactBusinessEntityTypeEnum = {
    SoleProp: 'sole_prop',
    Partnership: 'partnership',
    Company: 'company',
    Government: 'government',
    Charity: 'charity',
    Npo: 'NPO',
    Association: 'association',
    Trust: 'trust'
} as const;

export type ContactBusinessEntityTypeEnum = typeof ContactBusinessEntityTypeEnum[keyof typeof ContactBusinessEntityTypeEnum];

/**
 * The coupon can be applied to the following objects - * Subscription - All charges in the subscription are subject to the discount described in the coupon. To add a coupon to a subscription, first use Create Coupon. Then add the coupon ID to the coupon field of the subscription with Create Subscription or Update Subscription. * Customer - The discount applies to all charges to the customer. To add a coupon to a customer, first use Create Coupon. Then add the coupon ID to the coupon field of the customer with Create Customer or Update Customer. * Order - The discount applies to a single order. To add a coupon to an order, first use Create Coupon. The duration field of the coupon must be set to repeating, and the duration_in_months and discount_duration_in_uses fields must be set to 1. Then add the coupon ID to the coupon field of the order with Create an Order or Update Order. A coupon can be applied to one or more customers or subscriptions. However, a subscription can have only one coupon, and the only way to assign two or more coupons to a customer is to assign them to separate subscriptions. If there is a coupon for the customer and another coupon for the customer\'s subscription, the subscription coupon takes precedence.
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * The amount of money to subtract from the payment. Decimal. Range: Positive decimal number, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {number}
     * @memberof Coupon
     */
    'amount_off'?: number;
    /**
     * When the coupon was created, in Unix time. Response only.
     * @type {number}
     * @memberof Coupon
     */
    'created'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Coupon
     */
    'currency'?: string;
    /**
     * Description of the coupon.
     * @type {string}
     * @memberof Coupon
     */
    'description'?: string;
    /**
     * The number of times that the coupon can be redeemed by a specific customer or subscription. Relevant when duration is repeating and redeem_by is not set.
     * @type {number}
     * @memberof Coupon
     */
    'discount_duration_in_uses'?: number;
    /**
     * The final date that a discount can be used, in Unix time. Relevant when discount_validity_in_months is not set.
     * @type {number}
     * @memberof Coupon
     */
    'discount_valid_until'?: number;
    /**
     * The number of months after the discount is created that it can be used. Relevant when discount_valid_until is not set.
     * @type {number}
     * @memberof Coupon
     */
    'discount_validity_in_months'?: number;
    /**
     * Determines how long the discount remains in effect. One of the following:  * forever  * repeating 
     * @type {string}
     * @memberof Coupon
     */
    'duration'?: 'forever' | 'repeating';
    /**
     * Determines the number of months that the coupon remains in effect after its creation. Integer. Required when duration is repeating.
     * @type {number}
     * @memberof Coupon
     */
    'duration_in_months'?: number;
    /**
     * Unique ID for this coupon. English alphanumeric characters with no special characters except underscore. If the merchant does not define an ID, Rapyd generates a string starting with **coupon_**.
     * @type {string}
     * @memberof Coupon
     */
    'id'?: string;
    /**
     * Determines the number of times the coupon can be redeemed. The number of customers, subscriptions or orders that the coupon is applied to cannot exceed this number. Integer.
     * @type {number}
     * @memberof Coupon
     */
    'max_redemptions'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Coupon
     */
    'metadata'?: object;
    /**
     * Determines the size of the discount, measured in percent. Integer. Range: 1-100.
     * @type {number}
     * @memberof Coupon
     */
    'percent_off'?: number;
    /**
     * The last time at which the coupon can be redeemed, in Unix time. After the redeem_by date, the coupon can no longer be applied to new customers. \'redeem_by\' takes precedence over the setting of **discount_duration_in_uses** and **duration_in_months**.
     * @type {number}
     * @memberof Coupon
     */
    'redeem_by'?: number;
    /**
     * Indicates the number of times the coupon has been applied to a customer, subscription or invoice. If the discount has been used more than one time by a customer, subscription or invoice, the number of redemptions after the first is also added to this value. Integer. When this value equals **max_redemptions**, the coupon becomes no longer valid. Response only.
     * @type {number}
     * @memberof Coupon
     */
    'times_redeemed'?: number;
    /**
     * Indicates whether the coupon can be redeemed.
     * @type {boolean}
     * @memberof Coupon
     */
    'valid'?: boolean;
}
/**
 * customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {Array<Address1>}
     * @memberof Customer
     */
    'addresses'?: Array<Address1>;
    /**
     * The tax ID number of the customer. Relevant when the customer is a business
     * @type {string}
     * @memberof Customer
     */
    'business_vat_id'?: string;
    /**
     * Time of creation of this customer, in Unix time. Response only
     * @type {number}
     * @memberof Customer
     */
    'created_at'?: number;
    /**
     * The payment method that is used when the \'payment\' object or subscription does not specify a payment method. The value must also appear in the payment_methods list. The payment method is referenced by its name field.
     * @type {string}
     * @memberof Customer
     */
    'default_payment_method'?: string;
    /**
     * Indicates whether there is currently a failure of an automatic payment that is part of a subscription, or an invoice that was not paid when due. Response only. true - The account is delinquent. false - The account is current
     * @type {boolean}
     * @memberof Customer
     */
    'delinquent'?: boolean;
    /**
     * A text description of the customer
     * @type {string}
     * @memberof Customer
     */
    'description'?: string;
    /**
     * 
     * @type {Discount}
     * @memberof Customer
     */
    'discount'?: Discount | null;
    /**
     * Customer\'s email address. Maximum 512 characters
     * @type {string}
     * @memberof Customer
     */
    'email'?: string;
    /**
     * ID of the wallet that is linked to the customer. String starting with **ewallet_**. Each wallet can be associated with only one customer
     * @type {string}
     * @memberof Customer
     */
    'ewallet'?: string;
    /**
     * ID of the Customer object. String starting with **cus_**
     * @type {string}
     * @memberof Customer
     */
    'id'?: string;
    /**
     * A custom string that is prefixed to all invoices for this customer. For more information see Invoice Object at \"https://docs.rapyd.net/en/invoice-364856.html\"
     * @type {string}
     * @memberof Customer
     */
    'invoice_prefix'?: string;
    /**
     * A JSON object defined by the client
     * @type {object}
     * @memberof Customer
     */
    'metadata'?: object;
    /**
     * The name of the customer
     * @type {string}
     * @memberof Customer
     */
    'name': string;
    /**
     * 
     * @type {CustomerPaymentMethods}
     * @memberof Customer
     */
    'payment_methods'?: CustomerPaymentMethods;
    /**
     * Customer\'s primary phone number in E.164 format. The merchant is responsible for verifying that the number is correct. One method of verifying could be to send an activation code to the phone by SMS, with a limited time for response.
     * @type {string}
     * @memberof Customer
     */
    'phone_number'?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof Customer
     */
    'subscriptions'?: Array<Subscription>;
}
/**
 * Describes the fields relating to discounts in REST messages and webhooks for customer profiles and subscriptions Contains information about the coupon that applies to the customer. Read-only field. Adding a discount is a 2-step process - 1. Create Coupon, which returns a coupon ID. 2. Add the coupon ID to the coupon field of the customer with Create Customer or Update Customer.
 * @export
 * @interface CustomerDiscount
 */
export interface CustomerDiscount {
    /**
     * 
     * @type {Coupon}
     * @memberof CustomerDiscount
     */
    'coupon'?: Coupon | null;
    /**
     * ID of the Customer object that the discount applies to. String starting with cus_. Response only.
     * @type {string}
     * @memberof CustomerDiscount
     */
    'customer'?: string;
    /**
     * The final time that a discount can be used, in Unix time. When the value is -1, the discount never expires. Response only.
     * @type {number}
     * @memberof CustomerDiscount
     */
    'end'?: number;
    /**
     * ID of the Discount object. String starting with dis_. Response only.
     * @type {string}
     * @memberof CustomerDiscount
     */
    'id'?: string;
    /**
     * The number of times that the discount was used for a specific customer or subscription. The initial value is 0. The value is incremented by 1 each time that the discount is used. Response only.
     * @type {number}
     * @memberof CustomerDiscount
     */
    'number_of_uses'?: number;
    /**
     * The time that a discount was created, in Unix time. Response only.
     * @type {number}
     * @memberof CustomerDiscount
     */
    'start'?: number;
    /**
     * ID of the Subscription object that the discount applies to. String starting with sub_. Response only.
     * @type {string}
     * @memberof CustomerDiscount
     */
    'subscription'?: string;
    /**
     * Indicates whether the discount can be used. Response only.
     * @type {boolean}
     * @memberof CustomerDiscount
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomerIdPaymentMethodsBody
 */
export interface CustomerIdPaymentMethodsBody {
    /**
     * 
     * @type {PaymentMethodType}
     * @memberof CustomerIdPaymentMethodsBody
     */
    'data'?: PaymentMethodType;
}
/**
 * Describes the fields contained in REST messages and webhooks for payment methods saved to a customer profile
 * @export
 * @interface CustomerPaymentMethod
 */
export interface CustomerPaymentMethod {
    /**
     * 
     * @type {Category}
     * @memberof CustomerPaymentMethod
     */
    'category'?: Category;
    /**
     * Hash of the card number, expiration date and CVV. Read-only. Relevant to cards.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'fingerprint_token'?: string;
    /**
     * ID of the Payment Method object. String starting with card_ or other_
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'id'?: string;
    /**
     * A URL to the image of the icon for the type of payment method. Response only
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'image'?: string;
    /**
     * last4 - Last four digits of the card number. Read-only. Relevant to cards
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'last4'?: string;
    /**
     * A JSON object defined by the client
     * @type {object}
     * @memberof CustomerPaymentMethod
     */
    'metadata'?: object;
    /**
     * The name of the customer
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'name'?: string;
    /**
     * Identifier for use in a recurring card payment. In recurring payments, use the network reference ID you got from the response or webhook when adding the payment method to the customer. In the payment_method.fields object, use it in place of the cvv field, along with the other required fields for the card payment method. This field cannot be used together with a payment method ID or a customer ID. Note that for all payments, you must use the network reference ID from adding the payment method to the customer. The response in each subsequent payment contains a different network reference ID, which is not for use in requests. Relevant to clients with PCI certification who have been authorized to use this feature
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'network_reference_id'?: string;
    /**
     * 
     * @type {NextAction}
     * @memberof CustomerPaymentMethod
     */
    'next_action'?: NextAction;
    /**
     * URL where the customer is redirected for additional steps required for the payment. Response only. To simulate 3DS authentication in the sandbox, see Simulating 3DS Authentication - \"https://docs.rapyd.net/en/simulating-3ds-authentication---api-method.html\"
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'redirect_url'?: string;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'supporting_documentation'?: string;
    /**
     * ID of the token that represents the card. String starting with card_. Relevant to cards. Relevant if the value of is_tokenizable is true for the payment method in the response to List Payment Methods by Country. See Payment Method Type Object at \"https://docs.rapyd.net/en/payment-method-type-364771.html\"
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'token'?: string;
    /**
     * Name of the payment method type. For example, us_mastercard_card. To get a list of payment methods for a country, use List Payment Methods by Country.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'type'?: string;
    /**
     * Reserved. Response only
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'webhook_url'?: string;
    /**
     * BIC (SWIFT) code for the bank account.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'bic_swift'?: string;
    /**
     * Last four digits of the bank account number or IBAN (International Bank Account Number).
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'account_last4'?: string;
    /**
     * Customer\'s last name.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'last_name'?: string;
    /**
     * Customer\'s first name.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'first_name'?: string;
    /**
     * Results of the Access Control Server (ACS) check. Possible values: * pass *fail * unavailable *unchecked * Relevant to cards.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'acs_check'?: string;
    /**
     * Verification of the card’s CVV. Valid values: * pass * fail * unavailable *  unchecked
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'cvv_check'?: string;
    /**
     * 
     * @type {BinDetails}
     * @memberof CustomerPaymentMethod
     */
    'bin_details'?: BinDetails;
    /**
     * Year of expiration.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'expiration_year'?: string;
    /**
     * Month of expiration.
     * @type {string}
     * @memberof CustomerPaymentMethod
     */
    'expiration_month'?: string;
}


/**
 * An object containing the following fields - * data - A list of up to three payment methods. For more information, see Customer Payment Method Object. * has_more - Indicates whether there are more than three payment methods for this customer. * total_count - Total number of payment methods for this customer. * url - URL for requesting all of the payment methods for this customer..
 * @export
 * @interface CustomerPaymentMethods
 */
export interface CustomerPaymentMethods {
    /**
     * 
     * @type {Array<CustomerPaymentMethod>}
     * @memberof CustomerPaymentMethods
     */
    'data'?: Array<CustomerPaymentMethod>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerPaymentMethods
     */
    'has_more'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CustomerPaymentMethods
     */
    'total_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerPaymentMethods
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CustomerRequest
 */
export interface CustomerRequest {
    /**
     * Array of address objects associated with this customer. For more information
     * @type {Array<Address1>}
     * @memberof CustomerRequest
     */
    'addresses'?: Array<Address1>;
    /**
     * The tax ID number of the customer
     * @type {string}
     * @memberof CustomerRequest
     */
    'business_vat_id'?: string;
    /**
     * The ID of a coupon that is assigned to this customer
     * @type {string}
     * @memberof CustomerRequest
     */
    'coupon'?: string;
    /**
     * 
     * @type {CustomerRequestPaymentMethod}
     * @memberof CustomerRequest
     */
    'payment_method'?: CustomerRequestPaymentMethod;
    /**
     * A text description of the customer
     * @type {string}
     * @memberof CustomerRequest
     */
    'description'?: string;
    /**
     * Customer\'s email address
     * @type {string}
     * @memberof CustomerRequest
     */
    'email'?: string;
    /**
     * ID of the wallet that is linked to the customer. String starting with **ewallet_**.
     * @type {string}
     * @memberof CustomerRequest
     */
    'ewallet'?: string;
    /**
     * A custom string that is prefixed to all invoices for this customer.
     * @type {string}
     * @memberof CustomerRequest
     */
    'invoice_prefix'?: string;
    /**
     * A JSON object defined by the Rapyd partner
     * @type {object}
     * @memberof CustomerRequest
     */
    'metadata'?: object;
    /**
     * The name of the individual customer or the business name
     * @type {string}
     * @memberof CustomerRequest
     */
    'name'?: string;
    /**
     * Customer\'s primary phone number in E.164 format
     * @type {string}
     * @memberof CustomerRequest
     */
    'phone_number'?: string;
}
/**
 * The payment method that is used when the transaction does not specify a payment method. String starting with **card_** or other_.
 * @export
 * @interface CustomerRequestPaymentMethod
 */
export interface CustomerRequestPaymentMethod {
    /**
     * Payment Method Type required field
     * @type {Array<Field1>}
     * @memberof CustomerRequestPaymentMethod
     */
    'fields'?: Array<Field1>;
    /**
     * Type of the payment method. For example, it_visa_card
     * @type {string}
     * @memberof CustomerRequestPaymentMethod
     */
    'type'?: string;
}
/**
 * Describes currency conversion for payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
 * @export
 * @interface DailyRate
 */
export interface DailyRate {
    /**
     * The type of transaction that the currency exchange applies to. One of the following - payment, payout
     * @type {string}
     * @memberof DailyRate
     */
    'action_type'?: string;
    /**
     * If fixed_side is buy, the value of amount. If fixed_side is sell, the value of buy_currency following the currency exchange transaction. Relevant when amount and `fixed_side` are specified.
     * @type {number}
     * @memberof DailyRate
     */
    'buy_amount'?: number;
    /**
     * The currency purchased in the currency exchange transaction. Three-letter ISO 4217 code. Uppercase.
     * @type {string}
     * @memberof DailyRate
     */
    'buy_currency'?: string;
    /**
     * The date when the rate is applicable. Today or earlier. Format is YYYY-MM-DD. Default is today.
     * @type {string}
     * @memberof DailyRate
     */
    'date'?: string;
    /**
     * Indicates which currency the rate is fixed for. One of the following : * buy - The currency defined by buy_currency. * sell : The currency defined by sell_currency.
     * @type {string}
     * @memberof DailyRate
     */
    'fixed_side'?: string;
    /**
     * The exchange rate. Includes FX markup fees.
     * @type {number}
     * @memberof DailyRate
     */
    'rate'?: number;
    /**
     * If `fixed_side` is **sell**, the value of amount. If `fixed_side` is **buy**, the value of `sell_currency` following the currency exchange transaction. Relevant when `amount` and `fixed_side` are specified.
     * @type {number}
     * @memberof DailyRate
     */
    'sell_amount'?: number;
    /**
     * Selling currency
     * @type {string}
     * @memberof DailyRate
     */
    'sell_currency'?: string;
}
/**
 * 
 * @export
 * @interface DisburseBeneficiaryBody
 */
export interface DisburseBeneficiaryBody {
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country of the beneficiary’s bank account. The two-letter prefix of the payout method type matches the beneficiary country code.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'beneficiary_country'?: string;
    /**
     * Type of entity for the beneficiary. One of the following:
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'beneficiary_entity_type': DisburseBeneficiaryBodyBeneficiaryEntityTypeEnum;
    /**
     * When the value is **true**, the hosted tokenization page displays additional required fields.<BR> * Additional required fields when `beneficiary_entity_type` is **individual**: `address`, `city`, `country`, `date_of_birth`, `first_name`, `gender`, `identification_type`, `identification_value`, `last_name`, `nationality`. <BR> * Additional required fields when `beneficiary_entity_type` is **company**: `address`, `city`, `company_name`, `country`, `country_of_incorporation`, `date_of_incorporation`, `identification_type`, `identification_value`.<BR> For more information on the additional required fields, see \'Create Extended Beneficiary\'.<BR> **Note**: Currently only available in the sandbox.
     * @type {boolean}
     * @memberof DisburseBeneficiaryBody
     */
    'beneficiary_extended_fields'?: boolean;
    /**
     * Additional information about the beneficiary.
     * @type {Array<V1hosteddisbursebeneficiaryBeneficiaryOptionalFields>}
     * @memberof DisburseBeneficiaryBody
     */
    'beneficiary_optional_fields'?: Array<V1hosteddisbursebeneficiaryBeneficiaryOptionalFields>;
    /**
     * The category of payout method. One of the following: <BR> * **bank**<BR> * **card** - US only.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'category'?: DisburseBeneficiaryBodyCategoryEnum;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'complete_url'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see \'List Supported Languages\'.<BR> * When this parameter is null, the language of the user\'s browser is used.<BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'language'?: string;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'merchant_alias'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'merchant_reference_id'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation. <BR> **Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof DisburseBeneficiaryBody
     */
    'page_expiration'?: number;
    /**
     * Currency accepted by the beneficiary’s bank account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'payout_currency'?: string;
    /**
     * List of payout methods that are excluded from display on the beneficiary tokenization page.
     * @type {Array<object>}
     * @memberof DisburseBeneficiaryBody
     */
    'payout_method_types_exclude'?: Array<object>;
    /**
     * Array of strings. List of payout methods that are displayed on the beneficiary tokenization page.
     * @type {Array<object>}
     * @memberof DisburseBeneficiaryBody
     */
    'payout_method_types_include'?: Array<object>;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the sender’s country.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'sender_country': string;
    /**
     * Currency paid from the sender’s wallet. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'sender_currency'?: string;
    /**
     * Type of entity for the sender.
     * @type {string}
     * @memberof DisburseBeneficiaryBody
     */
    'sender_entity_type': DisburseBeneficiaryBodySenderEntityTypeEnum;
}

export const DisburseBeneficiaryBodyBeneficiaryEntityTypeEnum = {
    Company: 'company',
    Individual: 'individual'
} as const;

export type DisburseBeneficiaryBodyBeneficiaryEntityTypeEnum = typeof DisburseBeneficiaryBodyBeneficiaryEntityTypeEnum[keyof typeof DisburseBeneficiaryBodyBeneficiaryEntityTypeEnum];
export const DisburseBeneficiaryBodyCategoryEnum = {
    Bank: 'bank',
    Card: 'card'
} as const;

export type DisburseBeneficiaryBodyCategoryEnum = typeof DisburseBeneficiaryBodyCategoryEnum[keyof typeof DisburseBeneficiaryBodyCategoryEnum];
export const DisburseBeneficiaryBodySenderEntityTypeEnum = {
    Company: 'company',
    Individual: 'individual'
} as const;

export type DisburseBeneficiaryBodySenderEntityTypeEnum = typeof DisburseBeneficiaryBodySenderEntityTypeEnum[keyof typeof DisburseBeneficiaryBodySenderEntityTypeEnum];

/**
 * Describes the fields relating to discounts in REST messages and webhooks for customer profiles and subscriptions Contains information about the coupon that applies to the customer. Read-only field. Adding a discount is a 2-step process: <BR> 1. Create Coupon, which returns a coupon ID. <BR>2. Add the coupon ID to the coupon field of the customer with Create Customer or Update Customer.
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {Coupon}
     * @memberof Discount
     */
    'coupon'?: Coupon | null;
    /**
     * ID of the Customer object that the discount applies to. String starting with **cus_**. Response only.
     * @type {string}
     * @memberof Discount
     */
    'customer'?: string;
    /**
     * The final time that a discount can be used, in Unix time. When the value is -1, the discount never expires. Response only.
     * @type {number}
     * @memberof Discount
     */
    'end'?: number;
    /**
     * ID of the Discount object. String starting with **dis_**. Response only.
     * @type {string}
     * @memberof Discount
     */
    'id'?: string;
    /**
     * The number of times that the discount was used for a specific customer or subscription. The initial value is 0. The value is incremented by 1 each time that the discount is used. Response only.
     * @type {number}
     * @memberof Discount
     */
    'number_of_uses'?: number;
    /**
     * The time that a discount was created, in Unix time. Response only.
     * @type {number}
     * @memberof Discount
     */
    'start'?: number;
    /**
     * ID of the Subscription object that the discount applies to. String starting with **sub_**. Response only.
     * @type {string}
     * @memberof Discount
     */
    'subscription'?: string;
    /**
     * Indicates whether the discount can be used. Response only.
     * @type {boolean}
     * @memberof Discount
     */
    'valid'?: boolean;
}
/**
 * Describes the fields relating to discounts in REST messages and webhooks for customer profiles and subscriptions Contains information about the coupon that applies to the customer. Read-only field. Adding a discount is a 2-step process: <BR> 1. Create Coupon, which returns a coupon ID. <BR>2. Add the coupon ID to the coupon field of the customer with Create Customer or Update Customer.
 * @export
 * @interface DiscountCustomerResponse
 */
export interface DiscountCustomerResponse {
    /**
     * 
     * @type {Coupon}
     * @memberof DiscountCustomerResponse
     */
    'coupon'?: Coupon | null;
    /**
     * ID of the Customer object that the discount applies to. String starting with **cus_**. Response only.
     * @type {string}
     * @memberof DiscountCustomerResponse
     */
    'customer'?: string;
    /**
     * The final time that a discount can be used, in Unix time. When the value is -1, the discount never expires. Response only.
     * @type {number}
     * @memberof DiscountCustomerResponse
     */
    'end'?: number;
    /**
     * ID of the Discount object. String starting with **dis_**. Response only.
     * @type {string}
     * @memberof DiscountCustomerResponse
     */
    'id'?: string;
    /**
     * The number of times that the discount was used for a specific customer or subscription. The initial value is 0. The value is incremented by 1 each time that the discount is used. Response only.
     * @type {number}
     * @memberof DiscountCustomerResponse
     */
    'number_of_uses'?: number;
    /**
     * The time that a discount was created, in Unix time. Response only.
     * @type {number}
     * @memberof DiscountCustomerResponse
     */
    'start'?: number;
    /**
     * Indicates whether the discount can be used. Response only.
     * @type {boolean}
     * @memberof DiscountCustomerResponse
     */
    'valid'?: boolean;
}
/**
 * Describes the fields contained in REST messages and webhooks for disputes of payments.
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * Reserved.
     * @type {string}
     * @memberof Dispute
     */
    'id'?: string;
    /**
     * ID of the dispute. String starting with **dispute_**.
     * @type {string}
     * @memberof Dispute
     */
    'token'?: string;
    /**
     * Indicates the status of the dispute operation. One of the following values: * ACT (Active) - The dispute was initiated and is awaiting action by the merchant. * RVW (Review) - Rapyd is reviewing the merchant\'s evidence contesting the dispute. * PRA (Pre-Arbitration) - Rapyd is reviewing the merchant\'s evidence contesting a previously contested dispute. * ARB (Arbitration) - The merchant rejected a pre-arbitration outcome. Rapyd is awaiting a ruling by an arbitration committee from the card schemes. * LOS (Lose) - The merchant lost the dispute. Funds were deducted from the merchant wallet. Final status. * WIN (Win) - The merchant won the dispute. Funds were credited to the merchant wallet. Final status. * REV (Reverse) - The card issuer reversed the dispute. Funds were credited to the merchant wallet. Final status. 
     * @type {string}
     * @memberof Dispute
     */
    'status'?: DisputeStatusEnum;
    /**
     * Amount that Rapyd deducted from the merchant due to the dispute.
     * @type {number}
     * @memberof Dispute
     */
    'amount'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the amount field.
     * @type {string}
     * @memberof Dispute
     */
    'currency'?: string;
    /**
     * The category of dispute that was provided by the card network.
     * @type {string}
     * @memberof Dispute
     */
    'dispute_category'?: string;
    /**
     * A short description of the reason for the dispute.
     * @type {string}
     * @memberof Dispute
     */
    'dispute_reason_description'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Dispute
     */
    'original_transaction_currency'?: string;
    /**
     * Amount of the original payment.
     * @type {number}
     * @memberof Dispute
     */
    'original_transaction_amount'?: number;
    /**
     * Amount of the dispute, as reported to Rapyd.
     * @type {number}
     * @memberof Dispute
     */
    'original_dispute_amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Dispute
     */
    'original_dispute_currency'?: string;
    /**
     * ID of the payment that the dispute is charged against. String starting with **payment_**.
     * @type {string}
     * @memberof Dispute
     */
    'original_transaction_id'?: string;
    /**
     * ID of the wallet that the money is paid into. String starting with **ewallet_**. Relevant when the request includes a single wallet. Response only.
     * @type {string}
     * @memberof Dispute
     */
    'ewallet_id'?: string;
    /**
     * The date the transaction was processed by the card network.
     * @type {number}
     * @memberof Dispute
     */
    'central_processing_date'?: number;
    /**
     * Time of creation of the dispute, in Unix time. Response only.
     * @type {number}
     * @memberof Dispute
     */
    'created_at'?: number;
    /**
     * Time that the dispute was last updated, in Unix time. Response only.
     * @type {number}
     * @memberof Dispute
     */
    'updated_at'?: number;
    /**
     * The latest date for the dispute to be contested in Unix time. Response only.
     * @type {number}
     * @memberof Dispute
     */
    'due_date'?: number;
    /**
     * ID of the payment method. String starting with **card_**.
     * @type {string}
     * @memberof Dispute
     */
    'payment_method'?: string;
    /**
     * Details of the payment method that was used for the payment. See Payment Method Data Object. Response only.
     * @type {object}
     * @memberof Dispute
     */
    'payment_method_data'?: object;
    /**
     * FX rate. Relevant to FX payments.
     * @type {number}
     * @memberof Dispute
     */
    'rate'?: number;
    /**
     * Reserved.
     * @type {string}
     * @memberof Dispute
     */
    'evidence'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof Dispute
     */
    'evidence_reason_code'?: string;
    /**
     * When true, indicates that the disputed payment was automatically refunded based on pre-determined criteria. Response only.
     * @type {boolean}
     * @memberof Dispute
     */
    'pre_dispute'?: boolean;
    /**
     * An Acquirer Reference Number (ARN) is a unique number assigned to a credit card transaction as it moves through the payment flow. Banks can use it to help trace the payment/ refund if it appears to be missing. An ARN will be available for Visa and Mastercard charges. 
     * @type {string}
     * @memberof Dispute
     */
    'arn'?: string;
}

export const DisputeStatusEnum = {
    Act: 'ACT',
    Rvw: 'RVW',
    Pra: 'PRA',
    Arb: 'ARB',
    Los: 'LOS',
    Win: 'WIN',
    Rev: 'REV'
} as const;

export type DisputeStatusEnum = typeof DisputeStatusEnum[keyof typeof DisputeStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EntityType = {
    Company: 'company',
    Individual: 'individual'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeVerify = {
    Partnership: 'Partnership',
    SoleProprietor: 'Sole Proprietor',
    PrivateLimitedCompany: 'Private Limited Company',
    CharityOrNpo: 'Charity or NPO',
    Individual: 'Individual'
} as const;

export type EntityTypeVerify = typeof EntityTypeVerify[keyof typeof EntityTypeVerify];


/**
 * 
 * @export
 * @interface Escrow
 */
export interface Escrow {
    /**
     * 
     * @type {EscrowEwallets}
     * @memberof Escrow
     */
    'ewallets'?: EscrowEwallets;
}
/**
 * 
 * @export
 * @interface EscrowEscrowReleasesBody
 */
export interface EscrowEscrowReleasesBody {
    /**
     * 
     * @type {EscrowEwallets}
     * @memberof EscrowEscrowReleasesBody
     */
    'ewallets': EscrowEwallets;
}
/**
 * Describes the wallets and the releases from escrow.
 * @export
 * @interface EscrowEwallets
 */
export interface EscrowEwallets {
    /**
     * ID of the wallet, a string starting with **ewallet_**.
     * @type {string}
     * @memberof EscrowEwallets
     */
    'ewallet'?: string;
    /**
     * The amount to release to this wallet. Relevant when `percentage` is not set.
     * @type {number}
     * @memberof EscrowEwallets
     */
    'amount'?: number;
    /**
     * The percentage of this escrow to release to this wallet. Relevant when `amount` is not set. On a partial release after the first, this refers to the percentage of the original amount of the escrow.
     * @type {number}
     * @memberof EscrowEwallets
     */
    'percentage'?: number;
}
/**
 * 
 * @export
 * @interface EscrowResponse
 */
export interface EscrowResponse {
    /**
     * Total amount of funds that are currently held in the escrow, in the currency defined in `currency_code` in the payment.
     * @type {number}
     * @memberof EscrowResponse
     */
    'amount_on_hold'?: number;
    /**
     * Date and time the escrow was created, in Unix time.
     * @type {number}
     * @memberof EscrowResponse
     */
    'created_at'?: number;
    /**
     * The currency of the escrow balance. Three-letter ISO 4217 code.
     * @type {number}
     * @memberof EscrowResponse
     */
    'currency'?: number;
    /**
     * 
     * @type {EscrowResponseEscrowReleases}
     * @memberof EscrowResponse
     */
    'escrow_releases'?: EscrowResponseEscrowReleases;
    /**
     * Indicates that the number of escrow releases is greater than the number returned in the response.
     * @type {string}
     * @memberof EscrowResponse
     */
    'id'?: string;
    /**
     * Date and time of the completion of the last payment or partial payment, in Unix time.
     * @type {number}
     * @memberof EscrowResponse
     */
    'last_payment_completion'?: number;
    /**
     * ID of the payment, a string starting with **payment_**.
     * @type {number}
     * @memberof EscrowResponse
     */
    'payment'?: number;
    /**
     * Status of the escrow. One of the following:<BR> * **pending** - The payment and escrow were created, but the payment is not completed and the funds are not in the escrow.<BR> * **on_hold** - The payment is completed and the funds are in escrow. canceled - The escrow is canceled.<BR>* **released** - All or part of the funds have been released to the wallets.
     * @type {string}
     * @memberof EscrowResponse
     */
    'status'?: string;
    /**
     * Total amount of funds that were released to the wallets, in the currency defined in currency_code in the payment response.
     * @type {string}
     * @memberof EscrowResponse
     */
    'total_amount_released'?: string;
    /**
     * Date and time of the last update to the escrow, in Unix time.
     * @type {number}
     * @memberof EscrowResponse
     */
    'updated_at'?: number;
}
/**
 * Array of objects that describe individual releases.
 * @export
 * @interface EscrowResponseEscrowReleases
 */
export interface EscrowResponseEscrowReleases {
    /**
     * 
     * @type {EscrowResponseEscrowReleasesData}
     * @memberof EscrowResponseEscrowReleases
     */
    'data'?: EscrowResponseEscrowReleasesData;
    /**
     * Indicates that the number of escrow releases is greater than the number returned in the response.
     * @type {boolean}
     * @memberof EscrowResponseEscrowReleases
     */
    'has_more'?: boolean;
    /**
     * Number of escrow releases.
     * @type {number}
     * @memberof EscrowResponseEscrowReleases
     */
    'total_count'?: number;
    /**
     * URL for the record of all escrow releases for this payment.
     * @type {string}
     * @memberof EscrowResponseEscrowReleases
     */
    'url'?: string;
}
/**
 * Array of objects that describe individual escrow releases.
 * @export
 * @interface EscrowResponseEscrowReleasesData
 */
export interface EscrowResponseEscrowReleasesData {
    /**
     * The currency of the escrow balance. Three-letter ISO 4217 code.
     * @type {number}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'amount'?: number;
    /**
     * Date and time the escrow release was created, in Unix time.
     * @type {number}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'created_at'?: number;
    /**
     * The currency of the escrow balance. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'currency'?: string;
    /**
     * 
     * @type {EscrowEwallets}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'ewallets'?: EscrowEwallets;
    /**
     * ID of the escrow release, a string starting with **er_**.
     * @type {number}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'id'?: number;
    /**
     * Indicates that the wallets were released in the same proportion that was defined in the Create Payment request.
     * @type {boolean}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'proportional_release'?: boolean;
    /**
     * Indicates what triggered the escrow release. One of the following: <BR> * **event** - Funds were released due to an API request. <BR> **time** - Funds were automatically released at 5:00 p.m. GMT (17:00 GMT) on the day indicated in theCreate Payment request. <BR> **cancel_escrow** - Escrow was canceled.
     * @type {string}
     * @memberof EscrowResponseEscrowReleasesData
     */
    'trigger'?: string;
}
/**
 * 
 * @export
 * @interface Ewallet
 */
export interface Ewallet {
    /**
     * 
     * @type {Array<Account>}
     * @memberof Ewallet
     */
    'accounts'?: Array<Account>;
    /**
     * Indicates the type of client wallet
     * @type {string}
     * @memberof Ewallet
     */
    'category'?: EwalletCategoryEnum;
    /**
     * 
     * @type {EwalletContacts}
     * @memberof Ewallet
     */
    'contacts'?: EwalletContacts;
    /**
     * Email address of the wallet owner. Response only. Deprecated.
     * @type {string}
     * @memberof Ewallet
     */
    'email'?: string;
    /**
     * Wallet ID defined by the customer or end user. Must be unique.
     * @type {string}
     * @memberof Ewallet
     */
    'ewallet_reference_id'?: string;
    /**
     * First name of the wallet owner.
     * @type {string}
     * @memberof Ewallet
     */
    'first_name'?: string;
    /**
     * Unique identifier of the wallet object. String starting with **ewallet_**.
     * @type {string}
     * @memberof Ewallet
     */
    'id'?: string;
    /**
     * Last name of the wallet owner.
     * @type {string}
     * @memberof Ewallet
     */
    'last_name'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Ewallet
     */
    'metadata'?: object;
    /**
     * Phone number of the wallet owner in E.164 format. Response only. Deprecated.
     * @type {string}
     * @memberof Ewallet
     */
    'phone_number'?: string;
    /**
     * Status of the wallet
     * @type {string}
     * @memberof Ewallet
     */
    'status'?: EwalletStatusEnum;
    /**
     * Type of wallet.
     * @type {string}
     * @memberof Ewallet
     */
    'type'?: EwalletTypeEnum;
    /**
     * Result of the verification check.
     * @type {string}
     * @memberof Ewallet
     */
    'verification_status'?: string;
}

export const EwalletCategoryEnum = {
    Collect: 'collect',
    Disburse: 'disburse',
    CardAuthorization: 'card_authorization',
    General: 'general'
} as const;

export type EwalletCategoryEnum = typeof EwalletCategoryEnum[keyof typeof EwalletCategoryEnum];
export const EwalletStatusEnum = {
    Act: 'ACT',
    Dis: 'DIS'
} as const;

export type EwalletStatusEnum = typeof EwalletStatusEnum[keyof typeof EwalletStatusEnum];
export const EwalletTypeEnum = {
    Company: 'company',
    Person: 'person',
    Client: 'client'
} as const;

export type EwalletTypeEnum = typeof EwalletTypeEnum[keyof typeof EwalletTypeEnum];

/**
 * 
 * @export
 * @interface EwalletContacts
 */
export interface EwalletContacts {
    /**
     * 
     * @type {Array<Contact>}
     * @memberof EwalletContacts
     */
    'data'?: Array<Contact>;
    /**
     * 
     * @type {boolean}
     * @memberof EwalletContacts
     */
    'has_more'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EwalletContacts
     */
    'total_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof EwalletContacts
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface EwalletIdContactsBody
 */
export interface EwalletIdContactsBody {
    /**
     * 
     * @type {Address}
     * @memberof EwalletIdContactsBody
     */
    'address'?: Address;
    /**
     * Type of contact: personal.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'contact_type': string;
    /**
     * 2-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'country'?: string;
    /**
     * Date of birth of the individual. Format: MM/DD/YYYY
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'date_of_birth'?: string;
    /**
     * Email address for the contact.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'email'?: string;
    /**
     * First name of the contact.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'first_name'?: string;
    /**
     * Family name of the personal contact or primary person associated with the business contact. For a personal contact type, alphabetic characters and spaces. Required for issuing a card to a personal contact. 
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'last_name'?: string;
    /**
     * Gender of the contact. One of the following values: male, female, other, not_applicable
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'gender'?: string;
    /**
     * Description of the type of residency. One of the following values: lease, live_with_family, own, owner, month_to_month, housing_project
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'house_type'?: string;
    /**
     * ID number as shown by the ID document. Alphanumeric string
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'identification_number'?: string;
    /**
     * Type of the identification document
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'identification_type'?: string;
    /**
     * Marital status of the contact. One of the following values: married, single, divorced, widowed, cohabiting, not_applicable
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'marital_status'?: string;
    /**
     * A JSON object defined by the client.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'metadata'?: string;
    /**
     * Middle name of the personal contact or primary person associated with the business contact.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'middle_name'?: string;
    /**
     * Name of the contact\'s mother.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'mothers_name'?: string;
    /**
     * The citizenship of the contact. Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'nationality'?: string;
    /**
     * Phone number of the contact in E.164 format.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'phone_number'?: string;
    /**
     * Second last name of the contact.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'second_last_name'?: string;
    /**
     * Determines whether Rapyd sends notifications to the contact. Default is false.
     * @type {boolean}
     * @memberof EwalletIdContactsBody
     */
    'send_notifications'?: boolean;
    /**
     * Reference ID for the contact. Limited to 45 characters. Should be unique per merchant per e-wallet.
     * @type {string}
     * @memberof EwalletIdContactsBody
     */
    'contact_reference_id'?: string;
}
/**
 * 
 * @export
 * @interface EwalletTransaction
 */
export interface EwalletTransaction {
    /**
     * 
     * @type {object}
     * @memberof EwalletTransaction
     */
    'metadata'?: object;
    /**
     * Amount of the transaction, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 4217:2015.
     * @type {number}
     * @memberof EwalletTransaction
     */
    'amount'?: number;
    /**
     * The updated wallet balance after successful completion of the transaction.
     * @type {number}
     * @memberof EwalletTransaction
     */
    'balance'?: number;
    /**
     * Balance type affected by the transaction. One of the following
     * @type {string}
     * @memberof EwalletTransaction
     */
    'balance_type'?: EwalletTransactionBalanceTypeEnum;
    /**
     * Time the transaction was made, in Unix time.
     * @type {number}
     * @memberof EwalletTransaction
     */
    'created_at'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the amount field.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'currency'?: string;
    /**
     * The destination balance type when funds are transferred from one balance to another within the wallet.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'destination_balance_type'?: EwalletTransactionDestinationBalanceTypeEnum | null;
    /**
     * ID of the wallet receiving the money. String starting with **ewallet_**. Response only.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'destination_ewallet_id'?: string | null;
    /**
     * ID of the wallet. String starting with **ewallet_**.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'ewallet_id'?: string;
    /**
     * ID of the transaction. String starting with wt_ or UUID.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'id'?: string;
    /**
     * Unique identifier of the wallet object. String starting with **ewallet_**.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'reason'?: string;
    /**
     * The source balance type when funds are transferred from one balance to another within the wallet
     * @type {string}
     * @memberof EwalletTransaction
     */
    'source_balance_type'?: EwalletTransactionSourceBalanceTypeEnum | null;
    /**
     * ID of the wallet sending the money. String starting with **ewallet_**.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'source_ewallet_id'?: string | null;
    /**
     * Status of the transaction.
     * @type {string}
     * @memberof EwalletTransaction
     */
    'status'?: string;
    /**
     * Type of transaction
     * @type {string}
     * @memberof EwalletTransaction
     */
    'type'?: string;
    /**
     * Subtype of the transaction.
     * @type {number}
     * @memberof EwalletTransaction
     */
    'subtype'?: number;
    /**
     * 
     * @type {object}
     * @memberof EwalletTransaction
     */
    'action_data'?: object;
}

export const EwalletTransactionBalanceTypeEnum = {
    AvailableBalance: 'available_balance',
    OnHoldBalance: 'on_hold_balance',
    ReceivedBalance: 'received_balance',
    ReserveBalance: 'reserve_balance'
} as const;

export type EwalletTransactionBalanceTypeEnum = typeof EwalletTransactionBalanceTypeEnum[keyof typeof EwalletTransactionBalanceTypeEnum];
export const EwalletTransactionDestinationBalanceTypeEnum = {
    AvailableBalance: 'available_balance',
    OnHoldBalance: 'on_hold_balance',
    ReceivedBalance: 'received_balance',
    ReserveBalance: 'reserve_balance'
} as const;

export type EwalletTransactionDestinationBalanceTypeEnum = typeof EwalletTransactionDestinationBalanceTypeEnum[keyof typeof EwalletTransactionDestinationBalanceTypeEnum];
export const EwalletTransactionSourceBalanceTypeEnum = {
    AvailableBalance: 'available_balance',
    OnHoldBalance: 'on_hold_balance',
    ReceivedBalance: 'received_balance',
    ReserveBalance: 'reserve_balance'
} as const;

export type EwalletTransactionSourceBalanceTypeEnum = typeof EwalletTransactionSourceBalanceTypeEnum[keyof typeof EwalletTransactionSourceBalanceTypeEnum];

/**
 * @type EwalletTransactionDetails
 * @export
 */
export type EwalletTransactionDetails = EwalletTransaction | EwalletTransaction & EwalletTransactionP2PAdditionlData;

/**
 * 
 * @export
 * @interface EwalletTransactionP2PAdditionlData
 */
export interface EwalletTransactionP2PAdditionlData {
    /**
     * ID of the wallet sending the money. String starting with ewallet_.
     * @type {string}
     * @memberof EwalletTransactionP2PAdditionlData
     */
    'source_ewallet_id'?: string | null;
    /**
     * ID of the wallet receiving the money. String starting with ewallet_. Response only.
     * @type {string}
     * @memberof EwalletTransactionP2PAdditionlData
     */
    'destination_ewallet_id'?: string | null;
}
/**
 * 
 * @export
 * @interface EwalletTransactionP2PDetails
 */
export interface EwalletTransactionP2PDetails {
    /**
     * 
     * @type {object}
     * @memberof EwalletTransactionP2PDetails
     */
    'action_data'?: object;
    /**
     * 
     * @type {object}
     * @memberof EwalletTransactionP2PDetails
     */
    'metadata'?: object;
    /**
     * Amount of the transaction, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 4217:2015.
     * @type {number}
     * @memberof EwalletTransactionP2PDetails
     */
    'amount'?: number;
    /**
     * The updated wallet balance after successful completion of the transaction.
     * @type {number}
     * @memberof EwalletTransactionP2PDetails
     */
    'balance'?: number;
    /**
     * Balance type affected by the transaction. One of the following
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'balance_type'?: EwalletTransactionP2PDetailsBalanceTypeEnum;
    /**
     * Time the transaction was made, in Unix time.
     * @type {number}
     * @memberof EwalletTransactionP2PDetails
     */
    'created_at'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the amount field.
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'currency'?: string;
    /**
     * ID of the wallet. String starting with **ewallet_**.
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'ewallet_id'?: string;
    /**
     * ID of the transaction. String starting with **wt_** or UUID.
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'id'?: string;
    /**
     * Unique identifier of the wallet object. String starting with **ewallet_**.
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'reason'?: string;
    /**
     * Status of the transaction.
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'status'?: string;
    /**
     * Type of transaction
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'type'?: string;
    /**
     * Sub type of the transaction
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'subtype'?: string;
    /**
     * Beneficiary wallet ID
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'destination_ewallet_id'?: string;
    /**
     * Source wallet ID
     * @type {string}
     * @memberof EwalletTransactionP2PDetails
     */
    'source_ewallet_id'?: string;
}

export const EwalletTransactionP2PDetailsBalanceTypeEnum = {
    AvailableBalance: 'available_balance',
    OnHoldBalance: 'on_hold_balance',
    ReceivedBalance: 'received_balance',
    ReserveBalance: 'reserve_balance'
} as const;

export type EwalletTransactionP2PDetailsBalanceTypeEnum = typeof EwalletTransactionP2PDetailsBalanceTypeEnum[keyof typeof EwalletTransactionP2PDetailsBalanceTypeEnum];

/**
 * 
 * @export
 * @interface EwalletsEwalletTokenBody
 */
export interface EwalletsEwalletTokenBody {
    /**
     * Rapyd Wallet ID defined by the customer or end user.  Must be unique.
     * @type {string}
     * @memberof EwalletsEwalletTokenBody
     */
    'ewallet_reference_id'?: string;
    /**
     * First name of the Rapyd Wallet owner.
     * @type {string}
     * @memberof EwalletsEwalletTokenBody
     */
    'first_name'?: string;
    /**
     * Last name of the Rapyd Wallet owner.
     * @type {string}
     * @memberof EwalletsEwalletTokenBody
     */
    'last_name'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof EwalletsEwalletTokenBody
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * 
     * @type {FxFee}
     * @memberof Fee
     */
    'fx_fee'?: FxFee;
    /**
     * The total gross fees for the transaction, in units defined by currency_code. Relevant to responses.
     * @type {number}
     * @memberof Fee
     */
    'gross_fees'?: number;
    /**
     * The total net fees for the transaction, in units defined by `merchant_requested_currency`. Relevant to responses.
     * @type {number}
     * @memberof Fee
     */
    'net_fees'?: number;
    /**
     * 
     * @type {TransactionFee}
     * @memberof Fee
     */
    'transaction_fee'?: TransactionFee;
    /**
     * 
     * @type {number}
     * @memberof Fee
     */
    'total_merchant_fees'?: number;
}
/**
 * Field Object
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * Three-letter alphabetic ISO 4217 code for the official currency used in the country.
     * @type {string}
     * @memberof Field
     */
    'code'?: string;
    /**
     * Whether the field is always required for using the payment method
     * @type {boolean}
     * @memberof Field
     */
    'is_required'?: boolean;
    /**
     * Indicates whether the field can be updated with Update Payment Method
     * @type {boolean}
     * @memberof Field
     */
    'is_updatable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'instructions'?: string;
    /**
     * Name of the currency in English.
     * @type {string}
     * @memberof Field
     */
    'name'?: string;
    /**
     * Three-letter ISO numeric 4217 code for the currency.
     * @type {string}
     * @memberof Field
     */
    'numeric_code'?: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Field
     */
    'required_fields'?: Array<Field>;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'type'?: FieldTypeEnum;
    /**
     * A regular expression that defines the format when type is string.
     * @type {string}
     * @memberof Field
     */
    'regex'?: string;
    /**
     * Defines specific conditions when a field is required for a payment method. When the conditions defined by conditions are met, the field is required even though the value of `is_required` is **false**.
     * @type {Array<FieldConditions>}
     * @memberof Field
     */
    'conditions'?: Array<FieldConditions>;
    /**
     * Description of the field.
     * @type {string}
     * @memberof Field
     */
    'description'?: string;
}

export const FieldTypeEnum = {
    Boolean: 'boolean',
    Number: 'number',
    String: 'string',
    Object: 'object'
} as const;

export type FieldTypeEnum = typeof FieldTypeEnum[keyof typeof FieldTypeEnum];

/**
 * Field Object
 * @export
 * @interface Field1
 */
export interface Field1 {
    /**
     * Three-letter alphabetic ISO 4217 code for the official currency used in the country.
     * @type {string}
     * @memberof Field1
     */
    'code'?: string;
    /**
     * Whether the field is always required for using the payment method
     * @type {boolean}
     * @memberof Field1
     */
    'is_required'?: boolean;
    /**
     * Indicates whether the field can be updated with Update Payment Method
     * @type {boolean}
     * @memberof Field1
     */
    'is_updatable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Field1
     */
    'instructions'?: string;
    /**
     * Name of the currency in English.
     * @type {string}
     * @memberof Field1
     */
    'name'?: string;
    /**
     * Three-letter ISO numeric 4217 code for the currency.
     * @type {string}
     * @memberof Field1
     */
    'numeric_code'?: string;
    /**
     * 
     * @type {Array<Field1>}
     * @memberof Field1
     */
    'required_fields'?: Array<Field1>;
    /**
     * 
     * @type {string}
     * @memberof Field1
     */
    'type'?: Field1TypeEnum;
    /**
     * A regular expression that defines the format when type is string.
     * @type {string}
     * @memberof Field1
     */
    'regex'?: string;
    /**
     * Defines specific conditions when a field is required for a payment method. When the conditions defined by conditions are met, the field is required even though the value of is_required is false.
     * @type {Array<Field1Conditions>}
     * @memberof Field1
     */
    'conditions'?: Array<Field1Conditions>;
    /**
     * Description of the field.
     * @type {string}
     * @memberof Field1
     */
    'description'?: string;
}

export const Field1TypeEnum = {
    Boolean: 'boolean',
    Number: 'number',
    String: 'string'
} as const;

export type Field1TypeEnum = typeof Field1TypeEnum[keyof typeof Field1TypeEnum];

/**
 * 
 * @export
 * @interface Field1Conditions
 */
export interface Field1Conditions {
    /**
     * Description of the condition.
     * @type {string}
     * @memberof Field1Conditions
     */
    'description'?: string;
    /**
     * The name of a field, including the path. The field is the first operand of the condition.
     * @type {string}
     * @memberof Field1Conditions
     */
    'element_name'?: string;
    /**
     * A symbol representing the operator of the condition. String starting with $. The operator determines the relationship between the operands.
     * @type {string}
     * @memberof Field1Conditions
     */
    'operator'?: string;
    /**
     * 
     * @type {Field1ConditionsThresholdValue}
     * @memberof Field1Conditions
     */
    'threshold_value'?: Field1ConditionsThresholdValue;
}
/**
 * @type Field1ConditionsThresholdValue
 * des One or more possible values of the element_name field. The second operand of the condition.
 * @export
 */
export type Field1ConditionsThresholdValue = Array<string> | string;

/**
 * 
 * @export
 * @interface FieldConditions
 */
export interface FieldConditions {
    /**
     * Description of the condition.
     * @type {string}
     * @memberof FieldConditions
     */
    'description'?: string;
    /**
     * The name of a field, including the path. The field is the first operand of the condition.
     * @type {string}
     * @memberof FieldConditions
     */
    'element_name'?: string;
    /**
     * A symbol representing the operator of the condition. String starting with $. The operator determines the relationship between the operands.
     * @type {string}
     * @memberof FieldConditions
     */
    'operator'?: string;
    /**
     * 
     * @type {FieldConditionsThresholdValue}
     * @memberof FieldConditions
     */
    'threshold_value'?: FieldConditionsThresholdValue;
}
/**
 * @type FieldConditionsThresholdValue
 * One or more possible values of the element_name field. The second operand of the condition.
 * @export
 */
export type FieldConditionsThresholdValue = Array<string> | string;

/**
 * Describes the fees for processing the currency exchange. Relevant to payouts with FX.
 * @export
 * @interface FxFee
 */
export interface FxFee {
    /**
     * Specifies how the fee is calculated. One of the following:  * net - The fee is deducted from the amount paid.  For example, in a payout of $100 with a fee of 5%, the recipient receives $95.00 and the $5.00 fee goes to the client wallet.  * gross - The fee is charged on top of the amount paid.  For example, for a transaction of $100 with a fee of 5%, the sender pays $105.00. The recipient receives $100.00 and the $5.00 fee goes to the client wallet. 
     * @type {string}
     * @memberof FxFee
     */
    'calc_type'?: string;
    /**
     * The amount of the fee. Percentage.
     * @type {number}
     * @memberof FxFee
     */
    'value'?: number;
}
/**
 * Gender of the individual. Required when `entity_type` is **individual**.
 * @export
 * @enum {string}
 */

export const Gender = {
    Male: 'male',
    Female: 'female',
    Other: 'other',
    NotApplicable: 'not_applicable'
} as const;

export type Gender = typeof Gender[keyof typeof Gender];


/**
 * Group Payment
 * @export
 * @interface GroupPayment
 */
export interface GroupPayment {
    /**
     * Amount of the group payment, in units defined by `currency`.
     * @type {number}
     * @memberof GroupPayment
     */
    'amount'?: number;
    /**
     * Indicates the total amount of failed payments that have not been replaced.
     * @type {string}
     * @memberof GroupPayment
     */
    'amount_to_replace'?: string;
    /**
     * Reason for cancellation of the group payment.
     * @type {string}
     * @memberof GroupPayment
     */
    'cancel_reason'?: string;
    /**
     * Country where the payment methods are supported. Two-letter ISO 3166-1 ALPHA-2 code.
     * @type {string}
     * @memberof GroupPayment
     */
    'country'?: string;
    /**
     * Currency of the payments. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof GroupPayment
     */
    'currency'?: string;
    /**
     * Description of the group payment.
     * @type {string}
     * @memberof GroupPayment
     */
    'description'?: string;
    /**
     * End of the time allowed for customers to make this payment, in Unix time.
     * @type {number}
     * @memberof GroupPayment
     */
    'expiration'?: number;
    /**
     * ID of the \'group_payment\' object. String starting with **gp_**.
     * @type {string}
     * @memberof GroupPayment
     */
    'id'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof GroupPayment
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client
     * @type {object}
     * @memberof GroupPayment
     */
    'metadata'?: object;
    /**
     * Array of `payment` objects. All payments must have the same currency and must be supported in the same country. For details of the fields in the \'payment\' object.
     * @type {object}
     * @memberof GroupPayment
     */
    'payments'?: object;
    /**
     * Reason for cancellation of the group payment.
     * @type {string}
     * @memberof GroupPayment
     */
    'reason'?: string;
    /**
     * Indicates the status of the group payment operation. One of the following values: <BR>> * **active** - The group payment was created and one or more payments are still open.<BR> * **canceled** - The group payment was canceled. <BR>* **closed** - All payments in the group payment are complete.Response only.
     * @type {string}
     * @memberof GroupPayment
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface HostedBeneficiaryTokenResponse
 */
export interface HostedBeneficiaryTokenResponse {
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country of the beneficiary’s bank account. The two-letter prefix of the payout method type matches the beneficiary country code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_country'?: string;
    /**
     * Currency accepted by the beneficiary’s bank account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_currency'?: string;
    /**
     * Type of entity for the beneficiary. One of the following:
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_entity_type'?: HostedBeneficiaryTokenResponseBeneficiaryEntityTypeEnum;
    /**
     * When the value is **true**, the hosted tokenization page displays additional required fields.<BR> * Additional required fields when `beneficiary_entity_type` is **individual**: `address`, `city`, `country`, `date_of_birth`, `first_name`, `gender`, `identification_type`, `identification_value`, `last_name`, `nationality`. <BR> * Additional required fields when `beneficiary_entity_type` is **company**: `address`, `city`, `company_name`, `country`, `country_of_incorporation`, `date_of_incorporation`, `identification_type`, `identification_value`.<BR> For more information on the additional required fields, see \'Create Extended Beneficiary\'.<BR> **Note**: Currently only available in the sandbox.
     * @type {boolean}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_extended_fields'?: boolean;
    /**
     * ID of the beneficiary. String starting with **beneficiary_**.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_id'?: string;
    /**
     * Additional information about the beneficiary.
     * @type {Array<HostedBeneficiaryTokenResponseBeneficiaryOptionalFields>}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_optional_fields'?: Array<HostedBeneficiaryTokenResponseBeneficiaryOptionalFields>;
    /**
     * Indicates whether the beneficiary has been validated.
     * @type {boolean}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'beneficiary_validated'?: boolean;
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'cancel_url'?: string;
    /**
     * The category of payout method. One of the following: <BR> * **bank**<BR> * **card** - US only.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'category'?: HostedBeneficiaryTokenResponseCategoryEnum;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'complete_url'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the beneficiary’s country. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'country'?: string;
    /**
     * Currency accepted by the beneficiary’s bank account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'currency'?: string;
    /**
     * Type of entity for the beneficiary. One of the following:
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'entity_type'?: HostedBeneficiaryTokenResponseEntityTypeEnum;
    /**
     * The page expiration date in Unix time.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'expiration'?: string;
    /**
     * ID of the beneficiary tokenization page. String starting with **hp_ben_**.The page expiration date in Unix time.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see \'List Supported Languages\'.<BR> * When this parameter is null, the language of the user\'s browser is used.<BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'language'?: string;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page.<BR> To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'merchant_color'?: string;
    /**
     * Contains details of the client’s customer support. To configure these fields, use the Client Portal.
     * @type {Array<HostedBeneficiaryTokenResponseMerchantCustomerSupport>}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'merchant_customer_support'?: Array<HostedBeneficiaryTokenResponseMerchantCustomerSupport>;
    /**
     * URL for the image of the client\'s logo.<BR> To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'merchant_logo'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'merchant_reference_id'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. <BR> Relevant when one or both of the following fields is unset:<BR> * `cancel_url` <BR> * `complete_url`<BR> To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'merchant_website'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation. <BR> **Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'page_expiration'?: number;
    /**
     * Currency accepted by the beneficiary’s bank account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'payout_currency'?: string;
    /**
     * The payout method type selected by the customer. The two-letter prefix must match the beneficiary country code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'payout_method_type'?: string;
    /**
     * List of payout methods that are excluded from display on the beneficiary tokenization page.
     * @type {Array<object>}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'payout_method_types_exclude'?: Array<object>;
    /**
     * Array of strings. List of payout methods that are displayed on the beneficiary tokenization page.
     * @type {Array<object>}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'payout_method_types_include'?: Array<object>;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'redirect_url'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the sender’s country.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'sender_country'?: string;
    /**
     * Currency paid from the sender’s wallet. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'sender_currency'?: string;
    /**
     * Type of entity for the sender. One of the following:.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'sender_entity_type'?: HostedBeneficiaryTokenResponseSenderEntityTypeEnum;
    /**
     * Status of the hosted page. One of the following:<BR>* **NEW** - The hosted page was created.<BR> * **DON** - Done. The beneficiary details were saved.<BR> * **EXP** - The hosted page expired.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'status'?: HostedBeneficiaryTokenResponseStatusEnum;
    /**
     * Timestamp for the request to create the beneficiary tokenization object page, in Unix time.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'timestamp'?: string;
    /**
     * ID of the beneficiary tokenization page. String starting with **hp_ben_**.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponse
     */
    'tokenization_page'?: string;
}

export const HostedBeneficiaryTokenResponseBeneficiaryEntityTypeEnum = {
    Company: 'company',
    Individual: 'individual'
} as const;

export type HostedBeneficiaryTokenResponseBeneficiaryEntityTypeEnum = typeof HostedBeneficiaryTokenResponseBeneficiaryEntityTypeEnum[keyof typeof HostedBeneficiaryTokenResponseBeneficiaryEntityTypeEnum];
export const HostedBeneficiaryTokenResponseCategoryEnum = {
    Bank: 'bank',
    Card: 'card'
} as const;

export type HostedBeneficiaryTokenResponseCategoryEnum = typeof HostedBeneficiaryTokenResponseCategoryEnum[keyof typeof HostedBeneficiaryTokenResponseCategoryEnum];
export const HostedBeneficiaryTokenResponseEntityTypeEnum = {
    Company: 'company',
    Individual: 'individual'
} as const;

export type HostedBeneficiaryTokenResponseEntityTypeEnum = typeof HostedBeneficiaryTokenResponseEntityTypeEnum[keyof typeof HostedBeneficiaryTokenResponseEntityTypeEnum];
export const HostedBeneficiaryTokenResponseSenderEntityTypeEnum = {
    Company: 'company',
    Individual: 'individual'
} as const;

export type HostedBeneficiaryTokenResponseSenderEntityTypeEnum = typeof HostedBeneficiaryTokenResponseSenderEntityTypeEnum[keyof typeof HostedBeneficiaryTokenResponseSenderEntityTypeEnum];
export const HostedBeneficiaryTokenResponseStatusEnum = {
    New: 'NEW',
    Don: 'DON',
    Exp: 'EXP'
} as const;

export type HostedBeneficiaryTokenResponseStatusEnum = typeof HostedBeneficiaryTokenResponseStatusEnum[keyof typeof HostedBeneficiaryTokenResponseStatusEnum];

/**
 * 
 * @export
 * @interface HostedBeneficiaryTokenResponseBeneficiaryOptionalFields
 */
export interface HostedBeneficiaryTokenResponseBeneficiaryOptionalFields {
    /**
     * The name of the beneficiary\'s company. Relevant to beneficiaries that are not individuals. If the request does not contain this information, the hosted page prompts the customer for it. <BR> If `beneficiary_entity_type` is **individual**, this field must be omitted.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseBeneficiaryOptionalFields
     */
    'company_name'?: string;
    /**
     * The first name of the beneficiary. Relevant to individual beneficiaries. If the request does not contain this information, the redirect page prompts the customer for it.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseBeneficiaryOptionalFields
     */
    'first_name'?: string;
    /**
     * Type of identification document. When `entity_type` is **company**, this field must be **company_registered_number**. When `entity_type` is **individual**, one of the following values: <>BR> * **drivers_license**<BR> * **identification_id** <BR> * **international_passport** <BR> * **residence_permit**<BR> * **social_security**<BR> * **work_permit** type: string
     * @type {any}
     * @memberof HostedBeneficiaryTokenResponseBeneficiaryOptionalFields
     */
    'identification_type'?: any;
    /**
     * The identification of the document mentioned in identification_type.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseBeneficiaryOptionalFields
     */
    'identification_value'?: string;
    /**
     * The last name of the beneficiary. Relevant to individual beneficiaries. If the request does not contain this information, the redirect page prompts the customer for it.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseBeneficiaryOptionalFields
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface HostedBeneficiaryTokenResponseMerchantCustomerSupport
 */
export interface HostedBeneficiaryTokenResponseMerchantCustomerSupport {
    /**
     * Email address.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseMerchantCustomerSupport
     */
    'email'?: string;
    /**
     * URL for the client\'s customer support service.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseMerchantCustomerSupport
     */
    'url'?: string;
    /**
     * Phone number for contacting the client\'s customer support service.
     * @type {string}
     * @memberof HostedBeneficiaryTokenResponseMerchantCustomerSupport
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface HostedIdvBody
 */
export interface HostedIdvBody {
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'complete_url'?: string;
    /**
     * ID of the wallet contact. String starting with **cont_**.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'contact': string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country of the identification document. Must match the wallet contact country.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'country': string;
    /**
     * Type of the identification document. Two-letter code.<BR>See also \'List Official Identification Documents\'.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'document_type'?: string;
    /**
     * ID of the Rapyd Wallet. String starting with **ewallet_**.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'ewallet': string;
    /**
     * Requires the applicant to use the device\'s camera for a current face image, and prohibits uploading an existing image file. Default is **false**.
     * @type {boolean}
     * @memberof HostedIdvBody
     */
    'force_camera'?: boolean;
    /**
     * Determines the default language of the hosted page. For a list of values, see [List Supported Languages](https://docs.rapyd.net/en/list-supported-languages.html). <BR> * When this parameter is null, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'language'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation.<BR>**Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof HostedIdvBody
     */
    'page_expiration'?: number;
    /**
     * ID of the identity verification request. Must be unique for each request. Defined by the client.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'reference_id': string;
    /**
     * Determines the action that is taken on the request. One of the following:<BR>* **store** - Store the images on the Rapyd platform.<BR>* **verify** - Verify the identity of the person in the images.
     * @type {string}
     * @memberof HostedIdvBody
     */
    'request_type'?: HostedIdvBodyRequestTypeEnum;
}

export const HostedIdvBodyRequestTypeEnum = {
    Store: 'store',
    Verify: 'verify'
} as const;

export type HostedIdvBodyRequestTypeEnum = typeof HostedIdvBodyRequestTypeEnum[keyof typeof HostedIdvBodyRequestTypeEnum];

/**
 * 
 * @export
 * @interface HostedPageActivateCardResponse
 */
export interface HostedPageActivateCardResponse {
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'complete_url'?: string;
    /**
     * ID of the wallet contact that the card is assigned to. Must have a valid phone number. String starting with **cont_**.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'ewallet_contact'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'geo_country'?: string;
    /**
     * ID of the hosted page for activating a card, a string starting with **hp_issuing_act_**.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page.<BR>* When this parameter is null, the language of the user\'s browser is used.<BR>* If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'language'?: string;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_logo'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers.<BR>To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_privacy_policy'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Porta
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_terms'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when `cancel_url`, `complete_url` or both fields are not set. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'merchant_website'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation.<BR>**Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof HostedPageActivateCardResponse
     */
    'page_expiration'?: number;
    /**
     * When **true**, connects an issued card to a wallet contact. Relevant to a card that was issued in bulk and is not assigned to a specific person. Transparent to the customer. See also \'Personalize Bulk-Issued Card\' in online documentation.
     * @type {number}
     * @memberof HostedPageActivateCardResponse
     */
    'personalize'?: number;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'redirect_url'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof HostedPageActivateCardResponse
     */
    'region'?: string;
    /**
     * When **true**, the customer cannot reset the PIN via a hosted page.
     * @type {boolean}
     * @memberof HostedPageActivateCardResponse
     */
    'skip_pin'?: boolean;
    /**
     * 
     * @type {HostedPageStatus}
     * @memberof HostedPageActivateCardResponse
     */
    'status'?: HostedPageStatus;
}


/**
 * 
 * @export
 * @interface HostedPageAdditionalResponse
 */
export interface HostedPageAdditionalResponse {
    /**
     * Details of an account funding transaction (AFT), which transfers funds from a card to a cardholder\'s wallet.
     * @type {object}
     * @memberof HostedPageAdditionalResponse
     */
    'account_funding_transaction'?: object;
    /**
     * The amount of the payment, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {number}
     * @memberof HostedPageAdditionalResponse
     */
    'amount'?: number;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'cancel_checkout_url'?: string;
    /**
     * 
     * @type {HostedPageAdditionalResponseCartItems}
     * @memberof HostedPageAdditionalResponse
     */
    'cart_items'?: HostedPageAdditionalResponseCartItems;
    /**
     * URL where the customer is redirected after pressing Finish to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'complete_checkout_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'country'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'currency'?: string;
    /**
     * Description of the payment transaction. To display the description, set display_description to true in custom_elements.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'customer'?: string;
    /**
     * Determines whether the payment is held in escrow for later release.
     * @type {boolean}
     * @memberof HostedPageAdditionalResponse
     */
    'escrow'?: boolean;
    /**
     * Determines the number of days after creation of the payment that funds are released from escrow. Funds are released at 5:00 pm GMT on the day indicated. Integer, range: 1-90.
     * @type {number}
     * @memberof HostedPageAdditionalResponse
     */
    'escrow_release_days'?: number;
    /**
     * ID of the Rapyd checkout page. String starting with **checkout_**.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'id'?: string;
    /**
     * A string that represents the text on the main Call to Action (CTA) button. One of the following:<BR>* place_your_order - Place Your Order.<BR>* pay - Pay.<BR>* pay_now - Pay Now.<BR>* make_payment - Make Payment.<BR>* purchase - Purchase.<BR>* buy - Buy.<BR>* donate - Donate.<BR>* To configure this button, use the Client Portal.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'merchant_main_button'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'merchant_privacy_policy'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Portal
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'merchant_terms'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when one or both of the following fields is unset: <BR>* `cancel_url` <BR>* `complete_url`.<BR> To configure this field, use the Client Portal
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'merchant_website'?: string;
    /**
     * 
     * @type {HostedPageAdditionalResponseCustomElements}
     * @memberof HostedPageAdditionalResponse
     */
    'custom_elements'?: HostedPageAdditionalResponseCustomElements;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof HostedPageAdditionalResponse
     */
    'page_expiration'?: number;
    /**
     * 
     * @type {Payment}
     * @memberof HostedPageAdditionalResponse
     */
    'payment'?: Payment;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof HostedPageAdditionalResponse
     */
    'payment_expiration'?: number;
    /**
     * The type of the payment method. For example, **it_visa_card**
     * @type {string}
     * @memberof HostedPageAdditionalResponse
     */
    'payment_method_type'?: string;
    /**
     * A list of the categories of payment method that are supported on the checkout page. The categories appear on the page in the order provided
     * @type {Array<string>}
     * @memberof HostedPageAdditionalResponse
     */
    'payment_method_type_categories'?: Array<string>;
    /**
     * List of payment methods that are excluded from display on the checkout page.
     * @type {Array<string>}
     * @memberof HostedPageAdditionalResponse
     */
    'payment_method_types_exclude'?: Array<string>;
    /**
     * List of payment methods that are displayed on the checkout page. The payment methods appear on the page in the order provided.
     * @type {Array<string>}
     * @memberof HostedPageAdditionalResponse
     */
    'payment_method_types_include'?: Array<string>;
    /**
     * Time of creation of the checkout page, in Unix time.
     * @type {number}
     * @memberof HostedPageAdditionalResponse
     */
    'timestamp'?: number;
}
/**
 * Describes the cart items that the customer is purchasing. These items are displayed at the checkout page.
 * @export
 * @interface HostedPageAdditionalResponseCartItems
 */
export interface HostedPageAdditionalResponseCartItems {
    /**
     * The price of the item in the currency defined in currency.
     * @type {number}
     * @memberof HostedPageAdditionalResponseCartItems
     */
    'amount'?: number;
    /**
     * The name of the item.
     * @type {string}
     * @memberof HostedPageAdditionalResponseCartItems
     */
    'name'?: string;
    /**
     * The quantity of the item.
     * @type {number}
     * @memberof HostedPageAdditionalResponseCartItems
     */
    'quantity'?: number;
    /**
     * The image that appears in the checkout page for this item.
     * @type {string}
     * @memberof HostedPageAdditionalResponseCartItems
     */
    'image'?: string;
}
/**
 * Description of the payment transaction.
 * @export
 * @interface HostedPageAdditionalResponseCustomElements
 */
export interface HostedPageAdditionalResponseCustomElements {
    /**
     * 
     * @type {boolean}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'save_card_default': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'payment_fees_display': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'billing_address_collect': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'display_description': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'merchant_currency_only': boolean;
    /**
     * 
     * @type {string}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'cardholder_name': string;
    /**
     * 
     * @type {string}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'cardholder_preferred_currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HostedPageAdditionalResponseCustomElements
     */
    'dynamic_currency_conversion'?: boolean;
}
/**
 * 
 * @export
 * @interface HostedPageCardPINResponse
 */
export interface HostedPageCardPINResponse {
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'cancel_url'?: string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'card_issuing'?: string;
    /**
     * ID of the Issued Card object, a string starting with **ci_**.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'card_token'?: string;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'complete_url'?: string;
    /**
     * ID of the wallet contact that the card is assigned to. Must have a valid phone number. String starting with **cont_**.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'ewallet_contact'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'geo_country'?: string;
    /**
     * ID of the hosted page for activating a card, a string starting with **hp_issuing_act_**.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page.<BR>* When this parameter is null, the language of the user\'s browser is used.<BR>* If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'language'?: string;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_logo'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers.<BR>To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_privacy_policy'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Porta
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_terms'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when `cancel_url`, `complete_url` or both fields are not set. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'merchant_website'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation.<BR>**Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof HostedPageCardPINResponse
     */
    'page_expiration'?: number;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'redirect_url'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof HostedPageCardPINResponse
     */
    'region'?: string;
    /**
     * When **true**, the customer cannot reset the PIN via a hosted page.
     * @type {boolean}
     * @memberof HostedPageCardPINResponse
     */
    'skip_view_pin'?: boolean;
    /**
     * 
     * @type {HostedPageStatus}
     * @memberof HostedPageCardPINResponse
     */
    'status'?: HostedPageStatus;
}


/**
 * Status of the hosted page. One of the following: NEW - The hosted page was created. DON - Done. The card was added to the customer profile. EXP - The hosted page expired. 
 * @export
 * @enum {string}
 */

export const HostedPageStatus = {
    New: 'NEW',
    Don: 'DON',
    Exp: 'EXP'
} as const;

export type HostedPageStatus = typeof HostedPageStatus[keyof typeof HostedPageStatus];


/**
 * 
 * @export
 * @interface HostedPageStatusBaseResponse
 */
export interface HostedPageStatusBaseResponse {
    /**
     * Determines the default language of the hosted page. When this parameter is null, the language of the user\'s browser is used. If the language of the user\'s browser cannot be determined, the default language is English
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'language'?: string;
    /**
     * Reserved, the default name is Rapyd
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_logo'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when cancel_url or complete_url or both fields is unset. To configure this field, use the Client Portal
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_website'?: string;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'redirect_url'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Portal
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_terms'?: string;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing Close to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'complete_url'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof HostedPageStatusBaseResponse
     */
    'merchant_privacy_policy'?: string;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof HostedPageStatusBaseResponse
     */
    'page_expiration'?: number;
    /**
     * 
     * @type {HostedPageStatus}
     * @memberof HostedPageStatusBaseResponse
     */
    'status'?: HostedPageStatus;
}


/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<PaymentMethodType>}
     * @memberof InlineResponse200
     */
    'data'?: Array<PaymentMethodType>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2001
     */
    'status'?: Status1;
    /**
     * 
     * @type {PaymentMethodTypeRequiredFields}
     * @memberof InlineResponse2001
     */
    'data'?: PaymentMethodTypeRequiredFields;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20010
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Plan>}
     * @memberof InlineResponse20010
     */
    'data'?: Array<Plan>;
}
/**
 * 
 * @export
 * @interface InlineResponse200100
 */
export interface InlineResponse200100 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200100
     */
    'status'?: Status;
    /**
     * 
     * @type {Account}
     * @memberof InlineResponse200100
     */
    'data'?: Account;
}
/**
 * 
 * @export
 * @interface InlineResponse200101
 */
export interface InlineResponse200101 {
    /**
     * 
     * @type {Array<EwalletTransaction>}
     * @memberof InlineResponse200101
     */
    'data'?: Array<EwalletTransaction>;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200101
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse200102
 */
export interface InlineResponse200102 {
    /**
     * 
     * @type {EwalletTransactionDetails}
     * @memberof InlineResponse200102
     */
    'data'?: EwalletTransactionDetails;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200102
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse200103
 */
export interface InlineResponse200103 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200103
     */
    'status'?: Status;
    /**
     * 
     * @type {InlineResponse200103Data}
     * @memberof InlineResponse200103
     */
    'data'?: InlineResponse200103Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200103Data
 */
export interface InlineResponse200103Data {
    /**
     * 
     * @type {InlineResponse200103DataBankAccounts}
     * @memberof InlineResponse200103Data
     */
    'bank_accounts'?: InlineResponse200103DataBankAccounts;
}
/**
 * Array of objects with details of the virtual accounts. Each object contains the following fields
 * @export
 * @interface InlineResponse200103DataBankAccounts
 */
export interface InlineResponse200103DataBankAccounts {
    /**
     * The actual account number that was assigned to the virtual account when it was created.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'account_id'?: string;
    /**
     * Type of the virtual account number, such as IBAN or CLABE.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'account_id_type'?: string;
    /**
     * Two-letter ISO 3166-1 ALPHA-2 code of the country of the virtual account.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'country_iso'?: string;
    /**
     * Currency of the virtual account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'currency'?: string;
    /**
     * ID of the Rapyd Wallet that the virtual accounts were issued to. String starting with **ewallet_**.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'ewallet'?: string;
    /**
     * ID of the virtual account number object. String starting with **issuing_**.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'issuing_id'?: string;
    /**
     * Currency received by the virtual account after conversion.<BR>When not specified, the funds appear in the wallet’s currency account for the currency of the transaction.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'requested_currency'?: InlineResponse200103DataBankAccountsRequestedCurrencyEnum;
    /**
     * Indicates the status of the virtual account.
     * @type {string}
     * @memberof InlineResponse200103DataBankAccounts
     */
    'status'?: InlineResponse200103DataBankAccountsStatusEnum;
}

export const InlineResponse200103DataBankAccountsRequestedCurrencyEnum = {
    Aud: 'AUD',
    Eur: 'EUR',
    Gbp: 'GBP',
    Hkd: 'HKD',
    Sgd: 'SGD',
    Usd: 'USD'
} as const;

export type InlineResponse200103DataBankAccountsRequestedCurrencyEnum = typeof InlineResponse200103DataBankAccountsRequestedCurrencyEnum[keyof typeof InlineResponse200103DataBankAccountsRequestedCurrencyEnum];
export const InlineResponse200103DataBankAccountsStatusEnum = {
    Act: 'ACT',
    Clo: 'CLO',
    Err: 'ERR',
    Rej: 'REJ'
} as const;

export type InlineResponse200103DataBankAccountsStatusEnum = typeof InlineResponse200103DataBankAccountsStatusEnum[keyof typeof InlineResponse200103DataBankAccountsStatusEnum];

/**
 * 
 * @export
 * @interface InlineResponse200104
 */
export interface InlineResponse200104 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200104
     */
    'status'?: Status;
    /**
     * 
     * @type {DailyRate}
     * @memberof InlineResponse200104
     */
    'data'?: DailyRate;
}
/**
 * 
 * @export
 * @interface InlineResponse200105
 */
export interface InlineResponse200105 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200105
     */
    'status'?: Status;
    /**
     * 
     * @type {ResendWebhookResponse}
     * @memberof InlineResponse200105
     */
    'data'?: ResendWebhookResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse200106
 */
export interface InlineResponse200106 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200106
     */
    'status'?: Status;
    /**
     * 
     * @type {ListWebhooksResponse}
     * @memberof InlineResponse200106
     */
    'data'?: ListWebhooksResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse200107
 */
export interface InlineResponse200107 {
    /**
     * 
     * @type {InlineResponse200107Data}
     * @memberof InlineResponse200107
     */
    'data'?: InlineResponse200107Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200107
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse200107Data
 */
export interface InlineResponse200107Data {
    /**
     * Issued virtual account.
     * @type {object}
     * @memberof InlineResponse200107Data
     */
    'bank_account'?: object;
    /**
     * The country that the account number will be associated with. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'country'?: string;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'currency'?: string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'description'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with **ewallet_**.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'ewallet'?: string;
    /**
     * Issued virtual account funding instructions.
     * @type {object}
     * @memberof InlineResponse200107Data
     */
    'funding_instructions'?: object;
    /**
     * The country that the account number will be associated with. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'id'?: string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InlineResponse200107Data
     */
    'metadata'?: object;
    /**
     * Issued virtual account statuts.
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'status'?: string;
    /**
     * Issued virtual account transactions.
     * @type {Array<CardTransaction>}
     * @memberof InlineResponse200107Data
     */
    'transactions'?: Array<CardTransaction>;
    /**
     * *Currency received by the virtual account after conversion. Uppercase. One of the following: AUD - Australian Dollar EUR - Euro GBP - Pound Sterling HKD - Hong Kong Dollar SGD - Singapore Dollar USD - US Dollar When not specified, the funds appear in the wallet’s currency account for the currency of the transaction.*
     * @type {string}
     * @memberof InlineResponse200107Data
     */
    'requested_currency'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200108
 */
export interface InlineResponse200108 {
    /**
     * 
     * @type {InlineResponse200108Data}
     * @memberof InlineResponse200108
     */
    'data'?: InlineResponse200108Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200108
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse200108Data
 */
export interface InlineResponse200108Data {
    /**
     * ID of the issued card transaction object. String starting with **cit_**.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'id'?: string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'merchant_reference_id'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with **ewallet_**.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'ewallet'?: string;
    /**
     * Issued virtual account.
     * @type {object}
     * @memberof InlineResponse200108Data
     */
    'bank_account'?: object | null;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InlineResponse200108Data
     */
    'metadata'?: object;
    /**
     * Issued virtual account statuts.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'status'?: string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'description'?: string;
    /**
     * Issued virtual account funding instructions.
     * @type {object}
     * @memberof InlineResponse200108Data
     */
    'funding_instructions'?: object;
    /**
     * Currency of the transaction. Three-letter ISO 4217.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'currency'?: string;
    /**
     * Issued virtual account transactions.
     * @type {Array<InlineResponse20093DataTransactions>}
     * @memberof InlineResponse200108Data
     */
    'transactions'?: Array<InlineResponse20093DataTransactions>;
    /**
     * *Currency received by the virtual account after conversion. Uppercase. One of the following: AUD - Australian Dollar EUR - Euro GBP - Pound Sterling HKD - Hong Kong Dollar SGD - Singapore Dollar USD - US Dollar When not specified, the funds appear in the wallet’s currency account for the currency of the transaction.*
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'requested_currency'?: string;
    /**
     * This field will display the currency in which the transaction was originally made.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'original_currency'?: string;
    /**
     * This field will show the initial transaction amount before conversion.
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'original_amount'?: string;
    /**
     * This field will indicate the exchange rate applied for the currency conversion
     * @type {string}
     * @memberof InlineResponse200108Data
     */
    'fx_rate'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200109
 */
export interface InlineResponse200109 {
    /**
     * 
     * @type {InlineResponse200109Data}
     * @memberof InlineResponse200109
     */
    'data'?: InlineResponse200109Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200109
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse200109Data
 */
export interface InlineResponse200109Data {
    /**
     * Name of the bank account holder.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'account_name'?: string;
    /**
     * Number of the bank account.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'account_number'?: string;
    /**
     * The amount of the transaction, in units of the currency defined in currency.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'amount'?: string;
    /**
     * Bank identifier code, such as SWIFT, BIC, ABA, or other local identifier.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'bank_code'?: string;
    /**
     * Name of the bank.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'bank_name'?: string;
    /**
     * The country that the account number will be associated with. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'country'?: string;
    /**
     * Time of creation of the transaction, in Unix time. Response only.
     * @type {number}
     * @memberof InlineResponse200109Data
     */
    'created_at'?: number;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'currency'?: string;
    /**
     * IBAN of the virtual bank account.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'iban'?: string;
    /**
     * ID that is assigned by the remitter
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'id'?: string;
    /**
     * ID that is assigned by the client to the transaction.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'partner_transaction_id'?: string;
    /**
     * IBAN that was assigned to the Rapyd Wallet.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'receiving_iban'?: string;
    /**
     * Optional information that the remitter adds to the transaction, intended for the beneficiary. Supported by some payment methods.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'remitter_reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'sort_code'?: string;
    /**
     * Indicates the status of the transfer.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'status'?: string;
    /**
     * Time of update of the virtual account, in Unix time. Response only.
     * @type {number}
     * @memberof InlineResponse200109Data
     */
    'updated_at'?: number;
    /**
     * Time of creation of the transaction, in Unix time. Response only.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'created_at_gw'?: string;
    /**
     * This field will display the currency in which the transaction was originally made.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'original_currency'?: string;
    /**
     * This field will show the initial transaction amount before conversion.
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'original_amount'?: string;
    /**
     * This field will indicate the exchange rate applied for the currency conversion
     * @type {string}
     * @memberof InlineResponse200109Data
     */
    'fx_rate'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20011
     */
    'status'?: Status1;
    /**
     * 
     * @type {Plan}
     * @memberof InlineResponse20011
     */
    'data'?: Plan;
}
/**
 * 
 * @export
 * @interface InlineResponse200110
 */
export interface InlineResponse200110 {
    /**
     * 
     * @type {InlineResponse200110Data}
     * @memberof InlineResponse200110
     */
    'data'?: InlineResponse200110Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200110
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse200110Data
 */
export interface InlineResponse200110Data {
    /**
     * ID of the virtual bank account.
     * @type {string}
     * @memberof InlineResponse200110Data
     */
    'account_id'?: string;
    /**
     * Type of the virtual account number.
     * @type {string}
     * @memberof InlineResponse200110Data
     */
    'account_id_type'?: string;
    /**
     * Amount of the transaction, in units defined in currency.
     * @type {number}
     * @memberof InlineResponse200110Data
     */
    'amount'?: number;
    /**
     * Timestamp for the transaction, in Unix time
     * @type {number}
     * @memberof InlineResponse200110Data
     */
    'created_at'?: number;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse200110Data
     */
    'currency'?: string;
    /**
     * ID of the Rapyd Wallet that is attached to the virtual account. String starting with **ewallet_**.
     * @type {string}
     * @memberof InlineResponse200110Data
     */
    'ewallet'?: string;
    /**
     * ID of the transaction. String starting with **isutran_**.
     * @type {string}
     * @memberof InlineResponse200110Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200111
 */
export interface InlineResponse200111 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200111
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse200111Data}
     * @memberof InlineResponse200111
     */
    'data'?: InlineResponse200111Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200111Data
 */
export interface InlineResponse200111Data {
    /**
     * ID Verification.
     * @type {string}
     * @memberof InlineResponse200111Data
     */
    'id'?: string;
    /**
     * Organization Reference Token.
     * @type {string}
     * @memberof InlineResponse200111Data
     */
    'reference_id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200112
 */
export interface InlineResponse200112 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200112
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<InlineResponse200112Data>}
     * @memberof InlineResponse200112
     */
    'data'?: Array<InlineResponse200112Data>;
}
/**
 * 
 * @export
 * @interface InlineResponse200112Data
 */
export interface InlineResponse200112Data {
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country of the identification document.
     * @type {string}
     * @memberof InlineResponse200112Data
     */
    'country'?: string;
    /**
     * Type of the identification document. Two-letter code
     * @type {string}
     * @memberof InlineResponse200112Data
     */
    'type'?: string;
    /**
     * Name of the identification document. Two-letter code
     * @type {string}
     * @memberof InlineResponse200112Data
     */
    'name'?: string;
    /**
     * Boolean if back image required
     * @type {boolean}
     * @memberof InlineResponse200112Data
     */
    'is_back_required'?: boolean;
    /**
     * Boolean if address extractable
     * @type {boolean}
     * @memberof InlineResponse200112Data
     */
    'is_address_extractable'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200113
 */
export interface InlineResponse200113 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200113
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<InlineResponse200113Data>}
     * @memberof InlineResponse200113
     */
    'data'?: Array<InlineResponse200113Data>;
}
/**
 * 
 * @export
 * @interface InlineResponse200113Data
 */
export interface InlineResponse200113Data {
    /**
     * Code for the type of application. String starting with typ_.
     * @type {string}
     * @memberof InlineResponse200113Data
     */
    'application_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200113Data
     */
    'country'?: string;
    /**
     * 
     * @type {EntityTypeVerify}
     * @memberof InlineResponse200113Data
     */
    'entity_type'?: EntityTypeVerify;
}


/**
 * 
 * @export
 * @interface InlineResponse200114
 */
export interface InlineResponse200114 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200114
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse200114Data}
     * @memberof InlineResponse200114
     */
    'data'?: InlineResponse200114Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200114Data
 */
export interface InlineResponse200114Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200114Data
     */
    'status'?: InlineResponse200114DataStatusEnum;
}

export const InlineResponse200114DataStatusEnum = {
    New: 'NEW',
    Don: 'DON',
    Exp: 'EXP'
} as const;

export type InlineResponse200114DataStatusEnum = typeof InlineResponse200114DataStatusEnum[keyof typeof InlineResponse200114DataStatusEnum];

/**
 * 
 * @export
 * @interface InlineResponse200115
 */
export interface InlineResponse200115 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200115
     */
    'status'?: Status1;
    /**
     * 
     * @type {VerifyHostedAppResponse}
     * @memberof InlineResponse200115
     */
    'data'?: VerifyHostedAppResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse200116
 */
export interface InlineResponse200116 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200116
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse200116Data}
     * @memberof InlineResponse200116
     */
    'data'?: InlineResponse200116Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200116Data
 */
export interface InlineResponse200116Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'application_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'rapyd_entity_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'client_reference_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'cancel_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'complete_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'phone_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200116Data
     */
    'application_level'?: InlineResponse200116DataApplicationLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'sell_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116Data
     */
    'business_industry'?: string;
    /**
     * 
     * @type {InlineResponse200116DataApplicationType}
     * @memberof InlineResponse200116Data
     */
    'application_type'?: InlineResponse200116DataApplicationType;
    /**
     * 
     * @type {InlineResponse200116DataOrganizationDetails}
     * @memberof InlineResponse200116Data
     */
    'organization_details'?: InlineResponse200116DataOrganizationDetails;
    /**
     * 
     * @type {InlineResponse200116DataRenewResult}
     * @memberof InlineResponse200116Data
     */
    'renew_result'?: InlineResponse200116DataRenewResult;
}

export const InlineResponse200116DataApplicationLevelEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type InlineResponse200116DataApplicationLevelEnum = typeof InlineResponse200116DataApplicationLevelEnum[keyof typeof InlineResponse200116DataApplicationLevelEnum];

/**
 * 
 * @export
 * @interface InlineResponse200116DataApplicationType
 */
export interface InlineResponse200116DataApplicationType {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataApplicationType
     */
    'application_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataApplicationType
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataApplicationType
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200116DataOrganizationDetails
 */
export interface InlineResponse200116DataOrganizationDetails {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_website'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_design'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_language'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_alias'?: string;
    /**
     * 
     * @type {InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport}
     * @memberof InlineResponse200116DataOrganizationDetails
     */
    'merchant_customer_support'?: InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport;
}
/**
 * 
 * @export
 * @interface InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport
 */
export interface InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116DataOrganizationDetailsMerchantCustomerSupport
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200116DataRenewResult
 */
export interface InlineResponse200116DataRenewResult {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200116DataRenewResult
     */
    'redirect_to_app_type_page'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200116DataRenewResult
     */
    'need_to_renew'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200117
 */
export interface InlineResponse200117 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200117
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse200117Data}
     * @memberof InlineResponse200117
     */
    'data'?: InlineResponse200117Data;
}
/**
 * Retrieve the Rapyd ID and merchant reference ID.
 * @export
 * @interface InlineResponse200117Data
 */
export interface InlineResponse200117Data {
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'complete_url'?: string;
    /**
     * ID of the wallet contact. String starting with **cont_**.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'contact'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country of the identification document.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'country'?: string;
    /**
     * ID of the Hosted Page Identity Verification object, a string starting with **hp_idv_**.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see [List Supported Languages](https://docs.rapyd.net/en/list-supported-languages.html). <BR> * When this parameter is null, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'language'?: string;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page.<BR> To configure this field, use the Client Portal.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {InlineResponse200117DataMerchantCustomerSupport}
     * @memberof InlineResponse200117Data
     */
    'merchant_customer_support'?: InlineResponse200117DataMerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo.<BR> To configure this field, use the Client Portal.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'merchant_logo'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers.<BR>To configure this field, use the Client Portal.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'merchant_privacy_policy'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Porta
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'merchant_terms'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when `cancel_url`, `complete_url` or both fields are not set. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'merchant_website'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation.<BR>**Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof InlineResponse200117Data
     */
    'page_expiration'?: number;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'redirect_url'?: string;
    /**
     * ID of the identity verification request. Must be unique for each request. Defined by the client.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'reference_id'?: string;
    /**
     * Determines the action that is taken on the request. One of the following:<BR>* **store** - Store the images on the Rapyd platform.<BR>* **verify** - Verify the identity of the person in the images.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'request_type'?: InlineResponse200117DataRequestTypeEnum;
    /**
     * Status of the hosted page. One of the following:<BR>* **NEW** - The hosted page was created.<BR>* **DON** - Done. The identity verification request was submitted.<BR>* **EXP** - Expired. The hosted page expired.
     * @type {string}
     * @memberof InlineResponse200117Data
     */
    'status'?: InlineResponse200117DataStatusEnum;
}

export const InlineResponse200117DataRequestTypeEnum = {
    Store: 'store',
    Verify: 'verify'
} as const;

export type InlineResponse200117DataRequestTypeEnum = typeof InlineResponse200117DataRequestTypeEnum[keyof typeof InlineResponse200117DataRequestTypeEnum];
export const InlineResponse200117DataStatusEnum = {
    New: 'NEW',
    Don: 'DON',
    Exp: 'EXP'
} as const;

export type InlineResponse200117DataStatusEnum = typeof InlineResponse200117DataStatusEnum[keyof typeof InlineResponse200117DataStatusEnum];

/**
 * Contains details of the client’s customer support. To configure these fields, use the Client Portal.
 * @export
 * @interface InlineResponse200117DataMerchantCustomerSupport
 */
export interface InlineResponse200117DataMerchantCustomerSupport {
    /**
     * Email address.
     * @type {string}
     * @memberof InlineResponse200117DataMerchantCustomerSupport
     */
    'email'?: string;
    /**
     * URL for the client\'s customer support service.
     * @type {string}
     * @memberof InlineResponse200117DataMerchantCustomerSupport
     */
    'url'?: string;
    /**
     * Phone number for contacting the client\'s customer support service.
     * @type {string}
     * @memberof InlineResponse200117DataMerchantCustomerSupport
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200118
 */
export interface InlineResponse200118 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200118
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse200118Data}
     * @memberof InlineResponse200118
     */
    'data'?: InlineResponse200118Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200118Data
 */
export interface InlineResponse200118Data {
    /**
     * ID of the query request operation. UUID.
     * @type {string}
     * @memberof InlineResponse200118Data
     */
    'operation_id'?: string;
    /**
     * ID of the merchant, defined by the partner..
     * @type {string}
     * @memberof InlineResponse200118Data
     */
    'partner_merchant_reference'?: string;
    /**
     * Unique ID of the query request, defined by the partner.
     * @type {string}
     * @memberof InlineResponse200118Data
     */
    'partner_query_reference'?: string;
    /**
     * Status of the Card Network Lookup Service query. One of the following:<BR>* **ERROR** - The query failed.<BR>* **IN_PROGRESS** - The query is being processed. Results are not available.<BR>* **PARTIAL** - The query process is partially complete. Some results are available.<BR>* **PROCESSED** - The query process is complete. All results are available.The two-letter ISO 3166-1 ALPHA-2 code for the country of the identification document.
     * @type {string}
     * @memberof InlineResponse200118Data
     */
    'status'?: InlineResponse200118DataStatusEnum;
}

export const InlineResponse200118DataStatusEnum = {
    InProgress: 'IN_PROGRESS',
    Error: 'ERROR',
    InProgress2: 'IN_PROGRESS',
    Partial: 'PARTIAL',
    Processed: 'PROCESSED'
} as const;

export type InlineResponse200118DataStatusEnum = typeof InlineResponse200118DataStatusEnum[keyof typeof InlineResponse200118DataStatusEnum];

/**
 * 
 * @export
 * @interface InlineResponse200119
 */
export interface InlineResponse200119 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse200119
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse200119Data}
     * @memberof InlineResponse200119
     */
    'data'?: InlineResponse200119Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200119Data
 */
export interface InlineResponse200119Data {
    /**
     * 
     * @type {InlineResponse200119DataMatchStats}
     * @memberof InlineResponse200119Data
     */
    'match_stats'?: InlineResponse200119DataMatchStats;
    /**
     * 
     * @type {InlineResponse200119DataMatches}
     * @memberof InlineResponse200119Data
     */
    'matches'?: InlineResponse200119DataMatches;
    /**
     * 
     * @type {InlineResponse200119DataQueryInfo}
     * @memberof InlineResponse200119Data
     */
    'query_info'?: InlineResponse200119DataQueryInfo;
    /**
     * 
     * @type {V1cnlterminationQuerySearchCriteria}
     * @memberof InlineResponse200119Data
     */
    'search_criteria'?: V1cnlterminationQuerySearchCriteria;
    /**
     * 
     * @type {InlineResponse200119DataPrincipals}
     * @memberof InlineResponse200119Data
     */
    'principals'?: InlineResponse200119DataPrincipals;
    /**
     * Status of the Card Network Lookup Service query. One of the following:<BR>* **ERROR** - The query failed.<BR>* **IN_PROGRESS** - The query is being processed. Results are not available.<BR>* **PARTIAL** - The query process is partially complete. Some results are available.<BR>* **PROCESSED** - The query process is complete. All results are available.The two-letter ISO 3166-1 ALPHA-2 code for the country of the identification document.
     * @type {string}
     * @memberof InlineResponse200119Data
     */
    'status'?: InlineResponse200119DataStatusEnum;
    /**
     * 
     * @type {InlineResponse200119DataMatchedMerchant}
     * @memberof InlineResponse200119Data
     */
    'matched_merchant'?: InlineResponse200119DataMatchedMerchant;
    /**
     * 
     * @type {InlineResponse200119DataRegistrationInfo}
     * @memberof InlineResponse200119Data
     */
    'registration_info'?: InlineResponse200119DataRegistrationInfo;
}

export const InlineResponse200119DataStatusEnum = {
    InProgress: 'IN_PROGRESS',
    Error: 'ERROR',
    InProgress2: 'IN_PROGRESS',
    Partial: 'PARTIAL',
    Processed: 'PROCESSED'
} as const;

export type InlineResponse200119DataStatusEnum = typeof InlineResponse200119DataStatusEnum[keyof typeof InlineResponse200119DataStatusEnum];

/**
 * Statistics about the query.
 * @export
 * @interface InlineResponse200119DataMatchStats
 */
export interface InlineResponse200119DataMatchStats {
    /**
     * Number of previous queries to the card network termination database that match elements of this merchant query. Does not indicate a registered match. Mastercard only.
     * @type {number}
     * @memberof InlineResponse200119DataMatchStats
     */
    'query_match_count'?: number;
    /**
     * Total number of registered matches in the card network termination databases with elements shared with this merchant query.
     * @type {number}
     * @memberof InlineResponse200119DataMatchStats
     */
    'registered_match_count'?: number;
}
/**
 * Data about the merchant on file in the database.
 * @export
 * @interface InlineResponse200119DataMatchedMerchant
 */
export interface InlineResponse200119DataMatchedMerchant {
    /**
     * The category of the merchant\'s business.
     * @type {string}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'business_category'?: InlineResponse200119DataMatchedMerchantBusinessCategoryEnum;
    /**
     * The \"doing business as\" name of the merchant.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 4-60
     * @type {string}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'dba_name'?: string;
    /**
     * The registered legal name of the merchant.
     * @type {string}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'legal_name'?: string;
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchantPrincipalsAddress}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'address'?: V1cnlterminationQueryQueriedMerchantPrincipalsAddress;
    /**
     * Business phone numbers of the merchant.<BR<Array of strings. Maximum - 2. Each string is a phone number in the format +[country code]/[phone number], where the forward slash (/) represents a separator between the country code and the telephone number.<BR>The plus sign before the country code is optional. The country code may only contain digits.<BR>The slash is required and must follow the country code.<BR>The telephone number may include blank spaces and hyphens (-).<BR>For example, in **+1/555 555-5555**, the country code is 1 and the telephone number is 5555555555.<BR>Length of each phone number: 8-15.
     * @type {object}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'phone_numbers'?: object;
    /**
     * Merchant category codes of the merchant\'s business.<BR>Array of strings. Numbers or US letters. Maximum - 5 items. <BR>Length of each string: 4.
     * @type {object}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'mcc'?: object;
    /**
     * Web addresses associated with the merchant.<BR>Array of strings. Numbers or US letters. Maximum - 3 items. For example: [\"https://fourstarmarket.com\", \"https://fourstarmarket.net\"]<BR>Length: Maximum - 40
     * @type {object}
     * @memberof InlineResponse200119DataMatchedMerchant
     */
    'url'?: object;
}

export const InlineResponse200119DataMatchedMerchantBusinessCategoryEnum = {
    Merchant: 'Merchant',
    PaymentFacilitator: 'Payment Facilitator',
    IndependentSalesOrganization: 'Independent Sales Organization',
    Marketplace: 'Marketplace',
    StagedDigitalWalletOperator: 'Staged Digital Wallet Operator',
    SponsoredMerchant: 'Sponsored Merchant'
} as const;

export type InlineResponse200119DataMatchedMerchantBusinessCategoryEnum = typeof InlineResponse200119DataMatchedMerchantBusinessCategoryEnum[keyof typeof InlineResponse200119DataMatchedMerchantBusinessCategoryEnum];

/**
 * Describes the results of the query.
 * @export
 * @interface InlineResponse200119DataMatches
 */
export interface InlineResponse200119DataMatches {
    /**
     * Name of the card network termination database with a match.
     * @type {string}
     * @memberof InlineResponse200119DataMatches
     */
    'card_network'?: InlineResponse200119DataMatchesCardNetworkEnum;
    /**
     * List of the data points that match this query exactly. Array of strings.
     * @type {object}
     * @memberof InlineResponse200119DataMatches
     */
    'exact_match'?: object;
    /**
     * Type of match. One of the following:<BR>* **query match** - This merchant query matches elements of a previous merchant query in the card network termination database.<BR>This means that the queried merchant shares data with a merchant that was previously searched for.<BR>* **registered match** - This merchant query matches elements of a merchant termination registration in the card network termination database. This means that an acquirer terminated the contract of a merchant that shares data with the queried merchant.
     * @type {string}
     * @memberof InlineResponse200119DataMatches
     */
    'match_type'?: string;
    /**
     * List of the data points that partly match the query. Array of strings.
     * @type {object}
     * @memberof InlineResponse200119DataMatches
     */
    'partial_match'?: object;
}

export const InlineResponse200119DataMatchesCardNetworkEnum = {
    Mastercard: 'MASTERCARD',
    Visa: 'VISA'
} as const;

export type InlineResponse200119DataMatchesCardNetworkEnum = typeof InlineResponse200119DataMatchesCardNetworkEnum[keyof typeof InlineResponse200119DataMatchesCardNetworkEnum];

/**
 * Details of the registered principal owners of the merchant.<BR> Maximum - 3.
 * @export
 * @interface InlineResponse200119DataPrincipals
 */
export interface InlineResponse200119DataPrincipals {
    /**
     * The first name of the owner.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 1-35
     * @type {string}
     * @memberof InlineResponse200119DataPrincipals
     */
    'first_name'?: string;
    /**
     * The initial letter of the owner\'s middle name.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: Maximum - 1
     * @type {string}
     * @memberof InlineResponse200119DataPrincipals
     */
    'middle_initial'?: string;
    /**
     * The family name of the owner.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 1-40
     * @type {string}
     * @memberof InlineResponse200119DataPrincipals
     */
    'last_name'?: string;
    /**
     * The primary email address of the merchant.<BR>String that starts with a combination of letters, numbers, ., _, %, or - before an **@** sign. After the **@** sign, a domain name with letters, numbers, ., or -, ending with a dot and a 2 to 4 letter domain type, such as **.com**. For example: **billsmith@snapphoto.com**<BR>Length: Maximum - 90
     * @type {string}
     * @memberof InlineResponse200119DataPrincipals
     */
    'email'?: string;
    /**
     * The phone number of the owner.<BR> Phone number in the format +[country code]/[phone number], where the forward slash (/) represents a separator between the country code and the telephone number.<BR>The plus sign before the country code is optional. The country code may only contain digits.<BR>The slash is required and must follow the country code.<BR>The telephone number may include blank spaces and hyphens (-).<BR>For example, in **+1/555 555-5555**, the country code is 1 and the telephone number is 5555555555.<BR>Length: 8-15
     * @type {string}
     * @memberof InlineResponse200119DataPrincipals
     */
    'phone_number'?: string;
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchantPrincipalsAddress}
     * @memberof InlineResponse200119DataPrincipals
     */
    'address'?: V1cnlterminationQueryQueriedMerchantPrincipalsAddress;
}
/**
 * asd
 * @export
 * @interface InlineResponse200119DataQueryInfo
 */
export interface InlineResponse200119DataQueryInfo {
    /**
     * ID of the merchant, defined by the partner.
     * @type {string}
     * @memberof InlineResponse200119DataQueryInfo
     */
    'partner_merchant_reference'?: string;
    /**
     * Unique ID of the query request, defined by the partner.
     * @type {string}
     * @memberof InlineResponse200119DataQueryInfo
     */
    'partner_query_reference'?: string;
    /**
     * 
     * @type {InlineResponse200119DataQueryInfoQueriedMerchant}
     * @memberof InlineResponse200119DataQueryInfo
     */
    'queried_merchant'?: InlineResponse200119DataQueryInfoQueriedMerchant;
}
/**
 * Details of the merchant who is the subject of the query.
 * @export
 * @interface InlineResponse200119DataQueryInfoQueriedMerchant
 */
export interface InlineResponse200119DataQueryInfoQueriedMerchant {
    /**
     * The category of the merchant\'s business.
     * @type {string}
     * @memberof InlineResponse200119DataQueryInfoQueriedMerchant
     */
    'business_category'?: InlineResponse200119DataQueryInfoQueriedMerchantBusinessCategoryEnum;
    /**
     * The \"doing business as\" name of the merchant.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 4-60
     * @type {string}
     * @memberof InlineResponse200119DataQueryInfoQueriedMerchant
     */
    'dba_name'?: string;
    /**
     * The registered legal name of the merchant.
     * @type {string}
     * @memberof InlineResponse200119DataQueryInfoQueriedMerchant
     */
    'legal_name'?: string;
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchantPrincipalsAddress}
     * @memberof InlineResponse200119DataQueryInfoQueriedMerchant
     */
    'address'?: V1cnlterminationQueryQueriedMerchantPrincipalsAddress;
    /**
     * Business phone numbers of the merchant.<BR<Array of strings. Maximum - 2. Each string is a phone number in the format +[country code]/[phone number], where the forward slash (/) represents a separator between the country code and the telephone number.<BR>The plus sign before the country code is optional. The country code may only contain digits.<BR>The slash is required and must follow the country code.<BR>The telephone number may include blank spaces and hyphens (-).<BR>For example, in **+1/555 555-5555**, the country code is 1 and the telephone number is 5555555555.<BR>Length of each phone number: 8-15.
     * @type {object}
     * @memberof InlineResponse200119DataQueryInfoQueriedMerchant
     */
    'phone_numbers'?: object;
    /**
     * Indicates whether the merchant trades through the internet.
     * @type {boolean}
     * @memberof InlineResponse200119DataQueryInfoQueriedMerchant
     */
    'is_ecommerce'?: boolean;
}

export const InlineResponse200119DataQueryInfoQueriedMerchantBusinessCategoryEnum = {
    Merchant: 'Merchant',
    PaymentFacilitator: 'Payment Facilitator',
    IndependentSalesOrganization: 'Independent Sales Organization',
    Marketplace: 'Marketplace',
    StagedDigitalWalletOperator: 'Staged Digital Wallet Operator',
    SponsoredMerchant: 'Sponsored Merchant'
} as const;

export type InlineResponse200119DataQueryInfoQueriedMerchantBusinessCategoryEnum = typeof InlineResponse200119DataQueryInfoQueriedMerchantBusinessCategoryEnum[keyof typeof InlineResponse200119DataQueryInfoQueriedMerchantBusinessCategoryEnum];

/**
 * Registration information in the card network\'s termination database about the merchant and the acquirer that listed the merchant.
 * @export
 * @interface InlineResponse200119DataRegistrationInfo
 */
export interface InlineResponse200119DataRegistrationInfo {
    /**
     * End date of the merchant\'s contract with the acquirer.
     * @type {number}
     * @memberof InlineResponse200119DataRegistrationInfo
     */
    'contract_end_date'?: number;
    /**
     * start date of the merchant\'s contract with the acquirer.
     * @type {number}
     * @memberof InlineResponse200119DataRegistrationInfo
     */
    'contract_start_date'?: number;
    /**
     * Reason that the merchant\'s contract with the acquirer was terminated.
     * @type {string}
     * @memberof InlineResponse200119DataRegistrationInfo
     */
    'primary_registration_reason'?: string;
    /**
     * ID of the acquirer that listed the merchant.
     * @type {string}
     * @memberof InlineResponse200119DataRegistrationInfo
     */
    'registered_by_acquirer_id'?: string;
    /**
     * Name of the acquirer that listed the merchant.
     * @type {string}
     * @memberof InlineResponse200119DataRegistrationInfo
     */
    'registered_by_acquirer_name'?: string;
    /**
     * Region of the acquirer that listed the merchant.
     * @type {string}
     * @memberof InlineResponse200119DataRegistrationInfo
     */
    'registered_by_acquirer_region'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20012
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20012Data}
     * @memberof InlineResponse20012
     */
    'data'?: InlineResponse20012Data;
}
/**
 * 
 * @export
 * @interface InlineResponse200120
 */
export interface InlineResponse200120 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200120
     */
    'status'?: Status;
    /**
     * 
     * @type {ListSupportedLanguagesResponse}
     * @memberof InlineResponse200120
     */
    'data'?: ListSupportedLanguagesResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse200121
 */
export interface InlineResponse200121 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200121
     */
    'status'?: Status;
    /**
     * 
     * @type {ListCountriesResponse}
     * @memberof InlineResponse200121
     */
    'data'?: ListCountriesResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse200122
 */
export interface InlineResponse200122 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse200122
     */
    'status'?: Status;
    /**
     * 
     * @type {ListCurrenciesResponse}
     * @memberof InlineResponse200122
     */
    'data'?: ListCurrenciesResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20012Data
 */
export interface InlineResponse20012Data {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20012Data
     */
    'deleted'?: boolean;
    /**
     * ID of the plan
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20013
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Product>}
     * @memberof InlineResponse20013
     */
    'data'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20014
     */
    'status'?: Status1;
    /**
     * 
     * @type {Product}
     * @memberof InlineResponse20014
     */
    'data'?: Product;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20015
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<SubscriptionItem>}
     * @memberof InlineResponse20015
     */
    'data'?: Array<SubscriptionItem>;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20016
     */
    'status'?: Status1;
    /**
     * 
     * @type {SubscriptionItem}
     * @memberof InlineResponse20016
     */
    'data'?: SubscriptionItem;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20017
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20017Data}
     * @memberof InlineResponse20017
     */
    'data'?: InlineResponse20017Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20017Data
 */
export interface InlineResponse20017Data {
    /**
     * true if the item deleted successfully, else false.
     * @type {boolean}
     * @memberof InlineResponse20017Data
     */
    'deleted'?: boolean;
    /**
     * ID of the subscription item.
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20018
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<InlineResponse20018Data>}
     * @memberof InlineResponse20018
     */
    'data'?: Array<InlineResponse20018Data>;
}
/**
 * 
 * @export
 * @interface InlineResponse20018Data
 */
export interface InlineResponse20018Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    'id'?: string;
    /**
     * The usage quantity for the specified date and time (timestamp).
     * @type {number}
     * @memberof InlineResponse20018Data
     */
    'quantity'?: number;
    /**
     * ID of the subscription item.
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    'subscription_item'?: string;
    /**
     * Timestamp for the usage record in Unix time.
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20019
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20018Data}
     * @memberof InlineResponse20019
     */
    'data'?: InlineResponse20018Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2002
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof InlineResponse2002
     */
    'data'?: Array<Payment>;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20020
     */
    'status'?: Status1;
    /**
     * 
     * @type {Discount}
     * @memberof InlineResponse20020
     */
    'data'?: Discount | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20021
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<InvoiceResponse>}
     * @memberof InlineResponse20021
     */
    'data'?: Array<InvoiceResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20022
     */
    'status'?: Status1;
    /**
     * 
     * @type {InvoiceResponse}
     * @memberof InlineResponse20022
     */
    'data'?: InvoiceResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20023
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20023Data}
     * @memberof InlineResponse20023
     */
    'data'?: InlineResponse20023Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20023Data
 */
export interface InlineResponse20023Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023Data
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20023Data
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20024
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<InvoiceItemResponse>}
     * @memberof InlineResponse20024
     */
    'data'?: Array<InvoiceItemResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20025
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20025Data}
     * @memberof InlineResponse20025
     */
    'data'?: InlineResponse20025Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20025Data
 */
export interface InlineResponse20025Data {
    /**
     * ID of the invoice item. String starting with **ii_**.
     * @type {string}
     * @memberof InlineResponse20025Data
     */
    'id'?: string;
    /**
     * Indicates whether this invoice item was deleted.
     * @type {boolean}
     * @memberof InlineResponse20025Data
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20026
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<PaymentLink>}
     * @memberof InlineResponse20026
     */
    'data'?: Array<PaymentLink>;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20027
     */
    'status'?: Status1;
    /**
     * 
     * @type {GroupPayment}
     * @memberof InlineResponse20027
     */
    'data'?: GroupPayment;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20028
     */
    'status'?: Status1;
    /**
     * 
     * @type {EscrowResponse}
     * @memberof InlineResponse20028
     */
    'data'?: EscrowResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {EscrowResponse}
     * @memberof InlineResponse20029
     */
    'data'?: EscrowResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2003
     */
    'status'?: Status1;
    /**
     * 
     * @type {Payment}
     * @memberof InlineResponse2003
     */
    'data'?: Payment;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20030
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Refund>}
     * @memberof InlineResponse20030
     */
    'data'?: Array<Refund>;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20031
     */
    'status'?: Status1;
    /**
     * 
     * @type {Refund}
     * @memberof InlineResponse20031
     */
    'data'?: Refund;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20032
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20032Data}
     * @memberof InlineResponse20032
     */
    'data'?: InlineResponse20032Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20032Data
 */
export interface InlineResponse20032Data {
    /**
     * Amount of the group payment, in units defined by currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {number}
     * @memberof InlineResponse20032Data
     */
    'amount'?: number;
    /**
     * Indicates the total amount of failed payments that have not been replaced. Response only.
     * @type {number}
     * @memberof InlineResponse20032Data
     */
    'amount_to_replace'?: number;
    /**
     * Reason for cancellation of the group payment. Response only.
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'cancel_reason'?: string;
    /**
     * Country where the payment methods are supported. Two-letter ISO 3166-1 ALPHA-2 code. Response only.
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'country'?: string;
    /**
     * Currency of the payments. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'currency'?: string;
    /**
     * Description of the group payment.
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'description'?: string;
    /**
     * End of the time allowed for customers to make this payment, in Unix time. Response only.
     * @type {number}
     * @memberof InlineResponse20032Data
     */
    'expiration'?: number;
    /**
     * ID of the Group Payment object. String starting with **gp_**.
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'id'?: string;
    /**
     * Merchant-defined ID. Limited to 255 characters.
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InlineResponse20032Data
     */
    'metadata'?: object;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof InlineResponse20032Data
     */
    'payments'?: Array<Payment>;
    /**
     * Indicates the status of the group payment operation
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20033
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<ApplePayObjectResponse>}
     * @memberof InlineResponse20033
     */
    'data'?: Array<ApplePayObjectResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20034
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Dispute>}
     * @memberof InlineResponse20034
     */
    'data'?: Array<Dispute>;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20035
     */
    'status'?: Status1;
    /**
     * 
     * @type {Dispute}
     * @memberof InlineResponse20035
     */
    'data'?: Dispute;
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20036
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Customer>}
     * @memberof InlineResponse20036
     */
    'data'?: Array<Customer>;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20037
     */
    'status'?: Status1;
    /**
     * 
     * @type {Customer}
     * @memberof InlineResponse20037
     */
    'data'?: Customer;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20038
     */
    'status'?: Status1;
    /**
     * 
     * @type {DiscountCustomerResponse}
     * @memberof InlineResponse20038
     */
    'data'?: DiscountCustomerResponse | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * 
     * @type {InlineResponse20023Data}
     * @memberof InlineResponse20039
     */
    'data'?: InlineResponse20023Data;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20039
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2004
     */
    'status'?: Status1;
    /**
     * 
     * @type {CheckoutPageResponse}
     * @memberof InlineResponse2004
     */
    'data'?: CheckoutPageResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20040
     */
    'status'?: Status1;
    /**
     * 
     * @type {AddressResponse}
     * @memberof InlineResponse20040
     */
    'data'?: AddressResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20041
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<CustomerPaymentMethod>}
     * @memberof InlineResponse20041
     */
    'data'?: Array<CustomerPaymentMethod>;
}
/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20042
     */
    'status'?: Status1;
    /**
     * 
     * @type {CustomerPaymentMethod}
     * @memberof InlineResponse20042
     */
    'data'?: CustomerPaymentMethod;
}
/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20043
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20043Data}
     * @memberof InlineResponse20043
     */
    'data'?: InlineResponse20043Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20043Data
 */
export interface InlineResponse20043Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20043Data
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20043Data
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20044
     */
    'status'?: Status1;
    /**
     * 
     * @type {Sku}
     * @memberof InlineResponse20044
     */
    'data'?: Sku;
}
/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20045
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Sku>}
     * @memberof InlineResponse20045
     */
    'data'?: Array<Sku>;
}
/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20046
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<OrderResponse>}
     * @memberof InlineResponse20046
     */
    'data'?: Array<OrderResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20047
     */
    'status'?: Status1;
    /**
     * 
     * @type {OrderResponse}
     * @memberof InlineResponse20047
     */
    'data'?: OrderResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20048
     */
    'status'?: Status1;
    /**
     * 
     * @type {OrderReturnedResponse}
     * @memberof InlineResponse20048
     */
    'data'?: OrderReturnedResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20049
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<OrderReturnedResponse>}
     * @memberof InlineResponse20049
     */
    'data'?: Array<OrderReturnedResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2005
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof InlineResponse2005
     */
    'data'?: Array<Subscription>;
}
/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20050
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<Coupon>}
     * @memberof InlineResponse20050
     */
    'data'?: Array<Coupon>;
}
/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20051
     */
    'status'?: Status1;
    /**
     * 
     * @type {Coupon}
     * @memberof InlineResponse20051
     */
    'data'?: Coupon | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20052
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20052Data}
     * @memberof InlineResponse20052
     */
    'data'?: InlineResponse20052Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20052Data
 */
export interface InlineResponse20052Data {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20052Data
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * 
     * @type {PayoutMethodTypeDetails}
     * @memberof InlineResponse20053
     */
    'data'?: PayoutMethodTypeDetails;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20053
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {Array<Payout>}
     * @memberof InlineResponse20054
     */
    'data'?: Array<Payout>;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20054
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * 
     * @type {Payout}
     * @memberof InlineResponse20055
     */
    'data'?: Payout;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20055
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20056
     */
    'status'?: Status;
    /**
     * 
     * @type {MassPayoutResponse}
     * @memberof InlineResponse20056
     */
    'data'?: MassPayoutResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {Beneficiary}
     * @memberof InlineResponse20057
     */
    'data'?: Beneficiary;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20057
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {InlineResponse20058Data}
     * @memberof InlineResponse20058
     */
    'data'?: InlineResponse20058Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20058
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20058Data
 */
export interface InlineResponse20058Data {
    /**
     * 
     * @type {Beneficiary}
     * @memberof InlineResponse20058Data
     */
    'beneficiary'?: Beneficiary;
    /**
     * validation status
     * @type {boolean}
     * @memberof InlineResponse20058Data
     */
    'validated'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * 
     * @type {InlineResponse20059Data}
     * @memberof InlineResponse20059
     */
    'data'?: InlineResponse20059Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20059
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20059Data
 */
export interface InlineResponse20059Data {
    /**
     * Flag to indicate whether beneficiary deleted or not
     * @type {boolean}
     * @memberof InlineResponse20059Data
     */
    'deleted'?: boolean;
    /**
     * Beneficiary token
     * @type {string}
     * @memberof InlineResponse20059Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2006
     */
    'status'?: Status1;
    /**
     * 
     * @type {Subscription}
     * @memberof InlineResponse2006
     */
    'data'?: Subscription;
}
/**
 * 
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {HostedBeneficiaryTokenResponse}
     * @memberof InlineResponse20060
     */
    'data'?: HostedBeneficiaryTokenResponse;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20060
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * 
     * @type {Sender}
     * @memberof InlineResponse20061
     */
    'data'?: Sender;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20061
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * 
     * @type {InlineResponse20062Data}
     * @memberof InlineResponse20062
     */
    'data'?: InlineResponse20062Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20062
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20062Data
 */
export interface InlineResponse20062Data {
    /**
     * Flag to indicate whether sender deleted or not
     * @type {boolean}
     * @memberof InlineResponse20062Data
     */
    'deleted'?: boolean;
    /**
     * Sender token
     * @type {string}
     * @memberof InlineResponse20062Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {Array<PayoutMethodType>}
     * @memberof InlineResponse20063
     */
    'data'?: Array<PayoutMethodType>;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20063
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20064
 */
export interface InlineResponse20064 {
    /**
     * 
     * @type {PayoutReturned}
     * @memberof InlineResponse20064
     */
    'data'?: PayoutReturned;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20064
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20065
 */
export interface InlineResponse20065 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20065
     */
    'status'?: Status;
    /**
     * 
     * @type {InlineResponse20065Data}
     * @memberof InlineResponse20065
     */
    'data'?: InlineResponse20065Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20065Data
 */
export interface InlineResponse20065Data {
    /**
     * ID of the payout. String starting with **payout_**.
     * @type {string}
     * @memberof InlineResponse20065Data
     */
    'payout_token'?: string;
    /**
     * ID of the uploaded file. UUID.
     * @type {string}
     * @memberof InlineResponse20065Data
     */
    'file_id'?: string;
    /**
     * The name of the document file.
     * @type {string}
     * @memberof InlineResponse20065Data
     */
    'file_name'?: string;
    /**
     * The uploaded file\'s extension.
     * @type {string}
     * @memberof InlineResponse20065Data
     */
    'file_extension'?: string;
    /**
     * The date and time when the file was successfully uploaded. Format is **YYYY-MM-DD HH:MM:SS**.
     * @type {string}
     * @memberof InlineResponse20065Data
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20066
 */
export interface InlineResponse20066 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20066
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20067
 */
export interface InlineResponse20067 {
    /**
     * 
     * @type {Transfer}
     * @memberof InlineResponse20067
     */
    'data'?: Transfer;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20067
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20068
 */
export interface InlineResponse20068 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20068
     */
    'status'?: Status;
    /**
     * 
     * @type {InlineResponse20068Data}
     * @memberof InlineResponse20068
     */
    'data'?: InlineResponse20068Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20068Data
 */
export interface InlineResponse20068Data {
    /**
     * ID of the Rapyd wallet account. UUID.
     * @type {string}
     * @memberof InlineResponse20068Data
     */
    'account_id'?: string;
    /**
     * Amount of the transfer, in units of the currency specified in `currency`.
     * @type {number}
     * @memberof InlineResponse20068Data
     */
    'amount'?: number;
    /**
     * Indicates the type of balance within the Rapyd wallet account.
     * @type {string}
     * @memberof InlineResponse20068Data
     */
    'balance_type'?: string;
    /**
     * The currency of the transfer. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse20068Data
     */
    'currency'?: string;
    /**
     * ID of the funds transfer transaction. UUID.
     * @type {string}
     * @memberof InlineResponse20068Data
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {string}
     * @memberof InlineResponse20068Data
     */
    'metadata'?: string;
    /**
     * Phone number of the Rapyd wallet.
     * @type {string}
     * @memberof InlineResponse20068Data
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20069
 */
export interface InlineResponse20069 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20069
     */
    'status'?: Status;
    /**
     * 
     * @type {PutFundsOnHoldResponse}
     * @memberof InlineResponse20069
     */
    'data'?: PutFundsOnHoldResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2007
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse2007Data}
     * @memberof InlineResponse2007
     */
    'data'?: InlineResponse2007Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20070
 */
export interface InlineResponse20070 {
    /**
     * 
     * @type {Array<Contact>}
     * @memberof InlineResponse20070
     */
    'data'?: Array<Contact>;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20070
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20071
 */
export interface InlineResponse20071 {
    /**
     * 
     * @type {Contact}
     * @memberof InlineResponse20071
     */
    'data'?: Contact;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20071
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20072
 */
export interface InlineResponse20072 {
    /**
     * 
     * @type {InlineResponse20072Data}
     * @memberof InlineResponse20072
     */
    'data'?: InlineResponse20072Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20072
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20072Data
 */
export interface InlineResponse20072Data {
    /**
     * Flag to indicate whether contact deleted or not
     * @type {boolean}
     * @memberof InlineResponse20072Data
     */
    'delete'?: boolean;
    /**
     * Contact id
     * @type {string}
     * @memberof InlineResponse20072Data
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20073
 */
export interface InlineResponse20073 {
    /**
     * 
     * @type {InlineResponse20073Data}
     * @memberof InlineResponse20073
     */
    'data'?: InlineResponse20073Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20073
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20073Data
 */
export interface InlineResponse20073Data {
    /**
     * 
     * @type {Array<InlineResponse20073DataComplianceLevels>}
     * @memberof InlineResponse20073Data
     */
    'compliance_levels'?: Array<InlineResponse20073DataComplianceLevels>;
}
/**
 * 
 * @export
 * @interface InlineResponse20073DataComplianceLevels
 */
export interface InlineResponse20073DataComplianceLevels {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20073DataComplianceLevels
     */
    'level'?: number;
    /**
     * 
     * @type {Array<InlineResponse20073DataElements>}
     * @memberof InlineResponse20073DataComplianceLevels
     */
    'elements'?: Array<InlineResponse20073DataElements>;
}
/**
 * 
 * @export
 * @interface InlineResponse20073DataElements
 */
export interface InlineResponse20073DataElements {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20073DataElements
     */
    'element_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20073DataElements
     */
    'verified'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20074
 */
export interface InlineResponse20074 {
    /**
     * 
     * @type {InlineResponse20074Data}
     * @memberof InlineResponse20074
     */
    'data'?: InlineResponse20074Data;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20074
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20074Data
 */
export interface InlineResponse20074Data {
    /**
     * Determines the default language of the hosted page. When this parameter is null, the language of the user\'s browser is used. If the language of the user\'s browser cannot be determined, the default language is English
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'language'?: string;
    /**
     * Reserved, the default name is Rapyd
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof InlineResponse20074Data
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'merchant_logo'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when cancel_url or complete_url or both fields is unset. To configure this field, use the Client Portal
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'merchant_website'?: string;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'redirect_url'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Portal
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'merchant_terms'?: string;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing Close to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'complete_url'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'merchant_privacy_policy'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If page_expiration is not set, the hosted page expires 14 days after creation. Range is 1 minute to 30 days.
     * @type {number}
     * @memberof InlineResponse20074Data
     */
    'page_expiration'?: number;
    /**
     * 
     * @type {HostedPageStatus}
     * @memberof InlineResponse20074Data
     */
    'status'?: HostedPageStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'card'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'country'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'currency'?: string;
    /**
     * ID of the customer, a string starting with **cus_**.
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'customer'?: string;
    /**
     * ID of the card token hosted page, a string starting with hp_card_
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'id'?: string;
    /**
     * Limits the page to a specific type of payment method. For example, dk_visa_card
     * @type {string}
     * @memberof InlineResponse20074Data
     */
    'payment_method_type'?: string;
    /**
     * 
     * @type {PaymentParams}
     * @memberof InlineResponse20074Data
     */
    'payment_params'?: PaymentParams;
    /**
     * 
     * @type {CustomerPaymentMethod}
     * @memberof InlineResponse20074Data
     */
    'customer_card_payment_methods'?: CustomerPaymentMethod;
}


/**
 * 
 * @export
 * @interface InlineResponse20075
 */
export interface InlineResponse20075 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20075
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<InlineResponse20075DataInner>}
     * @memberof InlineResponse20075
     */
    'data'?: Array<InlineResponse20075DataInner>;
}
/**
 * @type InlineResponse20075DataInner
 * @export
 */
export type InlineResponse20075DataInner = CardIssuing | CardIssuingMasked;

/**
 * 
 * @export
 * @interface InlineResponse20076
 */
export interface InlineResponse20076 {
    /**
     * 
     * @type {InlineResponse20075DataInner}
     * @memberof InlineResponse20076
     */
    'data'?: InlineResponse20075DataInner;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20076
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20077
 */
export interface InlineResponse20077 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20077
     */
    'status'?: Status1;
    /**
     * 
     * @type {InlineResponse20075DataInner}
     * @memberof InlineResponse20077
     */
    'data'?: InlineResponse20075DataInner;
}
/**
 * 
 * @export
 * @interface InlineResponse20078
 */
export interface InlineResponse20078 {
    /**
     * 
     * @type {CardIssuing}
     * @memberof InlineResponse20078
     */
    'data'?: CardIssuing;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20078
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20079
 */
export interface InlineResponse20079 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20079
     */
    'status'?: Status1;
    /**
     * 
     * @type {HostedPageActivateCardResponse}
     * @memberof InlineResponse20079
     */
    'data'?: HostedPageActivateCardResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse2007Data
 */
export interface InlineResponse2007Data {
    /**
     * discount id
     * @type {string}
     * @memberof InlineResponse2007Data
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2007Data
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2008
     */
    'status'?: Status1;
    /**
     * 
     * @type {SubscriptionHostedPageReponse}
     * @memberof InlineResponse2008
     */
    'data'?: SubscriptionHostedPageReponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20080
 */
export interface InlineResponse20080 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20080
     */
    'status'?: Status1;
    /**
     * 
     * @type {HostedPageCardPINResponse}
     * @memberof InlineResponse20080
     */
    'data'?: HostedPageCardPINResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20081
 */
export interface InlineResponse20081 {
    /**
     * 
     * @type {Array<CardTransaction>}
     * @memberof InlineResponse20081
     */
    'data'?: Array<CardTransaction>;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20081
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20082
 */
export interface InlineResponse20082 {
    /**
     * 
     * @type {CardTransaction}
     * @memberof InlineResponse20082
     */
    'data'?: CardTransaction;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20082
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20083
 */
export interface InlineResponse20083 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20083
     */
    'status'?: Status1;
    /**
     * 
     * @type {SetPINResponse}
     * @memberof InlineResponse20083
     */
    'data'?: SetPINResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20084
 */
export interface InlineResponse20084 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20084
     */
    'status'?: Status1;
    /**
     * 
     * @type {AddCardtoGooglePayResponse}
     * @memberof InlineResponse20084
     */
    'data'?: AddCardtoGooglePayResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20085
 */
export interface InlineResponse20085 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20085
     */
    'status'?: Status1;
    /**
     * 
     * @type {Array<CardTokenResponse>}
     * @memberof InlineResponse20085
     */
    'data'?: Array<CardTokenResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20086
 */
export interface InlineResponse20086 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20086
     */
    'status'?: Status1;
    /**
     * 
     * @type {SimulateBlockCardResponse}
     * @memberof InlineResponse20086
     */
    'data'?: SimulateBlockCardResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse20087
 */
export interface InlineResponse20087 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20087
     */
    'status'?: Status1;
    /**
     * 
     * @type {SimulateCardTransactionAuthorizationRequestEEA}
     * @memberof InlineResponse20087
     */
    'data'?: SimulateCardTransactionAuthorizationRequestEEA;
}
/**
 * 
 * @export
 * @interface InlineResponse20088
 */
export interface InlineResponse20088 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20088
     */
    'status'?: Status1;
    /**
     * 
     * @type {SimulateCardTransactionAuthorizationReversalEEA}
     * @memberof InlineResponse20088
     */
    'data'?: SimulateCardTransactionAuthorizationReversalEEA;
}
/**
 * 
 * @export
 * @interface InlineResponse20089
 */
export interface InlineResponse20089 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20089
     */
    'status'?: Status1;
    /**
     * 
     * @type {SimulateClearingCardTransactionEEA}
     * @memberof InlineResponse20089
     */
    'data'?: SimulateClearingCardTransactionEEA;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Subscription}
     * @memberof InlineResponse2009
     */
    'data'?: Subscription;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse2009
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20090
 */
export interface InlineResponse20090 {
    /**
     * 
     * @type {InlineResponse20090Data}
     * @memberof InlineResponse20090
     */
    'data'?: InlineResponse20090Data;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20090
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20090Data
 */
export interface InlineResponse20090Data {
    /**
     * Issuied virtual account.
     * @type {object}
     * @memberof InlineResponse20090Data
     */
    'bank_account'?: object;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'currency'?: string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'description'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with ewallet_.
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'ewallet'?: string;
    /**
     * Issuied virtual account funding instructions.
     * @type {object}
     * @memberof InlineResponse20090Data
     */
    'funding_instructions'?: object;
    /**
     * The country that the account number will be associated with. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'id'?: string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InlineResponse20090Data
     */
    'metadata'?: object;
    /**
     * Issuied virtual account statuts.
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'status'?: string;
    /**
     * Issuied virtual account transactions.
     * @type {Array<CardTransaction>}
     * @memberof InlineResponse20090Data
     */
    'transactions'?: Array<CardTransaction>;
    /**
     * *Currency received by the virtual account after conversion. Uppercase. One of the following: AUD - Australian Dollar EUR - Euro GBP - Pound Sterling HKD - Hong Kong Dollar SGD - Singapore Dollar USD - US Dollar When not specified, the funds appear in the walletâ€™s currency account for the currency of the transaction.*
     * @type {string}
     * @memberof InlineResponse20090Data
     */
    'requested_currency'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20091
 */
export interface InlineResponse20091 {
    /**
     * 
     * @type {InlineResponse20091Data}
     * @memberof InlineResponse20091
     */
    'data'?: InlineResponse20091Data;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20091
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20091Data
 */
export interface InlineResponse20091Data {
    /**
     * ID of the issued card transaction object. String starting with cit_.
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'id'?: string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'merchant_reference_id'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with ewallet_.
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'ewallet'?: string;
    /**
     * Issuied virtual account.
     * @type {object}
     * @memberof InlineResponse20091Data
     */
    'bank_account'?: object | null;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InlineResponse20091Data
     */
    'metadata'?: object;
    /**
     * Issuied virtual account statuts.
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'status'?: string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'description'?: string;
    /**
     * Issued virtual account funding instructions.
     * @type {object}
     * @memberof InlineResponse20091Data
     */
    'funding_instructions'?: object;
    /**
     * Currency of the transaction. Three-letter ISO 4217.
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'currency'?: string;
    /**
     * Issued virtual account transactions.
     * @type {Array<InlineResponse20091DataTransactions>}
     * @memberof InlineResponse20091Data
     */
    'transactions'?: Array<InlineResponse20091DataTransactions>;
    /**
     * *Currency received by the virtual account after conversion. Uppercase. One of the following: AUD - Australian Dollar EUR - Euro GBP - Pound Sterling HKD - Hong Kong Dollar SGD - Singapore Dollar USD - US Dollar When not specified, the funds appear in the walletâ€™s currency account for the currency of the transaction.*
     * @type {string}
     * @memberof InlineResponse20091Data
     */
    'requested_currency'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20091DataTransactions
 */
export interface InlineResponse20091DataTransactions {
    /**
     * ID of the issued card transaction object. String starting with cit_.
     * @type {string}
     * @memberof InlineResponse20091DataTransactions
     */
    'id'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with ewallet_.
     * @type {string}
     * @memberof InlineResponse20091DataTransactions
     */
    'ewallet'?: string;
    /**
     * ID of the virtual bank account.
     * @type {string}
     * @memberof InlineResponse20091DataTransactions
     */
    'account_id'?: string;
    /**
     * Type of the virtual account number.
     * @type {string}
     * @memberof InlineResponse20091DataTransactions
     */
    'account_id_type'?: string;
    /**
     * Amount of the transaction.
     * @type {number}
     * @memberof InlineResponse20091DataTransactions
     */
    'amount'?: number;
    /**
     * Currency of the transaction. Three-letter ISO 4217.
     * @type {string}
     * @memberof InlineResponse20091DataTransactions
     */
    'currency'?: string;
    /**
     * Time of creation of the transaction, in Unix time. Response only.
     * @type {number}
     * @memberof InlineResponse20091DataTransactions
     */
    'created_at'?: number;
    /**
     * This field will show the initial transaction amount before conversion.
     * @type {number}
     * @memberof InlineResponse20091DataTransactions
     */
    'original_amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof InlineResponse20091DataTransactions
     */
    'original_currency'?: string;
    /**
     * This field will indicate the exchange rate applied for the currency conversion
     * @type {number}
     * @memberof InlineResponse20091DataTransactions
     */
    'fx_rate'?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20092
 */
export interface InlineResponse20092 {
    /**
     * 
     * @type {VirtualAccountIssuing}
     * @memberof InlineResponse20092
     */
    'data'?: VirtualAccountIssuing;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20092
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20093
 */
export interface InlineResponse20093 {
    /**
     * 
     * @type {InlineResponse20093Data}
     * @memberof InlineResponse20093
     */
    'data'?: InlineResponse20093Data;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20093
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20093Data
 */
export interface InlineResponse20093Data {
    /**
     * ID of the issued card transaction object. String starting with **cit_**.
     * @type {string}
     * @memberof InlineResponse20093Data
     */
    'id'?: string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof InlineResponse20093Data
     */
    'merchant_reference_id'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with **ewallet_**.
     * @type {string}
     * @memberof InlineResponse20093Data
     */
    'ewallet'?: string;
    /**
     * Issued virtual account.
     * @type {object}
     * @memberof InlineResponse20093Data
     */
    'bank_account'?: object | null;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InlineResponse20093Data
     */
    'metadata'?: object;
    /**
     * Issued virtual account statuts.
     * @type {string}
     * @memberof InlineResponse20093Data
     */
    'status'?: string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof InlineResponse20093Data
     */
    'description'?: string;
    /**
     * Issued virtual account funding instructions.
     * @type {object}
     * @memberof InlineResponse20093Data
     */
    'funding_instructions'?: object;
    /**
     * Currency of the transaction. Three-letter ISO 4217.
     * @type {string}
     * @memberof InlineResponse20093Data
     */
    'currency'?: string;
    /**
     * Issued virtual account transactions.
     * @type {Array<InlineResponse20093DataTransactions>}
     * @memberof InlineResponse20093Data
     */
    'transactions'?: Array<InlineResponse20093DataTransactions>;
}
/**
 * 
 * @export
 * @interface InlineResponse20093DataTransactions
 */
export interface InlineResponse20093DataTransactions {
    /**
     * ID of the issued card transaction object. String starting with **cit_**.
     * @type {string}
     * @memberof InlineResponse20093DataTransactions
     */
    'id'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with **ewallet_**.
     * @type {string}
     * @memberof InlineResponse20093DataTransactions
     */
    'ewallet'?: string;
    /**
     * ID of the virtual bank account.
     * @type {string}
     * @memberof InlineResponse20093DataTransactions
     */
    'account_id'?: string;
    /**
     * Type of the virtual account number.
     * @type {string}
     * @memberof InlineResponse20093DataTransactions
     */
    'account_id_type'?: string;
    /**
     * Amount of the transaction.
     * @type {number}
     * @memberof InlineResponse20093DataTransactions
     */
    'amount'?: number;
    /**
     * Currency of the transaction. Three-letter ISO 4217.
     * @type {string}
     * @memberof InlineResponse20093DataTransactions
     */
    'currency'?: string;
    /**
     * Time of creation of the transaction, in Unix time. Response only.
     * @type {number}
     * @memberof InlineResponse20093DataTransactions
     */
    'created_at'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20093DataTransactions
     */
    'receiving_currency'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20094
 */
export interface InlineResponse20094 {
    /**
     * 
     * @type {InlineResponse20094Data}
     * @memberof InlineResponse20094
     */
    'data'?: InlineResponse20094Data;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20094
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20094Data
 */
export interface InlineResponse20094Data {
    /**
     * ID of the account. String starting with issuing_
     * @type {string}
     * @memberof InlineResponse20094Data
     */
    'id'?: string;
    /**
     * Indicates whether the account has been successfully deleted
     * @type {boolean}
     * @memberof InlineResponse20094Data
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20095
 */
export interface InlineResponse20095 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20095
     */
    'status'?: Status;
    /**
     * 
     * @type {InlineResponse20095Data}
     * @memberof InlineResponse20095
     */
    'data'?: InlineResponse20095Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20095Data
 */
export interface InlineResponse20095Data {
    /**
     * Indicates whether the virtual account has a SWIFT code.
     * @type {boolean}
     * @memberof InlineResponse20095Data
     */
    'accept_swift'?: boolean;
    /**
     * Type of the virtual account number.
     * @type {string}
     * @memberof InlineResponse20095Data
     */
    'account_id_type'?: InlineResponse20095DataAccountIdTypeEnum;
    /**
     * Two-letter ISO 3166-1 ALPHA-2 code for the country. code.
     * @type {string}
     * @memberof InlineResponse20095Data
     */
    'country'?: string;
    /**
     * Type of the local bank code.
     * @type {string}
     * @memberof InlineResponse20095Data
     */
    'local_bank_code_type'?: InlineResponse20095DataLocalBankCodeTypeEnum;
    /**
     * Indicates whether the virtual account has a SWIFT code.
     * @type {boolean}
     * @memberof InlineResponse20095Data
     */
    'refundable'?: boolean;
    /**
     * Indicates whether remitter details are available.
     * @type {boolean}
     * @memberof InlineResponse20095Data
     */
    'remitter_details'?: boolean;
    /**
     * Array of currencies supported for the virtual account. Array of strings.
     * @type {Array<string>}
     * @memberof InlineResponse20095Data
     */
    'supported_currencies'?: Array<string>;
}

export const InlineResponse20095DataAccountIdTypeEnum = {
    IbanInternationalBankAccountNumberIban: 'iban - International bank account number (IBAN).',
    ClabeClabeNumber: 'clabe - CLABE number.',
    NullRegularBankAccountNumber: 'null - Regular bank account number.'
} as const;

export type InlineResponse20095DataAccountIdTypeEnum = typeof InlineResponse20095DataAccountIdTypeEnum[keyof typeof InlineResponse20095DataAccountIdTypeEnum];
export const InlineResponse20095DataLocalBankCodeTypeEnum = {
    Bic: 'bic',
    Aba: 'aba',
    SortCode: 'sort_code',
    Bsb: 'bsb',
    Cnaps: 'cnaps',
    Ifsc: 'ifsc'
} as const;

export type InlineResponse20095DataLocalBankCodeTypeEnum = typeof InlineResponse20095DataLocalBankCodeTypeEnum[keyof typeof InlineResponse20095DataLocalBankCodeTypeEnum];

/**
 * 
 * @export
 * @interface InlineResponse20096
 */
export interface InlineResponse20096 {
    /**
     * 
     * @type {DailyRate}
     * @memberof InlineResponse20096
     */
    'data'?: DailyRate;
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse20096
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse20097
 */
export interface InlineResponse20097 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20097
     */
    'status'?: Status;
    /**
     * 
     * @type {Array<Ewallet>}
     * @memberof InlineResponse20097
     */
    'data'?: Array<Ewallet>;
}
/**
 * 
 * @export
 * @interface InlineResponse20098
 */
export interface InlineResponse20098 {
    /**
     * 
     * @type {Ewallet}
     * @memberof InlineResponse20098
     */
    'data'?: Ewallet;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20098
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse20099
 */
export interface InlineResponse20099 {
    /**
     * 
     * @type {Array<Account>}
     * @memberof InlineResponse20099
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse20099
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse400
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4001
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40010
 */
export interface InlineResponse40010 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40010
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40011
 */
export interface InlineResponse40011 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40011
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40012
 */
export interface InlineResponse40012 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40012
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40013
 */
export interface InlineResponse40013 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40013
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40014
 */
export interface InlineResponse40014 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40014
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40015
 */
export interface InlineResponse40015 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40015
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40016
 */
export interface InlineResponse40016 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40016
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40017
 */
export interface InlineResponse40017 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40017
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40018
 */
export interface InlineResponse40018 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40018
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40019
 */
export interface InlineResponse40019 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40019
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4002
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40020
 */
export interface InlineResponse40020 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40020
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40021
 */
export interface InlineResponse40021 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40021
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40022
 */
export interface InlineResponse40022 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40022
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40023
 */
export interface InlineResponse40023 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40023
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40024
 */
export interface InlineResponse40024 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40024
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40025
 */
export interface InlineResponse40025 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40025
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40026
 */
export interface InlineResponse40026 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40026
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40027
 */
export interface InlineResponse40027 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40027
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40028
 */
export interface InlineResponse40028 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40028
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40029
 */
export interface InlineResponse40029 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40029
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse4003
 */
export interface InlineResponse4003 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4003
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40030
 */
export interface InlineResponse40030 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40030
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40031
 */
export interface InlineResponse40031 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40031
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40032
 */
export interface InlineResponse40032 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40032
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40033
 */
export interface InlineResponse40033 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40033
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40034
 */
export interface InlineResponse40034 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40034
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40035
 */
export interface InlineResponse40035 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40035
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40036
 */
export interface InlineResponse40036 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40036
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40037
 */
export interface InlineResponse40037 {
    /**
     * 
     * @type {Status}
     * @memberof InlineResponse40037
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface InlineResponse40038
 */
export interface InlineResponse40038 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40038
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40039
 */
export interface InlineResponse40039 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40039
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4004
 */
export interface InlineResponse4004 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4004
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40040
 */
export interface InlineResponse40040 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40040
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40041
 */
export interface InlineResponse40041 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40041
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse40042
 */
export interface InlineResponse40042 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse40042
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4005
 */
export interface InlineResponse4005 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4005
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4006
 */
export interface InlineResponse4006 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4006
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4007
 */
export interface InlineResponse4007 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4007
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4008
 */
export interface InlineResponse4008 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4008
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InlineResponse4009
 */
export interface InlineResponse4009 {
    /**
     * 
     * @type {Status1}
     * @memberof InlineResponse4009
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface InvoiceIdPayBody
 */
export interface InvoiceIdPayBody {
    /**
     * ID of the payment method for paying the invoice. If not included in the body, then the customer\'s default_payment_method is used.
     * @type {string}
     * @memberof InvoiceIdPayBody
     */
    'payment_method'?: string;
}
/**
 * Invoice item
 * @export
 * @interface InvoiceItem
 */
export interface InvoiceItem {
    /**
     * line item id
     * @type {string}
     * @memberof InvoiceItem
     */
    'id'?: string;
    /**
     * amount
     * @type {number}
     * @memberof InvoiceItem
     */
    'amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof InvoiceItem
     */
    'currency'?: string;
    /**
     * item description
     * @type {string}
     * @memberof InvoiceItem
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceItem
     */
    'discountable'?: boolean;
    /**
     * invoice item id
     * @type {string}
     * @memberof InvoiceItem
     */
    'invoice_item'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InvoiceItem
     */
    'metadata'?: object;
    /**
     * 
     * @type {InvoiceItemPeriod}
     * @memberof InvoiceItem
     */
    'period'?: InvoiceItemPeriod;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceItem
     */
    'proration'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {Plan}
     * @memberof InvoiceItem
     */
    'plan'?: Plan;
    /**
     * ID of the subscription that generates charges to this customer. String starting with **sub_**.
     * @type {string}
     * @memberof InvoiceItem
     */
    'subscription'?: string;
    /**
     * ID of the subscription item that generates charges to this customer.
     * @type {string}
     * @memberof InvoiceItem
     */
    'subscription_item'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceItemPeriod
 */
export interface InvoiceItemPeriod {
    /**
     * First date in the period covered by the invoice, in Unix time. Response only.
     * @type {string}
     * @memberof InvoiceItemPeriod
     */
    'start'?: string;
    /**
     * Last date in the period covered by the invoice, in Unix time. Response only.
     * @type {string}
     * @memberof InvoiceItemPeriod
     */
    'end'?: string;
}
/**
 * Invoice item
 * @export
 * @interface InvoiceItemResponse
 */
export interface InvoiceItemResponse {
    /**
     * ID of the invoice item. String starting with **ii_**.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'id'?: string;
    /**
     * The amount of the total charge or credit for this item. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.<BR> This is `quantity` times `unit_amount`. A credit is indicated by a negative number.
     * @type {number}
     * @memberof InvoiceItemResponse
     */
    'amount'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the `amount` field.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'currency'?: string;
    /**
     * ID of the customer. String starting with **cus_**.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'customer'?: string;
    /**
     * The time of the charge or credit, in Unix time.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'date'?: string;
    /**
     * item description
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'description'?: string;
    /**
     * Determines whether this invoice item is subject to the discount defined in the coupon that is assigned to the customer or subscription.
     * @type {boolean}
     * @memberof InvoiceItemResponse
     */
    'discountable'?: boolean;
    /**
     * ID of the invoice item. String starting with **ii_**.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'invoice_item'?: string;
    /**
     * ID of the invoice that this invoice item is assigned to. Relevant when `subscription` is not set.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'invoice'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InvoiceItemResponse
     */
    'metadata'?: object;
    /**
     * 
     * @type {InvoiceItemResponsePeriod}
     * @memberof InvoiceItemResponse
     */
    'period'?: InvoiceItemResponsePeriod;
    /**
     * 
     * @type {Plan}
     * @memberof InvoiceItemResponse
     */
    'plan'?: Plan;
    /**
     * Indicates whether the invoice item is prorated.
     * @type {boolean}
     * @memberof InvoiceItemResponse
     */
    'proration'?: boolean;
    /**
     * Indicates the number of units charged as a single invoice item. Integer.
     * @type {number}
     * @memberof InvoiceItemResponse
     */
    'quantity'?: number;
    /**
     * ID of the subscription this invoice item is assigned to. By default, the invoice item is assigned to the customer\'s subscription whose current billing cycle ends first. Relevant when `invoice` is not set.
     * @type {string}
     * @memberof InvoiceItemResponse
     */
    'subscription'?: string;
    /**
     * Per-unit price of the product or service, adjusted as defined in the plan. Decimal.
     * @type {number}
     * @memberof InvoiceItemResponse
     */
    'unit_amount'?: number;
}
/**
 * Defines the start and end of the time period that this invoice item refers to. Relevant when the invoice item refers to more than one day. Contains the following fields:
 * @export
 * @interface InvoiceItemResponsePeriod
 */
export interface InvoiceItemResponsePeriod {
    /**
     * First date in the period covered by the invoice, in Unix time. Response only.
     * @type {string}
     * @memberof InvoiceItemResponsePeriod
     */
    'start'?: string;
    /**
     * Last date in the period covered by the invoice, in Unix time. Response only.
     * @type {string}
     * @memberof InvoiceItemResponsePeriod
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceItemsInvoiceItemBody
 */
export interface InvoiceItemsInvoiceItemBody {
    /**
     * Number of days the customer has for paying this invoice. Integer.
     * @type {number}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'days_until_due'?: number;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'description'?: string;
    /**
     * The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the `days_until_due` field. Relevant when `billing` is **send_invoice**. Format is in Unix time.
     * @type {number}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'due_date'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'metadata'?: object;
    /**
     * Additional `payment_options`.
     * @type {object}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'payment_fields'?: object;
    /**
     * Description of the invoice for the customer\'s credit card statement. Limited to 22 characters.
     * @type {string}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'statement_descriptor'?: string;
    /**
     * The percentage tax rate that is applied to the subtotal of the invoice, after subtracting all discounts. Decimal, up to four decimal places. Range: 0-100
     * @type {number}
     * @memberof InvoiceItemsInvoiceItemBody
     */
    'tax_percent'?: number;
}
/**
 * 
 * @export
 * @interface InvoiceLineResponse
 */
export interface InvoiceLineResponse {
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineResponse
     */
    'amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLineResponse
     */
    'discountable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'invoice_item'?: string;
    /**
     * 
     * @type {object}
     * @memberof InvoiceLineResponse
     */
    'metadata'?: object;
    /**
     * 
     * @type {InvoiceLineResponsePeriod}
     * @memberof InvoiceLineResponse
     */
    'period'?: InvoiceLineResponsePeriod;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLineResponse
     */
    'proration'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'subscription_item'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineResponse
     */
    'type'?: string;
    /**
     * 
     * @type {InvoiceLineResponsePlan}
     * @memberof InvoiceLineResponse
     */
    'plan'?: InvoiceLineResponsePlan;
}
/**
 * 
 * @export
 * @interface InvoiceLineResponsePeriod
 */
export interface InvoiceLineResponsePeriod {
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineResponsePeriod
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineResponsePeriod
     */
    'end'?: number;
}
/**
 * @type InvoiceLineResponsePlan
 * @export
 */
export type InvoiceLineResponsePlan = Plan | string;

/**
 * Invoice
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponse
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceResponse
     */
    'attempt_count'?: number;
    /**
     * Number of automatic attempts that Rapyd made to retry paying this invoice if it failed.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'attempted'?: number;
    /**
     * Number of automatic attempts that Rapyd made to retry paying this invoice if it failed.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'automatic_attempt_count'?: number;
    /**
     * Determines the method of collection, pay_automatically or send_invoice. Default is pay_automatically
     * @type {string}
     * @memberof InvoiceResponse
     */
    'billing'?: string;
    /**
     * The reason for billing
     * @type {string}
     * @memberof InvoiceResponse
     */
    'billing_reason'?: InvoiceResponseBillingReasonEnum;
    /**
     * The time the invoice was created, in Unix time. Response only.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'created_at'?: number;
    /**
     * 
     * @type {Discount}
     * @memberof InvoiceResponse
     */
    'discount'?: Discount | null;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'currency'?: string;
    /**
     * ID of the customer. String starting with cus_.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'customer'?: string;
    /**
     * The number of days until the due date.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'days_until_due'?: number;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'description'?: string;
    /**
     * The amount of the discount that was applied to this invoice.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'discount_amount'?: number;
    /**
     * The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the `days_until_due` field. Format is in Unix time.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'due_date'?: string;
    /**
     * 
     * @type {Array<InvoiceItemResponse>}
     * @memberof InvoiceResponse
     */
    'lines'?: Array<InvoiceItemResponse>;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InvoiceResponse
     */
    'metadata'?: object;
    /**
     * Object containing additional payment_options fields.
     * @type {object}
     * @memberof InvoiceResponse
     */
    'payment_fields'?: object;
    /**
     * Payment method for the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'payment_method'?: string | null;
    /**
     * Description of the invoice for the customer\'s credit card statement. Limited to 22 characters.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {Payment}
     * @memberof InvoiceResponse
     */
    'subscription'?: Payment;
    /**
     * The tax rate, defined as a percentage.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'tax_percent'?: number;
    /**
     * 
     * @type {Payment}
     * @memberof InvoiceResponse
     */
    'payment'?: Payment;
    /**
     * 
     * @type {Payout}
     * @memberof InvoiceResponse
     */
    'payout'?: Payout;
    /**
     * Reserved
     * @type {object}
     * @memberof InvoiceResponse
     */
    'payout_fields'?: object;
    /**
     * Last date in the period covered by the invoice, in Unix time. Response only.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'period_end'?: number;
    /**
     * First date in the period covered by the invoice, in Unix time. Response only.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'period_start'?: number;
    /**
     * The time when the next payment attempt will be made, in Unix time.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'next_payment_attempt'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponse
     */
    'number'?: string;
    /**
     * An invoice moves through a series of statuses. See status table below.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'status'?: InvoiceResponseStatusEnum;
    /**
     * Total of all line items before discount and before tax. Decimal. Response only.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'subtotal'?: number;
    /**
     * Total after discount and tax. Decimal.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponse
     */
    'type'?: InvoiceResponseTypeEnum;
}

export const InvoiceResponseBillingReasonEnum = {
    SubscriptionCycle: 'subscription_cycle',
    SubscriptionCreate: 'subscription_create',
    Manual: 'manual',
    Upcoming: 'upcoming'
} as const;

export type InvoiceResponseBillingReasonEnum = typeof InvoiceResponseBillingReasonEnum[keyof typeof InvoiceResponseBillingReasonEnum];
export const InvoiceResponseStatusEnum = {
    Draft: 'draft',
    Deleted: 'deleted',
    Open: 'open',
    Paid: 'paid',
    Void: 'void',
    Uncollectible: 'uncollectible'
} as const;

export type InvoiceResponseStatusEnum = typeof InvoiceResponseStatusEnum[keyof typeof InvoiceResponseStatusEnum];
export const InvoiceResponseTypeEnum = {
    Payment: 'payment',
    Payout: 'payout'
} as const;

export type InvoiceResponseTypeEnum = typeof InvoiceResponseTypeEnum[keyof typeof InvoiceResponseTypeEnum];

/**
 * 
 * @export
 * @interface InvoicesInvoiceIdBody
 */
export interface InvoicesInvoiceIdBody {
    /**
     * The number of days until the due date.
     * @type {number}
     * @memberof InvoicesInvoiceIdBody
     */
    'days_until_due'?: number;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoicesInvoiceIdBody
     */
    'description'?: string;
    /**
     * The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the days_until_due field. Format is in Unix time.
     * @type {string}
     * @memberof InvoicesInvoiceIdBody
     */
    'due_date'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof InvoicesInvoiceIdBody
     */
    'metadata'?: object;
    /**
     * Object containing additional payment_options fields.
     * @type {object}
     * @memberof InvoicesInvoiceIdBody
     */
    'payment_fields'?: object;
    /**
     * Description of the invoice for the customer\'s credit card statement. Limited to 22 characters.
     * @type {string}
     * @memberof InvoicesInvoiceIdBody
     */
    'statement_descriptor'?: string;
    /**
     * The tax rate, defined as a percentage.
     * @type {number}
     * @memberof InvoicesInvoiceIdBody
     */
    'tax_percent'?: number;
}
/**
 * 
 * @export
 * @interface IssuingActivateCardBody
 */
export interface IssuingActivateCardBody {
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof IssuingActivateCardBody
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing **Close** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof IssuingActivateCardBody
     */
    'complete_url'?: string;
    /**
     * ID of the wallet contact that the card is assigned to. Must have a valid phone number. String starting with **cont_**.
     * @type {string}
     * @memberof IssuingActivateCardBody
     */
    'ewallet_contact': string;
    /**
     * Determines the default language of the hosted page. For a list of values, see \'List Supported Languages\'.<BR>* When this parameter is null, the language of the user\'s browser is used.<BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof IssuingActivateCardBody
     */
    'language'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 14 days after creation.<BR>**Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof IssuingActivateCardBody
     */
    'page_expiration'?: number;
    /**
     * When **true**, connects an issued card to a wallet contact. Relevant to a card that was issued in bulk and is not assigned to a specific person.
     * @type {boolean}
     * @memberof IssuingActivateCardBody
     */
    'personalize'?: boolean;
    /**
     * When **true**, the customer cannot reset the PIN.
     * @type {boolean}
     * @memberof IssuingActivateCardBody
     */
    'skip_pin'?: boolean;
}
/**
 * 
 * @export
 * @interface IssuingBankaccountsBody
 */
export interface IssuingBankaccountsBody {
    /**
     * The country that the account number will be associated with. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof IssuingBankaccountsBody
     */
    'country': string;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof IssuingBankaccountsBody
     */
    'currency': string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof IssuingBankaccountsBody
     */
    'description'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with **ewallet_**.
     * @type {string}
     * @memberof IssuingBankaccountsBody
     */
    'ewallet': string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof IssuingBankaccountsBody
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof IssuingBankaccountsBody
     */
    'metadata'?: object;
    /**
     * Currency received by the virtual account after conversion. Uppercase. One of the following:<BR> * AUD - Australian Dollar<BR> * EUR - Euro<BR> * GBP - Pound Sterling<BR> * HKD - Hong Kong Dollar<BR> * SGD - Singapore Dollar<BR> * USD - US Dollar<BR> When not specified, the funds appear in the wallet’s currency account for the currency of the transaction.
     * @type {string}
     * @memberof IssuingBankaccountsBody
     */
    'requested_currency'?: string;
}
/**
 * 
 * @export
 * @interface IssuingCardsBody
 */
export interface IssuingCardsBody {
    /**
     * ID of the card program that the card is issued from. String starting with **cardprog_**.
     * @type {string}
     * @memberof IssuingCardsBody
     */
    'card_program': string;
    /**
     * Two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof IssuingCardsBody
     */
    'country'?: string;
    /**
     * ID of the wallet contact that the card is assigned to. String starting with **cont_**.
     * @type {string}
     * @memberof IssuingCardsBody
     */
    'ewallet_contact': string;
    /**
     * Expiration month of the card.
     * @type {string}
     * @memberof IssuingCardsBody
     */
    'expiration_month'?: string;
    /**
     * Expiration year of the card.
     * @type {string}
     * @memberof IssuingCardsBody
     */
    'expiration_year'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof IssuingCardsBody
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface IssuingPinBody
 */
export interface IssuingPinBody {
    /**
     * URL where the customer is redirected after pressing **Back to Website**.
     * @type {string}
     * @memberof IssuingPinBody
     */
    'cancel_url'?: string;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof IssuingPinBody
     */
    'card'?: string;
    /**
     * ID of the wallet contact that the card is assigned to. Must have a valid phone number. String starting with **cont_**.
     * @type {string}
     * @memberof IssuingPinBody
     */
    'ewallet_contact': string;
    /**
     * Determines the default language of the hosted page. For a list of values, see \'List Supported Languages\'.<BR>* When this parameter is null, the language of the user\'s browser is used.<BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof IssuingPinBody
     */
    'language'?: string;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If `page_expiration` is not set, the hosted page expires 7 days after creation.<BR>**Range**: 1 minute to 30 days.
     * @type {any}
     * @memberof IssuingPinBody
     */
    'page_expiration'?: any;
    /**
     * When **true**, the customer cannot reset the PIN.
     * @type {boolean}
     * @memberof IssuingPinBody
     */
    'skip_pin'?: boolean;
}
/**
 * Describes the fees for processing the currency exchange. Relevant to payouts with FX.
 * @export
 * @interface IssuingTransactionFxData
 */
export interface IssuingTransactionFxData {
    /**
     * The amount sent by the sender to the virtual account, in units of the currency defined in original_currency.
     * @type {number}
     * @memberof IssuingTransactionFxData
     */
    'original_amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof IssuingTransactionFxData
     */
    'original_currency'?: string;
    /**
     * Currency conversion rate for the transaction.
     * @type {number}
     * @memberof IssuingTransactionFxData
     */
    'fx_rate'?: number;
}
/**
 * 
 * @export
 * @interface Limit
 */
export interface Limit {
    /**
     * The amount of the limit.
     * @type {number}
     * @memberof Limit
     */
    'amount'?: number;
    /**
     * Three-letter ISO 4217 code for the currency of an existing account.
     * @type {string}
     * @memberof Limit
     */
    'currency'?: string;
    /**
     * The limit type.
     * @type {string}
     * @memberof Limit
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Limit
     */
    'updated_at'?: number;
}
/**
 * 
 * @export
 * @interface ListCountriesResponse
 */
export interface ListCountriesResponse {
    /**
     * 
     * @type {ListCountriesResponseLanguages}
     * @memberof ListCountriesResponse
     */
    'languages'?: ListCountriesResponseLanguages;
}
/**
 * List of the supported countries.
 * @export
 * @interface ListCountriesResponseLanguages
 */
export interface ListCountriesResponseLanguages {
    /**
     * Three-letter ISO 4217 code for the currency.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'currency_code'?: string;
    /**
     * Name of the currency in English.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'currency_name'?: string;
    /**
     * Unicode symbol for the currency.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'currency_sign'?: string;
    /**
     * ID of the country.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'id'?: string;
    /**
     * 2-letter ISO 3166-1 alpha-2 code for the country.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'iso_alpha2'?: string;
    /**
     * 3-letter ISO 3166-1 alpha-2 code for the country. Informational only - not relevant to Rapyd API.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'iso_alpha3'?: string;
    /**
     * Name of the country in English.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'name'?: string;
    /**
     * International telephone prefix for the country.
     * @type {string}
     * @memberof ListCountriesResponseLanguages
     */
    'phone_code'?: string;
}
/**
 * 
 * @export
 * @interface ListCurrenciesResponse
 */
export interface ListCurrenciesResponse {
    /**
     * Three-letter ISO 4217 alphabetic code for the currency.
     * @type {string}
     * @memberof ListCurrenciesResponse
     */
    'code'?: string;
    /**
     * Number of digits for the minor currency unit.
     * @type {string}
     * @memberof ListCurrenciesResponse
     */
    'digits_after_decimal_separator'?: string;
    /**
     * Name of the currency in English.
     * @type {string}
     * @memberof ListCurrenciesResponse
     */
    'name'?: string;
    /**
     * ISO 4217 numeric code for the currency.
     * @type {string}
     * @memberof ListCurrenciesResponse
     */
    'numeric_code'?: string;
    /**
     * Unicode symbol for the currency. If there is no official Unicode symbol, this field contains the string **undefined**.
     * @type {string}
     * @memberof ListCurrenciesResponse
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface ListSupportedLanguagesResponse
 */
export interface ListSupportedLanguagesResponse {
    /**
     * 
     * @type {ListSupportedLanguagesResponseLanguages}
     * @memberof ListSupportedLanguagesResponse
     */
    'languages'?: ListSupportedLanguagesResponseLanguages;
}
/**
 * List of the languages supported for hosted pages.
 * @export
 * @interface ListSupportedLanguagesResponseLanguages
 */
export interface ListSupportedLanguagesResponseLanguages {
    /**
     * Name of the language in English.
     * @type {string}
     * @memberof ListSupportedLanguagesResponseLanguages
     */
    'name'?: string;
    /**
     * ISO 639-1 code for the language. 2 letters, with suffix where relevant.
     * @type {string}
     * @memberof ListSupportedLanguagesResponseLanguages
     */
    'iso_alpha2'?: string;
}
/**
 * 
 * @export
 * @interface ListWebhooksResponse
 */
export interface ListWebhooksResponse {
    /**
     * 
     * @type {ListWebhooksResponseAttempts}
     * @memberof ListWebhooksResponse
     */
    'attempts'?: ListWebhooksResponseAttempts;
    /**
     * Timestamp for the creation of the webhook. Unix time.
     * @type {number}
     * @memberof ListWebhooksResponse
     */
    'created_at'?: number;
    /**
     * The data section of the webhook itself.
     * @type {object}
     * @memberof ListWebhooksResponse
     */
    'data'?: object;
    /**
     * Timestamp of the last attempt at sending the webhook. Unix time.
     * @type {number}
     * @memberof ListWebhooksResponse
     */
    'last_attempt_at'?: number;
    /**
     * Timestamp of the next attempt at sending the webhook. Unix time.
     * @type {number}
     * @memberof ListWebhooksResponse
     */
    'next_attempt_at'?: number;
    /**
     * Status of the webhook. One of the following: <BR> * **NEW** (new) - The webhook was created and has not yet been sent successfully. <BR> * **CLO** (closed) - The webhook was sent successfully.<BR> * **ERR** (error) - Attempts were made to send the webhook, but the maximum number of retries was reached. The automatic retry process failed. The webhook was not sent. <BR> * **RET** (retried) - The webhook was resent.
     * @type {string}
     * @memberof ListWebhooksResponse
     */
    'status'?: string;
    /**
     * ID of the webhook. String starting with **wh_**.
     * @type {string}
     * @memberof ListWebhooksResponse
     */
    'token'?: string;
    /**
     * Internal name of the webhook type.
     * @type {number}
     * @memberof ListWebhooksResponse
     */
    'type'?: number;
}
/**
 * List of attempts at sending the webhook. Array of objects that contain the following fields:
 * @export
 * @interface ListWebhooksResponseAttempts
 */
export interface ListWebhooksResponseAttempts {
    /**
     * Error message received from the configured webhook destination.
     * @type {string}
     * @memberof ListWebhooksResponseAttempts
     */
    'error'?: string;
    /**
     * HTTP status code returned by the configured webhook destination.
     * @type {string}
     * @memberof ListWebhooksResponseAttempts
     */
    'http_status_code'?: string;
    /**
     * Body of the HTTP response from the configured webhook destination.
     * @type {string}
     * @memberof ListWebhooksResponseAttempts
     */
    'http_response_body'?: string;
    /**
     * 
     * @type {ListWebhooksResponseAttemptsHttpResponseHeaders}
     * @memberof ListWebhooksResponseAttempts
     */
    'http_response_headers'?: ListWebhooksResponseAttemptsHttpResponseHeaders;
}
/**
 * Headers of the HTTP response from the configured webhook destination, with the value received.
 * @export
 * @interface ListWebhooksResponseAttemptsHttpResponseHeaders
 */
export interface ListWebhooksResponseAttemptsHttpResponseHeaders {
    /**
     * Control options for the connection.
     * @type {string}
     * @memberof ListWebhooksResponseAttemptsHttpResponseHeaders
     */
    'connection'?: string;
    /**
     * Length of the content in bytes.ook destination.
     * @type {number}
     * @memberof ListWebhooksResponseAttemptsHttpResponseHeaders
     */
    'content-length'?: number;
    /**
     * MIME type of the content.
     * @type {string}
     * @memberof ListWebhooksResponseAttemptsHttpResponseHeaders
     */
    'content-type'?: string;
    /**
     * Timestamp of the response in HTTP-date format (RFC 9110).
     * @type {string}
     * @memberof ListWebhooksResponseAttemptsHttpResponseHeaders
     */
    'date'?: string;
    /**
     * Name of the server.
     * @type {string}
     * @memberof ListWebhooksResponseAttemptsHttpResponseHeaders
     */
    'server'?: string;
}
/**
 * 
 * @export
 * @interface MassPayoutResponse
 */
export interface MassPayoutResponse {
    /**
     * Time of creation of the batch operation, in Unix time (seconds).
     * @type {number}
     * @memberof MassPayoutResponse
     */
    'created_at'?: number;
    /**
     * ID of the batch operation. String starting with **batch_**.Three-letter ISO 4217 code for the currency of an existing account.
     * @type {string}
     * @memberof MassPayoutResponse
     */
    'id'?: string;
    /**
     * Filename of the uploaded batch file.
     * @type {string}
     * @memberof MassPayoutResponse
     */
    'original_name'?: string;
    /**
     * Status of the batch operation - \"NEW\".
     * @type {string}
     * @memberof MassPayoutResponse
     */
    'status'?: string;
    /**
     * Batch operation type - \"mass_payout_pci\".
     * @type {string}
     * @memberof MassPayoutResponse
     */
    'type'?: string;
}
/**
 * Contains details of the client’s customer support. To configure these fields, use the Client Portal.
 * @export
 * @interface MerchantCustomerSupport
 */
export interface MerchantCustomerSupport {
    /**
     * Email address.
     * @type {string}
     * @memberof MerchantCustomerSupport
     */
    'email'?: string;
    /**
     * URL for the client\'s customer support service.
     * @type {string}
     * @memberof MerchantCustomerSupport
     */
    'url'?: string;
    /**
     * Phone number for contacting the client\'s customer support service.
     * @type {string}
     * @memberof MerchantCustomerSupport
     */
    'phone_number'?: string;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof MerchantCustomerSupport
     */
    'merchant_logo'?: string;
}
/**
 * Indicates the next action for completing the payment. Response only. One of the following values are - * 3d_verification - The next action is 3DS authentication. To simulate 3DS authentication in the sandbox, see Simulating 3DS Authentication. Relevant only to card payments. * pending_capture - The next action is pending the capture of the amount. Relevant only to card payments when the amount is not zero. * pending_confirmation - The next action is pending the confirmation for the payment. Relevant to all payment methods excluding card payment. * not_applicable - The payment has completed or the next action is not relevant.
 * @export
 * @enum {string}
 */

export const NextAction = {
    _3dVerification: '3d_verification',
    PendingCapture: 'pending_capture',
    PendingConfirmation: 'pending_confirmation',
    NotApplicable: 'not_applicable'
} as const;

export type NextAction = typeof NextAction[keyof typeof NextAction];


/**
 * 
 * @export
 * @interface OrderIdPayBody
 */
export interface OrderIdPayBody {
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof OrderIdPayBody
     */
    'metadata'?: object;
    /**
     * ID of the payment method. String starting with card_ or other_. If not specified, the payment method is the default_payment_method of the customer.
     * @type {string}
     * @memberof OrderIdPayBody
     */
    'payment_method'?: string;
    /**
     * ID of a customer. String starting with cus_. The order is paid with the customer\'s default payment method.
     * @type {string}
     * @memberof OrderIdPayBody
     */
    'customer'?: string;
}
/**
 * 
 * @export
 * @interface OrderIdReturnsBody
 */
export interface OrderIdReturnsBody {
    /**
     * 
     * @type {string}
     * @memberof OrderIdReturnsBody
     */
    'order_id'?: string;
    /**
     * 
     * @type {Array<V1ordersorderIdreturnsItems>}
     * @memberof OrderIdReturnsBody
     */
    'items': Array<V1ordersorderIdreturnsItems>;
}
/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof OrderItem
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'parent'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'type'?: OrderItemTypeEnum;
}

export const OrderItemTypeEnum = {
    Discount: 'discount',
    Shipping: 'shipping',
    Sku: 'sku',
    Tax: 'tax'
} as const;

export type OrderItemTypeEnum = typeof OrderItemTypeEnum[keyof typeof OrderItemTypeEnum];

/**
 * 
 * @export
 * @interface OrderItemResponse
 */
export interface OrderItemResponse {
    /**
     * Price of one SKU unit, in the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {number}
     * @memberof OrderItemResponse
     */
    'amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof OrderItemResponse
     */
    'currency'?: string;
    /**
     * Description of the item.
     * @type {string}
     * @memberof OrderItemResponse
     */
    'description'?: string;
    /**
     * ID of the SKU object that represents the product. One of the following: ID of the SKU object. String starting with sku_ ID of the coupon. If generated by Rapyd, a string starting with coupon_. 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'parent'?: string;
    /**
     * Quantity of the product in the line item. Integer. Required when type is sku.
     * @type {number}
     * @memberof OrderItemResponse
     */
    'quantity'?: number;
    /**
     * Type of line item.
     * @type {string}
     * @memberof OrderItemResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'amount_returned'?: number;
    /**
     * 
     * @type {Payment}
     * @memberof OrderResponse
     */
    'payment'?: Payment;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'external_coupon_code'?: string;
    /**
     * 
     * @type {Array<OrderItemResponse>}
     * @memberof OrderResponse
     */
    'items'?: Array<OrderItemResponse>;
    /**
     * 
     * @type {object}
     * @memberof OrderResponse
     */
    'metadata'?: object;
    /**
     * A list of the returns charged against this order.
     * @type {Array<OrderReturnedItemResponse>}
     * @memberof OrderResponse
     */
    'returns'?: Array<OrderReturnedItemResponse>;
    /**
     * 
     * @type {object}
     * @memberof OrderResponse
     */
    'shipping_address'?: object;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'status'?: string;
    /**
     * 
     * @type {OrderResponseStatusTransitions}
     * @memberof OrderResponse
     */
    'status_transitions'?: OrderResponseStatusTransitions;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'updated'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'upstream_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'tax_percent'?: number;
}
/**
 * Indicates the last time in Unix time that the order transitioned to one of the following statuses. A zero value for a status indicates that the order has never transitioned to it.
 * @export
 * @interface OrderResponseStatusTransitions
 */
export interface OrderResponseStatusTransitions {
    /**
     * 
     * @type {number}
     * @memberof OrderResponseStatusTransitions
     */
    'canceled'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponseStatusTransitions
     */
    'fulfilled'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponseStatusTransitions
     */
    'paid'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponseStatusTransitions
     */
    'returned'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponseStatusTransitions
     */
    'pending'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponseStatusTransitions
     */
    'partial'?: number;
}
/**
 * 
 * @export
 * @interface OrderReturnedItemResponse
 */
export interface OrderReturnedItemResponse {
    /**
     * 
     * @type {number}
     * @memberof OrderReturnedItemResponse
     */
    'amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof OrderReturnedItemResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnedItemResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnedItemResponse
     */
    'parent'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderReturnedItemResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnedItemResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface OrderReturnedResponse
 */
export interface OrderReturnedResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderReturnedResponse
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderReturnedResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderReturnedResponse
     */
    'created'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof OrderReturnedResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {Array<OrderReturnedItemResponse>}
     * @memberof OrderReturnedResponse
     */
    'items'?: Array<OrderReturnedItemResponse>;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnedResponse
     */
    'order'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnedResponse
     */
    'refund'?: string;
}
/**
 * 
 * @export
 * @interface OrdersOrderIdBody
 */
export interface OrdersOrderIdBody {
    /**
     * ID of a coupon that is applied against this order. String starting with **coupon_**. The duration field of the coupon must be set to **repeating**, and the `duration_in_months` and `discount_duration_in_uses` fields must be set to **1**.
     * @type {string}
     * @memberof OrdersOrderIdBody
     */
    'coupon'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof OrdersOrderIdBody
     */
    'metadata'?: object;
    /**
     * Percentage of tax to charge. Decimal.
     * @type {number}
     * @memberof OrdersOrderIdBody
     */
    'tax_percent'?: number;
    /**
     * Indicates the status of the order. Can be changed when status is pending, paid or fulfilled
     * @type {string}
     * @memberof OrdersOrderIdBody
     */
    'status'?: OrdersOrderIdBodyStatusEnum;
}

export const OrdersOrderIdBodyStatusEnum = {
    Paid: 'paid',
    Pending: 'pending',
    Canceled: 'canceled',
    Fulfilled: 'fulfilled',
    Returned: 'returned',
    Partial: 'partial'
} as const;

export type OrdersOrderIdBodyStatusEnum = typeof OrdersOrderIdBodyStatusEnum[keyof typeof OrdersOrderIdBodyStatusEnum];

/**
 * The outcome object describes the outcome of the Rapyd Protect risk assessment
 * @export
 * @interface Outcome
 */
export interface Outcome {
    /**
     * 
     * @type {string}
     * @memberof Outcome
     */
    'network_status'?: OutcomeNetworkStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Outcome
     */
    'payment_flow_type'?: OutcomePaymentFlowTypeEnum;
    /**
     * 
     * @type {PaymentOptions}
     * @memberof Outcome
     */
    'payment_options'?: PaymentOptions;
    /**
     * Indicates the status of the payment method. One of the following value is 1 means the payment_method_type is Valid
     * @type {string}
     * @memberof Outcome
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Outcome
     */
    'risk_level'?: OutcomeRiskLevelEnum;
    /**
     * Message to the merchant
     * @type {string}
     * @memberof Outcome
     */
    'seller_message'?: string;
}

export const OutcomeNetworkStatusEnum = {
    ApprovedByNetwork: 'approved_by_network',
    DeclinedByNetwork: 'declined_by_network',
    NotSentToNetwork: 'not_sent_to_network',
    ReversedAfterApproval: 'reversed_after_approval'
} as const;

export type OutcomeNetworkStatusEnum = typeof OutcomeNetworkStatusEnum[keyof typeof OutcomeNetworkStatusEnum];
export const OutcomePaymentFlowTypeEnum = {
    Direct: 'direct',
    EWallet: 'eWallet',
    EwalletPayout: 'ewallet_payout',
    Card: 'card',
    RedirectUrl: 'redirect_url'
} as const;

export type OutcomePaymentFlowTypeEnum = typeof OutcomePaymentFlowTypeEnum[keyof typeof OutcomePaymentFlowTypeEnum];
export const OutcomeRiskLevelEnum = {
    Normal: 'normal',
    Elevated: 'elevated',
    Highest: 'highest',
    NotAssessed: 'not_assessed'
} as const;

export type OutcomeRiskLevelEnum = typeof OutcomeRiskLevelEnum[keyof typeof OutcomeRiskLevelEnum];

/**
 * Collects money from a payment method and deposits it into one or more Rapyd Wallets
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {Address1}
     * @memberof Payment
     */
    'address'?: Address1;
    /**
     * The amount received by the recipient, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. To verify a card, set to 0.
     * @type {number}
     * @memberof Payment
     */
    'amount'?: number;
    /**
     * Indicates that the card payment was authorized by the card network.
     * @type {string}
     * @memberof Payment
     */
    'auth_code'?: string;
    /**
     * Reason for cancellation or reversal of a payment. Response only.
     * @type {string}
     * @memberof Payment
     */
    'cancel_reason'?: string;
    /**
     * Indicates whether the payment has been successfully captured. Response only.
     * @type {boolean}
     * @memberof Payment
     */
    'captured'?: boolean;
    /**
     * URL where the customer is redirected for final steps in completing the operation. Provided by the clientRelevant to bank redirect payment methods
     * @type {string}
     * @memberof Payment
     */
    'complete_payment_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'country_code'?: string;
    /**
     * Time of creation of the payment, in Unix time. Response only.
     * @type {number}
     * @memberof Payment
     */
    'created_at'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Payment
     */
    'currency_code'?: string;
    /**
     * ID of the customer who is making the payment. String starting with **cus_**. When a payment is created without an existing customer, the platform creates an anonymous customer with no payment methods. Response only.
     * @type {string}
     * @memberof Payment
     */
    'customer_token'?: string;
    /**
     * Description of the payment
     * @type {string}
     * @memberof Payment
     */
    'description'?: string;
    /**
     * 
     * @type {Dispute}
     * @memberof Payment
     */
    'dispute'?: Dispute;
    /**
     * Relevant error message (with an underscore between words) and ID number of the error. Response only.
     * @type {string}
     * @memberof Payment
     */
    'error_code'?: string;
    /**
     * URL where the customer is redirected in case of an error in the operation. Provided by the client.Relevant to bank redirect payment methods
     * @type {string}
     * @memberof Payment
     */
    'error_payment_url'?: string;
    /**
     * Describes the escrow. Relevant when the payment is created with escrow set to true. Response only.
     * @type {object}
     * @memberof Payment
     */
    'escrow'?: object;
    /**
     * ID of the wallet that the money is paid into. String starting with ewallet_. Relevant when the request includes a single wallet. Response only.
     * @type {string}
     * @memberof Payment
     */
    'ewallet_id'?: string;
    /**
     * Specifies the wallets that the money is collected into. If this is left blank, the money goes into the oldest \'collection\'-type client wallet. If there is no \'collection\' client wallet, the money goes into the oldest \'general\'-type client wallet.
     * @type {Array<PaymentEwallets>}
     * @memberof Payment
     */
    'ewallets'?: Array<PaymentEwallets>;
    /**
     * End of the time allowed for customer to make this payment, in Unix time. Must be after the current time
     * @type {number}
     * @memberof Payment
     */
    'expiration'?: number;
    /**
     * Error code explaining the reason for failure of the payment. Response only.
     * @type {string}
     * @memberof Payment
     */
    'failure_code'?: string;
    /**
     * Message to the merchant, explaining the reason for failure of the payment. Response only.
     * @type {string}
     * @memberof Payment
     */
    'failure_message'?: string;
    /**
     * Indicates whether the FX rate is fixed for the buy side (seller) or for the sell side (buyer). * buy - The currency that the Rapyd Wallet receives for goods or services. Fixed side buy relates to the seller (merchant) funds. For example, a US-based merchant wants to charge 100 USD. The buyer (customer) pays the amount in MXN that converts to 100 USD. This is the default. * sell - The currency that the buyer is charged for purchasing goods or services. Fixed side sell relates to the buyer (customer) funds. For example, a US-based merchant wants to charge a buyer 2,000 MXN and will accept whatever amount in USD that is converted from 2,000 MXN.
     * @type {string}
     * @memberof Payment
     */
    'fixed_side'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof Payment
     */
    'flow_type'?: string;
    /**
     * Exchange rate for the transaction. When fixed_side is buy, fx_rate is the buy rate. When fixed_side is sell, fx_rate is the sell rate. Decimal number as string. Response only.
     * @type {number}
     * @memberof Payment
     */
    'fx_rate'?: number;
    /**
     * ID of the group payment. String starting with gp_. Relevant when the payment is part of a group payment.
     * @type {string}
     * @memberof Payment
     */
    'group_payment'?: string;
    /**
     * ID of the payment. String starting with payment_. Response only
     * @type {string}
     * @memberof Payment
     */
    'id'?: string;
    /**
     * Reason for cancellation or reversal of a payment. Response only.
     * @type {string}
     * @memberof Payment
     */
    'initiation_type'?: string;
    /**
     * Describes how the customer makes the payment. Read-only. Contains the following fields - * name - Description of the payment method. * steps - A steps object containing a list of steps for the customer to take. Each step is named stepN, where N is an integer.
     * @type {Array<PaymentInstructions>}
     * @memberof Payment
     */
    'instructions'?: Array<PaymentInstructions>;
    /**
     * ID of the invoice that this payment is for. String starting with inv_. Response only.
     * @type {string}
     * @memberof Payment
     */
    'invoice'?: string;
    /**
     * Indicates whether the payment has been partially paid. When false, indicates that the payment is unpaid or fully paid. Response only.
     * @type {boolean}
     * @memberof Payment
     */
    'is_partial'?: boolean;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof Payment
     */
    'merchant_reference_id'?: string;
    /**
     * Indicates the amount paid by the payer, in units of the currency defined in merchant_requested_currency. Relevant to payments with FX. Read only.
     * @type {string}
     * @memberof Payment
     */
    'merchant_requested_amount'?: string;
    /**
     * Indicates the currency that merchant receives. Three-letter ISO 4217 code. Uppercase. Relevant to payments with FX. Response only.
     * @type {string}
     * @memberof Payment
     */
    'merchant_requested_currency'?: string;
    /**
     * A JSON object defined by the client in the Customer Payment Method object. Response only.
     * @type {object}
     * @memberof Payment
     */
    'metadata'?: object;
    /**
     * Reserved
     * @type {string}
     * @memberof Payment
     */
    'mid'?: string;
    /**
     * 
     * @type {NextAction}
     * @memberof Payment
     */
    'next_action'?: NextAction;
    /**
     * ID of the order that this payment is for. Read-only. Relevant when the payment is for an order.
     * @type {string}
     * @memberof Payment
     */
    'order'?: string;
    /**
     * * Foreign exchange payments - The amount paid by the sender, in units of the currency defined in requested_currency, including gross transaction fees and gross FX fees. * Payments not involving foreign exchange - The amount of the payment, in units of the currency defined in currency, including gross transaction fees. Response only.
     * @type {number}
     * @memberof Payment
     */
    'original_amount'?: number;
    /**
     * 
     * @type {Outcome}
     * @memberof Payment
     */
    'outcome'?: Outcome;
    /**
     * Indicates whether the payment has been fully captured. Response only.
     * @type {boolean}
     * @memberof Payment
     */
    'paid'?: boolean;
    /**
     * Time of the last capture, in Unix time. Response only.
     * @type {number}
     * @memberof Payment
     */
    'paid_at'?: number;
    /**
     * 
     * @type {Fee}
     * @memberof Payment
     */
    'payment_fees'?: Fee | null;
    /**
     * payment_method ID or object. If not specified in this field, the payment method is the default payment method specified for the customer. Mandatory when there is no default payment method. For a description of the fields in the payment_method object, see Customer Payment Method Object.
     * @type {string}
     * @memberof Payment
     */
    'payment_method'?: string;
    /**
     * Details of the payment_method_data object. See Payment Method Data Object. Response only.
     * @type {object}
     * @memberof Payment
     */
    'payment_method_data'?: object | null;
    /**
     * Object describing additional payment method fields required for the payment. These values are not saved as part of the payment method object. To determine the fields required, run Get Payment Method Required Fields.
     * @type {object}
     * @memberof Payment
     */
    'payment_method_options'?: object;
    /**
     * A type of payment method that a customer can use for making payments.  The payment method type has a suffix with one of the following values [_bank, _card, _cash, _ewallet]
     * @type {string}
     * @memberof Payment
     */
    'payment_method_type'?: string;
    /**
     * Category of payment method type. Read-only.
     * @type {string}
     * @memberof Payment
     */
    'payment_method_type_category'?: PaymentPaymentMethodTypeCategoryEnum;
    /**
     * Email address that the receipt for this transaction is sent to
     * @type {string}
     * @memberof Payment
     */
    'receipt_email'?: string;
    /**
     * Reserved. Response only
     * @type {string}
     * @memberof Payment
     */
    'receipt_number'?: string;
    /**
     * URL where the customer is redirected for additional steps required for the payment. Response only. To simulate 3DS authentication in the sandbox, see Simulating 3DS Authentication
     * @type {string}
     * @memberof Payment
     */
    'redirect_url'?: string;
    /**
     * Indicates whether there was a refund against this payment. Response only.
     * @type {boolean}
     * @memberof Payment
     */
    'refunded'?: boolean;
    /**
     * The total amount refunded against this payment, in units of the currency defined in currency. Response only.
     * @type {number}
     * @memberof Payment
     */
    'refunded_amount'?: number;
    /**
     * 
     * @type {PaymentRefunds}
     * @memberof Payment
     */
    'refunds'?: PaymentRefunds;
    /**
     * Contains the customer name and the associated bank account. This includes - * name - Name of the customer. * account_id - ID of the customer\'s bank account. * bank_code - SWIFT code for the customer\'s bank. Response only.
     * @type {object}
     * @memberof Payment
     */
    'remitter_information'?: object;
    /**
     * * true - Saves the card for future use. This is the default. * false - Does not save the card. Relevant when payment_method_type_category is card and the \"Create Payment\" request includes full card details.
     * @type {boolean}
     * @memberof Payment
     */
    'save_payment_method'?: boolean;
    /**
     * A text description suitable for a customer\'s payment statement. Limited to 22 characters. If this field is not specified, Rapyd populates it with the name of the merchant
     * @type {string}
     * @memberof Payment
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof Payment
     */
    'status'?: PaymentStatus;
    /**
     * A set of text codes for the customer to use to complete the steps described in the instructions field. Response only.   The name of the field is the local name of the code, or some other label. For example   * code * paycode * pay_code * payid * pairing_code * payment_code * response_code
     * @type {object}
     * @memberof Payment
     */
    'textual_codes'?: object;
    /**
     * ID of the associated transaction. Response only
     * @type {string}
     * @memberof Payment
     */
    'transaction_id'?: string;
    /**
     * A set of images for the customer to use to complete the steps described in the instructions field. For example, a QR code or barcode. Response only.
     * @type {object}
     * @memberof Payment
     */
    'visual_codes'?: object;
}

export const PaymentPaymentMethodTypeCategoryEnum = {
    BankTransfer: 'bank_transfer',
    BankRedirect: 'bank_redirect',
    Card: 'card',
    Cash: 'cash',
    Ewallet: 'ewallet'
} as const;

export type PaymentPaymentMethodTypeCategoryEnum = typeof PaymentPaymentMethodTypeCategoryEnum[keyof typeof PaymentPaymentMethodTypeCategoryEnum];

/**
 * 
 * @export
 * @interface PaymentAmountRangePerCurrencyInner
 */
export interface PaymentAmountRangePerCurrencyInner {
    /**
     * Maximum amount supported by this payout method for the indicated currency. Decimal number.
     * @type {number}
     * @memberof PaymentAmountRangePerCurrencyInner
     */
    'maximum_amount'?: number;
    /**
     * Minimum amount supported by this payout method for the indicated currency. Decimal number.
     * @type {number}
     * @memberof PaymentAmountRangePerCurrencyInner
     */
    'minimum_amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof PaymentAmountRangePerCurrencyInner
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface PaymentEwallets
 */
export interface PaymentEwallets {
    /**
     * 
     * @type {string}
     * @memberof PaymentEwallets
     */
    'ewallet_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentEwallets
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentEwallets
     */
    'percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentEwallets
     */
    'refunded_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentEwallets
     */
    'released_amount'?: number;
}
/**
 * 
 * @export
 * @interface PaymentFee
 */
export interface PaymentFee {
    /**
     * 
     * @type {FxFee}
     * @memberof PaymentFee
     */
    'fx_fee'?: FxFee;
    /**
     * The total gross fees for the transaction, in units defined by currency_code. Relevant to responses.
     * @type {number}
     * @memberof PaymentFee
     */
    'gross_fees'?: number;
    /**
     * The total net fees for the transaction, in units defined by merchant_requested_currency. Relevant to responses.
     * @type {number}
     * @memberof PaymentFee
     */
    'net_fees'?: number;
    /**
     * 
     * @type {TransactionFee}
     * @memberof PaymentFee
     */
    'transaction_fee'?: TransactionFee;
}
/**
 * 
 * @export
 * @interface PaymentIdCaptureBody
 */
export interface PaymentIdCaptureBody {
    /**
     * The amount to capture, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {number}
     * @memberof PaymentIdCaptureBody
     */
    'amount'?: number;
    /**
     * Email address that the receipt for this transaction is sent to.
     * @type {string}
     * @memberof PaymentIdCaptureBody
     */
    'receipt_email'?: string;
    /**
     * A text description suitable for a customer\'s payment statement. Some payment methods truncate this string to a limited number of characters.
     * @type {string}
     * @memberof PaymentIdCaptureBody
     */
    'statement_descriptor'?: string;
}
/**
 * 
 * @export
 * @interface PaymentInstructions
 */
export interface PaymentInstructions {
    /**
     * 
     * @type {string}
     * @memberof PaymentInstructions
     */
    'name'?: string;
    /**
     * 
     * @type {Array<PaymentSteps>}
     * @memberof PaymentInstructions
     */
    'steps'?: Array<PaymentSteps>;
}
/**
 * Retrieves details of a payment link.
 * @export
 * @interface PaymentLink
 */
export interface PaymentLink {
    /**
     * The amount of the payment, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. On the hosted payment page, the customer: <BR><BR> Cannot modify the amount when amount_is_editable is false or not used. <BR><BR> Can modify the amount when amount_is_editable is true and amount has a positive value. <BR><BR> Must enter an amount when amount_is_editable is true and amount is 0, null, or not used.
     * @type {number}
     * @memberof PaymentLink
     */
    'amount'?: number;
    /**
     * Determines whether the customer can edit the amount.<br><br> **true** - The customer can edit the amount. <br><br> **false** - The customer cannot edit the amount.
     * @type {boolean}
     * @memberof PaymentLink
     */
    'amount_is_editable'?: boolean;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof PaymentLink
     */
    'country'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country. <BR><BR> **Transactions without FX** - Indicates the currency of the amount received by the recipient. BR><BR> **FX transactions** - Indicates the currency of the amount paid by the buyer.
     * @type {string}
     * @memberof PaymentLink
     */
    'currency'?: string;
    /**
     * ID of a specific customer. String starting with **cus_**. Restricts the payment link to the customer.
     * @type {string}
     * @memberof PaymentLink
     */
    'customer'?: string;
    /**
     * Indicates whether the FX rate is fixed for the buy side (seller) or for the sell side (buyer). <BR><BR> * buy - The currency that the Rapyd Wallet receives for goods or services. Fixed side buy relates to the seller (merchant) funds. For example, a US-based merchant wants to charge 100 USD. The buyer (customer) pays the amount in MXN that converts to 100 USD. This is the default. <BR><BR> * sell - The currency that the buyer is charged for purchasing goods or services. Fixed side sell relates to the buyer (customer) funds. For example, a US-based merchant wants to charge a buyer 2,000 MXN and will accept whatever amount in USD that is converted from 2,000 MXN.
     * @type {string}
     * @memberof PaymentLink
     */
    'fixed_side'?: string;
    /**
     * ID of the payment link. String starting with **hp_reuse_**.
     * @type {string}
     * @memberof PaymentLink
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see https://docs.rapyd.net/en/list-supported-languages.html. <BR><BR> When this parameter is null, the language of the user\'s browser is used. BR><BR> If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof PaymentLink
     */
    'language'?: string;
    /**
     * Indicates the maximum number of times that the payment link can be used for payments. When not defined, there is no limit.
     * @type {number}
     * @memberof PaymentLink
     */
    'max_payments'?: number;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof PaymentLink
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page. To configure this field, use the Client Portal. See https://docs.rapyd.net/en/customizing-your-hosted-page.html.
     * @type {string}
     * @memberof PaymentLink
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {MerchantCustomerSupport}
     * @memberof PaymentLink
     */
    'merchant_customer_support'?: MerchantCustomerSupport;
    /**
     * URL for the image of the client\'s logo. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof PaymentLink
     */
    'merchant_logo'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof PaymentLink
     */
    'merchant_privacy_policy'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof PaymentLink
     */
    'merchant_reference_id'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when one or both of the following fields is unset: <BR><BR> * `cancel_url` <BR><BR> * `complete_url`<BR><BR> To configure this field, use the Client Portal
     * @type {string}
     * @memberof PaymentLink
     */
    'merchant_website'?: string;
    /**
     * End of the time when the customer can use the payment link, in Unix time. One year after creation. <BR> <BR> **Note:** Each hosted page that the payment link generates expires 14 days after creation.
     * @type {number}
     * @memberof PaymentLink
     */
    'page_expiration'?: number;
    /**
     * Currency for one side of an FX transaction. Three-letter ISO 4217 code. <BR><BR>* When `fixed_side` is **sell**, it is the currency received in the Rapyd Wallet. <BR><BR>* When `fixed_side` is **buy**, it is the currency charged to the buyer (customer).
     * @type {string}
     * @memberof PaymentLink
     */
    'requested_currency'?: string;
    /**
     * The payment link URL.
     * @type {string}
     * @memberof PaymentLink
     */
    'redirect_url'?: string;
    /**
     * Status of the hosted payment page. One of the following: <BR><BR>* **NEW** - The hosted page was created. <BR><BR>* **EXP** - The hosted page expired.
     * @type {string}
     * @memberof PaymentLink
     */
    'status'?: string;
    /**
     * Optional parameters for the checkout page.
     * @type {object}
     * @memberof PaymentLink
     */
    'template'?: object;
}
/**
 * A type of payment method that a customer can use for making payments.
 * @export
 * @interface PaymentMethodType
 */
export interface PaymentMethodType {
    /**
     * Indicates the amount range for the payment method\'s currencies. Each object contains the following fields:* currency - Three-letter ISO 4217 format of currency* maximum_amount - The maximum payment amount* minimum_amount - The minimum payment amount
     * @type {Array<PaymentAmountRangePerCurrencyInner>}
     * @memberof PaymentMethodType
     */
    'amount_range_per_currency'?: Array<PaymentAmountRangePerCurrencyInner>;
    /**
     * 
     * @type {Category}
     * @memberof PaymentMethodType
     */
    'category'?: Category;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodType
     */
    'country'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentMethodType
     */
    'currencies'?: Array<string>;
    /**
     * Payment Method Type required field
     * @type {Array<Field1>}
     * @memberof PaymentMethodType
     */
    'fields'?: Array<Field1>;
    /**
     * A URL to the image of the icon for the type of payment method. Response only
     * @type {string}
     * @memberof PaymentMethodType
     */
    'image'?: string;
    /**
     * Indicates whether a payment made with this payment method can be canceled. Response only
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_cancelable'?: boolean;
    /**
     * Indicates whether the merchant can set an expiration time for the customer to complete the payment. Response only
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_expirable'?: boolean;
    /**
     * Indicates whether the payment is completed immediately online. Response only
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_online'?: boolean;
    /**
     * Indicates whether the payment method type supports refunds
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_refundable'?: boolean;
    /**
     * Indicates whether the token of the payment method can be used in a collect operation
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_tokenizable'?: boolean;
    /**
     * Indicates whether a Web-based version of the payment method type exists
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_virtual'?: boolean;
    /**
     * The maximum time (in seconds) that the merchant can set for completing the payment. Relevant when is_expirable is true
     * @type {number}
     * @memberof PaymentMethodType
     */
    'maximum_expiration_seconds'?: number;
    /**
     * The minimum time (in seconds) that the merchant can set for completing the payment. Relevant when is_expirable is true
     * @type {number}
     * @memberof PaymentMethodType
     */
    'minimum_expiration_seconds'?: number;
    /**
     * Indicates whether multiple overage charges are allowed for this payment method type
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'multiple_overage_allowed'?: boolean;
    /**
     * The name of the payment method, in user-friendly terms. For example, Ireland Visa card. Response only
     * @type {string}
     * @memberof PaymentMethodType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodType
     */
    'payment_flow_type'?: PaymentMethodTypePaymentFlowTypeEnum;
    /**
     * 
     * @type {Array<Field1>}
     * @memberof PaymentMethodType
     */
    'payment_options'?: Array<Field1>;
    /**
     * Indicates the status of the payment method. One of the following value is 1 means the payment_method_type is Valid
     * @type {string}
     * @memberof PaymentMethodType
     */
    'status'?: string;
    /**
     * Describes the digital wallet providers that support the payment method. These providers may include **apple_pay** and **google_pay**.
     * @type {Array<string>}
     * @memberof PaymentMethodType
     */
    'supported_digital_wallet_providers'?: Array<string>;
    /**
     * Type of the payment method. For example, it_visa_card
     * @type {string}
     * @memberof PaymentMethodType
     */
    'type'?: string;
    /**
     * Indicates the name of the Web-based version of this payment method type
     * @type {string}
     * @memberof PaymentMethodType
     */
    'virtual_payment_method_type'?: string;
    /**
     * Indicates if the payment method type restricted or not.
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'is_restricted'?: boolean;
    /**
     * Indicates if the payment method type supports subscription.
     * @type {boolean}
     * @memberof PaymentMethodType
     */
    'supports_subscription'?: boolean;
}

export const PaymentMethodTypePaymentFlowTypeEnum = {
    Direct: 'direct',
    EWallet: 'eWallet',
    EwalletPayout: 'ewallet_payout',
    Card: 'card',
    RedirectUrl: 'redirect_url',
    Cash: 'cash',
    BankTransfer: 'bank transfer'
} as const;

export type PaymentMethodTypePaymentFlowTypeEnum = typeof PaymentMethodTypePaymentFlowTypeEnum[keyof typeof PaymentMethodTypePaymentFlowTypeEnum];

/**
 * Payment Method Type required fields - this is the response of GET required fields for Payment_Method_Type
 * @export
 * @interface PaymentMethodTypeRequiredFields
 */
export interface PaymentMethodTypeRequiredFields {
    /**
     * Payment Method Type required field
     * @type {Array<Field1>}
     * @memberof PaymentMethodTypeRequiredFields
     */
    'fields'?: Array<Field1>;
    /**
     * The maximum time (in seconds) that the merchant can set for completing the payment. Relevant when is_expirable is true
     * @type {number}
     * @memberof PaymentMethodTypeRequiredFields
     */
    'maximum_expiration_seconds'?: number;
    /**
     * The minimum time (in seconds) that the merchant can set for completing the payment. Relevant when is_expirable is true
     * @type {number}
     * @memberof PaymentMethodTypeRequiredFields
     */
    'minimum_expiration_seconds'?: number;
    /**
     * payment method option
     * @type {Array<Field1>}
     * @memberof PaymentMethodTypeRequiredFields
     */
    'payment_method_options'?: Array<Field1>;
    /**
     * 
     * @type {Array<Field1>}
     * @memberof PaymentMethodTypeRequiredFields
     */
    'payment_options'?: Array<Field1>;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodTypeRequiredFields
     */
    'type'?: string;
}
/**
 * A payment method type is a type of payment method that any customer can use, for example, ee_mastercard_card, Mastercard for Estonia. When it is added to a customer profile, it becomes a payment method that is specific to that one customer. The name of the payment method type starts with a prefix for the country, the 2-letter ISO 3166-1 alpha-2 code. If the payment method is valid in multiple countries, the prefix is xx_. The payment method type has a suffix with one of the following values - _bank - Bank transfer or bank redirect _card - Credit card, debit card or other card _cash - Cash _ewallet - Local eWallet
 * @export
 * @interface PaymentOptions
 */
export interface PaymentOptions {
    /**
     * 
     * @type {Address1}
     * @memberof PaymentOptions
     */
    'address'?: Address1;
    /**
     * Indicates the amount range for the payment method\'s currencies. Each object contains the following fields:* currency - Three-letter ISO 4217 format of currency* maximum_amount - The maximum payment amount* minimum_amount - The minimum payment amount
     * @type {Array<PaymentAmountRangePerCurrencyInner>}
     * @memberof PaymentOptions
     */
    'amount_range_per_currency'?: Array<PaymentAmountRangePerCurrencyInner>;
    /**
     * 
     * @type {BinDetails}
     * @memberof PaymentOptions
     */
    'bin_details'?: BinDetails;
    /**
     * 
     * @type {Category}
     * @memberof PaymentOptions
     */
    'category'?: Category;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof PaymentOptions
     */
    'conditions'?: Array<Condition>;
    /**
     * 
     * @type {string}
     * @memberof PaymentOptions
     */
    'country'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentOptions
     */
    'currencies'?: Array<string>;
    /**
     * 
     * @type {Customer}
     * @memberof PaymentOptions
     */
    'customer'?: Customer;
    /**
     * Hash of the card number, expiration date and CVV. Read-only. Relevant to cards
     * @type {string}
     * @memberof PaymentOptions
     */
    'fingerprint'?: string;
    /**
     * A URL to the image of the icon for the type of payment method. Response only
     * @type {string}
     * @memberof PaymentOptions
     */
    'image'?: string;
    /**
     * Instructions for the field. Response only
     * @type {string}
     * @memberof PaymentOptions
     */
    'instructions'?: string;
    /**
     * Indicates whether a payment made with this payment method can be canceled. Response only
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_cancelable'?: boolean;
    /**
     * Indicates whether the merchant can set an expiration time for the customer to complete the payment. Response only
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_expirable'?: boolean;
    /**
     * Indicates whether the payment is completed immediately online. Response only
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_online'?: boolean;
    /**
     * Indicates whether the payment method type supports refunds
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_refundable'?: boolean;
    /**
     * Whether the field is required for using the payment method. When the conditions defined by conditions are met, the field is required even though the value of is_required is false. Response only
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_required'?: boolean;
    /**
     * Indicates whether the token of the payment method can be used in a collect operation
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_tokenizable'?: boolean;
    /**
     * Indicates whether a Web-based version of the payment method type exists
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'is_virtual'?: boolean;
    /**
     * last4 - Last four digits of the card number. Read-only. Relevant to cards
     * @type {string}
     * @memberof PaymentOptions
     */
    'last4'?: string;
    /**
     * The maximum time (in seconds) that the merchant can set for completing the payment. Relevant when is_expirable is true. Response only
     * @type {number}
     * @memberof PaymentOptions
     */
    'maximum_expiration_seconds'?: number;
    /**
     * The minimum time (in seconds) that the merchant can set for completing the payment. Relevant when is_expirable is true. Response only
     * @type {number}
     * @memberof PaymentOptions
     */
    'minimum_expiration_seconds'?: number;
    /**
     * Indicates whether multiple overage charges are allowed for this payment method type
     * @type {boolean}
     * @memberof PaymentOptions
     */
    'multiple_overage_allowed'?: boolean;
    /**
     * The name of the payment method, in user-friendly terms. For example, \'Ireland Visa card\'. Response only
     * @type {string}
     * @memberof PaymentOptions
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentOptions
     */
    'payment_flow_type'?: PaymentOptionsPaymentFlowTypeEnum;
}

export const PaymentOptionsPaymentFlowTypeEnum = {
    Direct: 'direct',
    EWallet: 'eWallet',
    EwalletPayout: 'ewallet_payout',
    Card: 'card',
    RedirectUrl: 'redirect_url'
} as const;

export type PaymentOptionsPaymentFlowTypeEnum = typeof PaymentOptionsPaymentFlowTypeEnum[keyof typeof PaymentOptionsPaymentFlowTypeEnum];

/**
 * 
 * @export
 * @interface PaymentParams
 */
export interface PaymentParams {
    /**
     * URL where the customer is redirected after successfully completing an operation on a hosted page. Does not support localhost URLs.
     * @type {string}
     * @memberof PaymentParams
     */
    'complete_payment_url'?: string;
    /**
     * URL where the customer is redirected if an error occurs during or after an operation on a hosted page. Does not support localhost URLs.
     * @type {string}
     * @memberof PaymentParams
     */
    'error_payment_url'?: string;
}
/**
 * Refunds object
 * @export
 * @interface PaymentRefunds
 */
export interface PaymentRefunds {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentRefunds
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentRefunds
     */
    'has_more'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentRefunds
     */
    'total_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRefunds
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Act: 'ACT',
    Clo: 'CLO',
    Err: 'ERR',
    Can: 'CAN',
    Exp: 'EXP',
    Dld: 'DLD',
    Rev: 'REV',
    Und: 'UND',
    Cre: 'CRE'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 * @export
 * @interface PaymentSteps
 */
export interface PaymentSteps {
    /**
     * 
     * @type {string}
     * @memberof PaymentSteps
     */
    'step'?: string;
}
/**
 * 
 * @export
 * @interface PaymentsCompletePaymentBody
 */
export interface PaymentsCompletePaymentBody {
    /**
     * ID of the payment to complete. String starting with **payment_**.
     * @type {string}
     * @memberof PaymentsCompletePaymentBody
     */
    'token'?: string;
    /**
     * Depends on the type of payment method. <BR> * bank_redirect - **rapyd** <BR>* bank_transfer - The value returned in the code field of the `textual_codes` object. You can find this field in the response to the \'Create Payment\' request. If the `code` field is empty, `param1` is not required.<BR>* cash - Not required.<BR>* ewallet - Not required.
     * @type {string}
     * @memberof PaymentsCompletePaymentBody
     */
    'param1'?: string;
    /**
     * Depends on the type of payment method. <BR> * bank_redirect - **success** <BR>* bank_transfer -  Original payment amount. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.<BR>* cash - Not required.<BR>* ewallet - Not required.
     * @type {string}
     * @memberof PaymentsCompletePaymentBody
     */
    'param2'?: string;
}
/**
 * 
 * @export
 * @interface PaymentsGroupPaymentsBody
 */
export interface PaymentsGroupPaymentsBody {
    /**
     * Description of the group payment
     * @type {string}
     * @memberof PaymentsGroupPaymentsBody
     */
    'description'?: string;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof PaymentsGroupPaymentsBody
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PaymentsGroupPaymentsBody
     */
    'metadata'?: object;
    /**
     * Array of \'payment\' objects. For details about the fields in the \'payment\' object, see [Create Payment](https://docs.rapyd.net/en/create-payment.html).
     * @type {object}
     * @memberof PaymentsGroupPaymentsBody
     */
    'payments': object;
}
/**
 * 
 * @export
 * @interface PaymentsPaymentIdBody
 */
export interface PaymentsPaymentIdBody {
    /**
     * 
     * @type {Address1}
     * @memberof PaymentsPaymentIdBody
     */
    'address'?: Address1;
    /**
     * Description of the payment.
     * @type {string}
     * @memberof PaymentsPaymentIdBody
     */
    'description'?: string;
    /**
     * To release escrow funds immediately, set to false. If there are multiple sellers, the funds are released to all of them. Relevant to payments with escrow.
     * @type {boolean}
     * @memberof PaymentsPaymentIdBody
     */
    'escrow'?: boolean;
    /**
     * Defines the number of days after the creation of the payment that the funds are automatically released. Relevant when escrow is true.
     * @type {number}
     * @memberof PaymentsPaymentIdBody
     */
    'escrow_release_days'?: number;
    /**
     * Category of transaction initiation type.
     * @type {string}
     * @memberof PaymentsPaymentIdBody
     */
    'initiation_type'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PaymentsPaymentIdBody
     */
    'metadata'?: object;
    /**
     * Email address that the receipt for this transaction is sent to.
     * @type {string}
     * @memberof PaymentsPaymentIdBody
     */
    'receipt_email'?: string;
}
/**
 * 
 * @export
 * @interface PaymentsSubscriptionsBody
 */
export interface PaymentsSubscriptionsBody {
    /**
     * Determines the method of billing. Set to **pay_automatically**.
     * @type {string}
     * @memberof PaymentsSubscriptionsBody
     */
    'billing'?: string;
    /**
     * Determines the start of the next billing cycle, as defined in the plan described in the \'items\'. Value must be timestamp in Unix time.
     * @type {number}
     * @memberof PaymentsSubscriptionsBody
     */
    'billing_cycle_anchor'?: number;
    /**
     * Terminates the subscription at the end of the current billing period.
     * @type {boolean}
     * @memberof PaymentsSubscriptionsBody
     */
    'cancel_at_period_end'?: boolean;
    /**
     * The ID of a discount coupon that applies to all subscription items associated with this subscription. If the coupon defines a fixed monetary discount, it must use the same currency as the subscription\'s plan.
     * @type {string}
     * @memberof PaymentsSubscriptionsBody
     */
    'coupon'?: string;
    /**
     * ID of the customer who pays for this subscription. String starting with cus_.
     * @type {string}
     * @memberof PaymentsSubscriptionsBody
     */
    'customer': string;
    /**
     * Number of days from the invoice date for customer to complete the payment.
     * @type {number}
     * @memberof PaymentsSubscriptionsBody
     */
    'days_until_due'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PaymentsSubscriptionsBody
     */
    'metadata'?: object;
    /**
     * 
     * @type {Payment}
     * @memberof PaymentsSubscriptionsBody
     */
    'payment_fields'?: Payment;
    /**
     * 
     * @type {V1PaymentsBodyPaymentMethod}
     * @memberof PaymentsSubscriptionsBody
     */
    'payment_method'?: V1PaymentsBodyPaymentMethod;
    /**
     * Determines whether each upcoming subscription invoice is issued immediately. When true, the invoice is issued when the subscription is created. When false (the default), the invoice is issued an hour after the subscription is created.
     * @type {boolean}
     * @memberof PaymentsSubscriptionsBody
     */
    'simultaneous_invoice'?: boolean;
    /**
     * Array of subscription items. Each item contains a plan (required) and a quantity
     * @type {Array<V1paymentssubscriptionsSubscriptionItems>}
     * @memberof PaymentsSubscriptionsBody
     */
    'subscription_items': Array<V1paymentssubscriptionsSubscriptionItems>;
    /**
     * The percentage of tax that is applied to the entire amount of the invoice.
     * @type {number}
     * @memberof PaymentsSubscriptionsBody
     */
    'tax_percent'?: number;
    /**
     * The time of the end of the customer\'s free trial period. If trial_from_plan is set, leave this parameter unset.
     * @type {number}
     * @memberof PaymentsSubscriptionsBody
     */
    'trial_end'?: number;
    /**
     * Determines whether a free trial period can be defined in a \'plan\' object attached to the subscription. If trial_end is set, leave this parameter unset.
     * @type {boolean}
     * @memberof PaymentsSubscriptionsBody
     */
    'trial_from_plan'?: boolean;
    /**
     * The number of days in the customer\'s free trial period.
     * @type {number}
     * @memberof PaymentsSubscriptionsBody
     */
    'trial_period_days'?: number;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * Amount of the payout, in units defined by payout_currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. Same as payout_amount. Response only.
     * @type {number}
     * @memberof Payout
     */
    'amount'?: number;
    /**
     * 
     * @type {Beneficiary}
     * @memberof Payout
     */
    'beneficiary'?: Beneficiary;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'beneficiary_country'?: string;
    /**
     * Time of creation of the payout, in Unix time. Response only.
     * @type {number}
     * @memberof Payout
     */
    'created_at'?: number;
    /**
     * Description of the payout transaction.
     * @type {string}
     * @memberof Payout
     */
    'description'?: string;
    /**
     * Indicates the error code of the last unsuccessful operation on the Payout object.
     * @type {string}
     * @memberof Payout
     */
    'error'?: string | null;
    /**
     * The estimated time period in which the beneficiary will receive the funds.
     * @type {string}
     * @memberof Payout
     */
    'estimated_time_of_arrival'?: string;
    /**
     * An array of one object, which contains the following fields: * ewallet_id - The ID of the wallet that the money is transferred from, a string starting with **ewallet_**. * amount - Amount of the transaction in currency units defined in currency. * percent - A decimal number representing a percentage of the total payout. Response only.
     * @type {Array<PayoutEwallets>}
     * @memberof Payout
     */
    'ewallets'?: Array<PayoutEwallets>;
    /**
     * Determines the day the payout expires, in Unix time. The payout must be completed before the start of this day. Relevant to cash payout methods where the is_expirable field is true in the response to List Payout Method Types.
     * @type {number}
     * @memberof Payout
     */
    'expiration'?: number | null;
    /**
     * Currency conversion rate for the payout. Decimal. Response only.
     * @type {number}
     * @memberof Payout
     */
    'fx_rate'?: number;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof Payout
     */
    'gc_error_code'?: string | null;
    /**
     * ID of the payout. String starting with **payout_**.
     * @type {string}
     * @memberof Payout
     */
    'id'?: string;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof Payout
     */
    'identifier_type'?: string | null;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof Payout
     */
    'identifier_value'?: string | null;
    /**
     * Describes how the customer collects the payout. Contains the following fields: * name - Short description of the instructions. * steps - A \'steps\' object containing a list of steps for the customer to take. Each step is named stepN, where N is an integer. 
     * @type {Array<PayoutInstructions>}
     * @memberof Payout
     */
    'instructions'?: Array<PayoutInstructions>;
    /**
     * Additional information from the merchant. For example, the merchant\'s instructions and transaction number that must be presented for collecting the payout.
     * @type {object}
     * @memberof Payout
     */
    'instructions_value'?: object;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof Payout
     */
    'merchant_reference_id'?: string | null;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Payout
     */
    'metadata'?: object;
    /**
     * Cumulative amount received by the beneficiary, in units defined by payout_currency. Response only.
     * @type {number}
     * @memberof Payout
     */
    'paid_amount'?: number;
    /**
     * Time of the payout, in Unix time. Response only.
     * @type {string}
     * @memberof Payout
     */
    'paid_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'payout_currency'?: string;
    /**
     * 
     * @type {PayoutFees}
     * @memberof Payout
     */
    'payout_fees'?: PayoutFees | null;
    /**
     * The type of payout method. The two-letter prefix must match the beneficiary country computed.
     * @type {string}
     * @memberof Payout
     */
    'payout_method_type'?: string;
    /**
     * The type of the payout method.
     * @type {string}
     * @memberof Payout
     */
    'payout_type'?: PayoutPayoutTypeEnum;
    /**
     * 
     * @type {Sender}
     * @memberof Payout
     */
    'sender'?: Sender;
    /**
     * Amount that the sender is paying in units of the currency defined in sender_currency.  This amount remains the same regardless of FX fees. Required when payout_amount is not used. Decimal. 
     * @type {number}
     * @memberof Payout
     */
    'sender_amount'?: number;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof Payout
     */
    'sender_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'sender_currency'?: string;
    /**
     * A statement that includes the reason for the payout. Limited to 35 characters.
     * @type {string}
     * @memberof Payout
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof Payout
     */
    'status'?: PayoutStatus;
}

export const PayoutPayoutTypeEnum = {
    Card: 'card',
    Cash: 'cash',
    Ewallet: 'ewallet',
    Bank: 'bank',
    RapydEwallet: 'rapyd_ewallet'
} as const;

export type PayoutPayoutTypeEnum = typeof PayoutPayoutTypeEnum[keyof typeof PayoutPayoutTypeEnum];

/**
 * 
 * @export
 * @interface PayoutAmountRangePerCurrencyInner
 */
export interface PayoutAmountRangePerCurrencyInner {
    /**
     * Maximum amount supported by this payout method for the indicated currency. Decimal number.
     * @type {number}
     * @memberof PayoutAmountRangePerCurrencyInner
     */
    'maximum_amount'?: number;
    /**
     * Minimum amount supported by this payout method for the indicated currency. Decimal number.
     * @type {number}
     * @memberof PayoutAmountRangePerCurrencyInner
     */
    'minimum_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PayoutAmountRangePerCurrencyInner
     */
    'payout_currency'?: string;
}
/**
 * 
 * @export
 * @interface PayoutEwallets
 */
export interface PayoutEwallets {
    /**
     * The amount of the payment to the wallet, in units of the currency defined in currency. Decimal. If the total amount of the payment is not fully accounted for, the balance appears in the client wallet. Relevant when percentage is not set.
     * @type {number}
     * @memberof PayoutEwallets
     */
    'amount'?: number;
    /**
     * ID of the wallet. String starting with **ewallet_**. Read-only.
     * @type {string}
     * @memberof PayoutEwallets
     */
    'ewallet_id'?: string;
    /**
     * The percentage that is paid to the wallet out of the total payment. Read-only.
     * @type {number}
     * @memberof PayoutEwallets
     */
    'percent'?: number;
}
/**
 * 
 * @export
 * @interface PayoutFees
 */
export interface PayoutFees {
    /**
     * 
     * @type {FxFee}
     * @memberof PayoutFees
     */
    'fx_fee'?: FxFee;
    /**
     * The total gross fees for the transaction, in units defined by currency_code. Relevant to responses.
     * @type {number}
     * @memberof PayoutFees
     */
    'gross_fees'?: number;
    /**
     * The total net fees for the transaction, in units defined by merchant_requested_currency. Relevant to responses.
     * @type {number}
     * @memberof PayoutFees
     */
    'net_fees'?: number;
    /**
     * 
     * @type {TransactionFee}
     * @memberof PayoutFees
     */
    'transaction_fee'?: TransactionFee;
}
/**
 * 
 * @export
 * @interface PayoutInstructions
 */
export interface PayoutInstructions {
    /**
     * 
     * @type {string}
     * @memberof PayoutInstructions
     */
    'name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof PayoutInstructions
     */
    'steps'?: Array<object>;
}
/**
 * 
 * @export
 * @interface PayoutMethodType
 */
export interface PayoutMethodType {
    /**
     * An array of objects that describe limits on the amount, per currency. Contains the following fields: maximum_amount - Maximum amount supported by this payout method for the indicated currency. Decimal number. minimum_amount - Minimum amount supported by this payout method for the indicated currency. Decimal number. * payout_currency - Currency of the payout. Three-letter ISO 4217 code. Uppercase.
     * @type {Array<Array<PayoutAmountRangePerCurrencyInner>>}
     * @memberof PayoutMethodType
     */
    'amount_range_per_currency'?: Array<Array<PayoutAmountRangePerCurrencyInner>>;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutMethodType
     */
    'beneficiary_country'?: string;
    /**
     * A list of the beneficiary entity types supported by this payout method. One or more of the following: company individual Response only.
     * @type {Array<EntityType>}
     * @memberof PayoutMethodType
     */
    'beneficiary_entity_types'?: Array<EntityType>;
    /**
     * 
     * @type {Category}
     * @memberof PayoutMethodType
     */
    'category'?: Category;
    /**
     * URL of an image that the merchant can use to represent the payout method.
     * @type {string}
     * @memberof PayoutMethodType
     */
    'image'?: string;
    /**
     * Indicates whether the payout can be canceled. Relevant when category is cash. One of the following values 0 - Not cancelable. 1 - cancelable.\'
     * @type {number}
     * @memberof PayoutMethodType
     */
    'is_cancelable'?: number;
    /**
     * Indicates whether the payout expires if not completed. Relevant when category is cash. One of the following values 0 - Not expirable. 1 - expirable.\'
     * @type {number}
     * @memberof PayoutMethodType
     */
    'is_expirable'?: number;
    /**
     * Indicates whether the payout must be made at a specific physical location. Relevant when category is cash. One of the following values 0 - Not locationspecific. 1 - location specific.\'
     * @type {number}
     * @memberof PayoutMethodType
     */
    'is_location_specific'?: number;
    /**
     * The maximum time (in seconds) that the merchant can set for completing the payout. Relevant when is_expirable is true.
     * @type {number}
     * @memberof PayoutMethodType
     */
    'maximum_expiration_seconds'?: number;
    /**
     * The minimum time (in seconds) that the merchant can set for completing the payout. Relevant when is_expirable is true.
     * @type {number}
     * @memberof PayoutMethodType
     */
    'minimum_expiration_seconds'?: number;
    /**
     * Payout method name.
     * @type {string}
     * @memberof PayoutMethodType
     */
    'name'?: string;
    /**
     * A list of the currencies supported by this payout method. Three-letter ISO 4217 code. Uppercase. Response only.
     * @type {Array<string>}
     * @memberof PayoutMethodType
     */
    'payout_currencies'?: Array<string>;
    /**
     * The type of payout method. The two-letter prefix must match the beneficiary country code. Required when default_payout_method_type is not used.
     * @type {string}
     * @memberof PayoutMethodType
     */
    'payout_method_type'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutMethodType
     */
    'sender_country'?: string;
    /**
     * List of currencies that the sender is paying with. Currency consists of a three-letter ISO 4217 code. Response only.
     * @type {Array<string>}
     * @memberof PayoutMethodType
     */
    'sender_currencies'?: Array<string>;
    /**
     * A list of the sender entity types supported by this payout method. One or more of the following: company individual Response only. 
     * @type {Array<EntityType>}
     * @memberof PayoutMethodType
     */
    'sender_entity_types'?: Array<EntityType>;
    /**
     * The estimated time period in which the beneficiary will receive the funds.
     * @type {string}
     * @memberof PayoutMethodType
     */
    'estimated_time_of_arrival'?: string;
    /**
     * Indicates whether the payout method is currently available. One of the following values: 0 - Not available. 1 - Available.
     * @type {number}
     * @memberof PayoutMethodType
     */
    'status'?: number;
}


/**
 * 
 * @export
 * @interface PayoutMethodTypeDetails
 */
export interface PayoutMethodTypeDetails {
    /**
     * concatenation of all fields.
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'batch_file_header'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'beneficiary_country'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof PayoutMethodTypeDetails
     */
    'beneficiary_entity_type'?: EntityType;
    /**
     * Lists all the beneficiary required fields for payout method
     * @type {Array<PayoutRequiredFields>}
     * @memberof PayoutMethodTypeDetails
     */
    'beneficiary_required_fields'?: Array<PayoutRequiredFields>;
    /**
     * URL of an image that the merchant can use to represent the payout method.
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'image'?: string;
    /**
     * Indicates whether the payout can be canceled. Relevant when category is cash. One of the following values 0 - Not cancelable. 1 - cancelable.\'
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'is_cancelable'?: number;
    /**
     * Indicates whether the payout expires if not completed. Relevant when category is cash. One of the following values 0 - Not expirable. 1 - expirable.\'
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'is_expirable'?: number;
    /**
     * Indicates whether the payout must be made at a specific physical location. Relevant when category is cash. One of the following values 0 - Not location specific. 1 - location specific.\'
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'is_location_specific'?: number;
    /**
     * Indicates whether the payout is made automatically, without any action by the beneficiary.
     * @type {boolean}
     * @memberof PayoutMethodTypeDetails
     */
    'is_online'?: boolean;
    /**
     * Maximum amount supported by this payout method for the indicated currency. Decimal number.
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'maximum_amount'?: number;
    /**
     * The maximum time (in seconds) that the merchant can set for completing the payout. Relevant when is_expirable is true.
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'maximum_expiration_seconds'?: number;
    /**
     * Minimum amount supported by this payout method for the indicated currency. Decimal number.
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'minimum_amount'?: number;
    /**
     * The minimum time (in seconds) that the merchant can set for completing the payout. Relevant when is_expirable is true.
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'minimum_expiration_seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'payout_currency'?: string;
    /**
     * The type of payout method. The two-letter prefix must match the beneficiary country code. Required when default_payout_method_type is not used.
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'payout_method_type'?: string;
    /**
     * Lists all the payout options for payout method.
     * @type {Array<PayoutRequiredFields>}
     * @memberof PayoutMethodTypeDetails
     */
    'payout_options'?: Array<PayoutRequiredFields>;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'sender_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutMethodTypeDetails
     */
    'sender_currency'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof PayoutMethodTypeDetails
     */
    'sender_entity_type'?: EntityType;
    /**
     * Lists all the sender required fields for payout method
     * @type {Array<PayoutRequiredFields>}
     * @memberof PayoutMethodTypeDetails
     */
    'sender_required_fields'?: Array<PayoutRequiredFields>;
    /**
     * Indicates whether the payout method is currently available. One of the following values: 0 - Not available. 1 - Available.
     * @type {number}
     * @memberof PayoutMethodTypeDetails
     */
    'status'?: number;
}


/**
 * 
 * @export
 * @interface PayoutRequest
 */
export interface PayoutRequest {
    /**
     * 
     * @type {PayoutRequestBeneficiary}
     * @memberof PayoutRequest
     */
    'beneficiary'?: PayoutRequestBeneficiary;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof PayoutRequest
     */
    'beneficiary_country'?: string;
    /**
     * Type of entity for the beneficiary. One of the following: individual, company
     * @type {string}
     * @memberof PayoutRequest
     */
    'beneficiary_entity_type'?: PayoutRequestBeneficiaryEntityTypeEnum;
    /**
     * Determines whether completion of the payout requires confirmation of the FX rate. Relevant to payouts with foreign exchange. Default is false.
     * @type {boolean}
     * @memberof PayoutRequest
     */
    'confirm_automatically'?: boolean;
    /**
     * conversion rate
     * @type {number}
     * @memberof PayoutRequest
     */
    'converstion_rate'?: number;
    /**
     * Description of the payout transaction.
     * @type {string}
     * @memberof PayoutRequest
     */
    'description'?: string;
    /**
     * ID of the wallet that the money is transferred from. String starting with ewallet_.
     * @type {string}
     * @memberof PayoutRequest
     */
    'ewallet'?: string;
    /**
     * Determines the day the payout expires, in Unix time. The payout must be completed before the start of this day. Relevant to cash payouts.
     * @type {string}
     * @memberof PayoutRequest
     */
    'expiration'?: string;
    /**
     * Location of the payout transaction.
     * @type {string}
     * @memberof PayoutRequest
     */
    'location'?: string;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof PayoutRequest
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PayoutRequest
     */
    'metadata'?: object;
    /**
     * Amount of the payout, in units of the currency defined in payout_currency. Mandatory when sender_amount is not used. Decimal.
     * @type {number}
     * @memberof PayoutRequest
     */
    'payout_amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof PayoutRequest
     */
    'payout_currency'?: string;
    /**
     * The type of payout method. The two-letter prefix must match the beneficiary country code. Required when the beneficiary does not have a default payout method type.
     * @type {string}
     * @memberof PayoutRequest
     */
    'payout_method_type'?: string;
    /**
     * Payout options
     * @type {object}
     * @memberof PayoutRequest
     */
    'payout_options'?: object;
    /**
     * 
     * @type {PayoutRequestSender}
     * @memberof PayoutRequest
     */
    'sender'?: PayoutRequestSender;
    /**
     * 
     * @type {string}
     * @memberof PayoutRequest
     */
    'sender_country'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof PayoutRequest
     */
    'sender_currency'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof PayoutRequest
     */
    'sender_entity_type'?: EntityType;
    /**
     * A statement that includes the reason for the payout. Limited to 35 characters.
     * @type {string}
     * @memberof PayoutRequest
     */
    'statement_descriptor'?: string;
}

export const PayoutRequestBeneficiaryEntityTypeEnum = {
    Individual: 'individual',
    Company: 'company'
} as const;

export type PayoutRequestBeneficiaryEntityTypeEnum = typeof PayoutRequestBeneficiaryEntityTypeEnum[keyof typeof PayoutRequestBeneficiaryEntityTypeEnum];

/**
 * @type PayoutRequestBeneficiary
 * String starting with beneficiary_ or the object describing the beneficiary.
 * @export
 */
export type PayoutRequestBeneficiary = Beneficiary | string;

/**
 * @type PayoutRequestSender
 * String starting with sender_ or the object describing the sender.
 * @export
 */
export type PayoutRequestSender = Sender | string;

/**
 * 
 * @export
 * @interface PayoutRequiredFields
 */
export interface PayoutRequiredFields {
    /**
     * List out the allowed values
     * @type {string}
     * @memberof PayoutRequiredFields
     */
    'allowed_values'?: string;
    /**
     * Description of the field
     * @type {string}
     * @memberof PayoutRequiredFields
     */
    'description'?: string;
    /**
     * Indicates whether the field is always required for using the payout method
     * @type {boolean}
     * @memberof PayoutRequiredFields
     */
    'is_required'?: boolean;
    /**
     * Name of the field
     * @type {string}
     * @memberof PayoutRequiredFields
     */
    'name'?: string;
    /**
     * A regular expression that defines the format when type is string. Note: Rapyd uses a unique variant of the regex standard. See note in           \"https://docs.rapyd.net/en/get-payment-method-required-fields.html\" 
     * @type {string}
     * @memberof PayoutRequiredFields
     */
    'regex'?: string;
    /**
     * Indicates transfer type of the payout
     * @type {string}
     * @memberof PayoutRequiredFields
     */
    'transfer_type'?: string;
    /**
     * Indicates datatype of the field
     * @type {string}
     * @memberof PayoutRequiredFields
     */
    'type'?: PayoutRequiredFieldsTypeEnum;
}

export const PayoutRequiredFieldsTypeEnum = {
    Boolean: 'boolean',
    Number: 'number',
    String: 'string'
} as const;

export type PayoutRequiredFieldsTypeEnum = typeof PayoutRequiredFieldsTypeEnum[keyof typeof PayoutRequiredFieldsTypeEnum];

/**
 * 
 * @export
 * @interface PayoutReturned
 */
export interface PayoutReturned {
    /**
     * Amount of the payout, in units defined by payout_currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. Same as payout_amount. Response only.
     * @type {number}
     * @memberof PayoutReturned
     */
    'amount'?: number;
    /**
     * 
     * @type {Beneficiary}
     * @memberof PayoutReturned
     */
    'beneficiary'?: Beneficiary;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutReturned
     */
    'beneficiary_country'?: string;
    /**
     * Time of creation of the payout, in Unix time. Response only.
     * @type {number}
     * @memberof PayoutReturned
     */
    'created_at'?: number;
    /**
     * Description of the payout transaction.
     * @type {string}
     * @memberof PayoutReturned
     */
    'description'?: string;
    /**
     * Indicates the error code of the last unsuccessful operation on the Payout object.
     * @type {string}
     * @memberof PayoutReturned
     */
    'error'?: string | null;
    /**
     * The estimated time period in which the beneficiary will receive the funds.
     * @type {string}
     * @memberof PayoutReturned
     */
    'estimated_time_of_arrival'?: string;
    /**
     * An array of one object, which contains the following fields: * ewallet_id - The ID of the wallet that the money is transferred from, a string starting with **ewallet_**. * amount - Amount of the transaction in currency units defined in currency. * percent - A decimal number representing a percentage of the total payout. Response only.
     * @type {Array<PayoutEwallets>}
     * @memberof PayoutReturned
     */
    'ewallets'?: Array<PayoutEwallets>;
    /**
     * Determines the day the payout expires, in Unix time. The payout must be completed before the start of this day. Relevant to cash payout methods where the is_expirable field is true in the response to List Payout Method Types.
     * @type {number}
     * @memberof PayoutReturned
     */
    'expiration'?: number | null;
    /**
     * Currency conversion rate for the payout. Decimal. Response only.
     * @type {number}
     * @memberof PayoutReturned
     */
    'fx_rate'?: number;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof PayoutReturned
     */
    'gc_error_code'?: string | null;
    /**
     * ID of the payout. String starting with **payout_**.
     * @type {string}
     * @memberof PayoutReturned
     */
    'id'?: string;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof PayoutReturned
     */
    'identifier_type'?: string | null;
    /**
     * Reserved. Response only.
     * @type {string}
     * @memberof PayoutReturned
     */
    'identifier_value'?: string | null;
    /**
     * Describes how the customer collects the payout. Contains the following fields: * name - Short description of the instructions. * steps - A \'steps\' object containing a list of steps for the customer to take. Each step is named stepN, where N is an integer. 
     * @type {Array<PayoutInstructions>}
     * @memberof PayoutReturned
     */
    'instructions'?: Array<PayoutInstructions>;
    /**
     * Additional information from the merchant. For example, the merchant\'s instructions and transaction number that must be presented for collecting the payout.
     * @type {object}
     * @memberof PayoutReturned
     */
    'instructions_value'?: object;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof PayoutReturned
     */
    'merchant_reference_id'?: string | null;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PayoutReturned
     */
    'metadata'?: object;
    /**
     * Cumulative amount received by the beneficiary, in units defined by payout_currency. Response only.
     * @type {number}
     * @memberof PayoutReturned
     */
    'paid_amount'?: number;
    /**
     * Time of the payout, in Unix time. Response only.
     * @type {string}
     * @memberof PayoutReturned
     */
    'paid_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayoutReturned
     */
    'payout_currency'?: string;
    /**
     * 
     * @type {PayoutFees}
     * @memberof PayoutReturned
     */
    'payout_fees'?: PayoutFees | null;
    /**
     * The type of payout method. The two-letter prefix must match the beneficiary country computed.
     * @type {string}
     * @memberof PayoutReturned
     */
    'payout_method_type'?: string;
    /**
     * The type of the payout method.
     * @type {string}
     * @memberof PayoutReturned
     */
    'payout_type'?: PayoutReturnedPayoutTypeEnum;
    /**
     * 
     * @type {Sender}
     * @memberof PayoutReturned
     */
    'sender'?: Sender;
    /**
     * Amount that the sender is paying in units of the currency defined in sender_currency.  This amount remains the same regardless of FX fees. Required when payout_amount is not used. Decimal. 
     * @type {number}
     * @memberof PayoutReturned
     */
    'sender_amount'?: number;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutReturned
     */
    'sender_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutReturned
     */
    'sender_currency'?: string;
    /**
     * A statement that includes the reason for the payout. Limited to 35 characters.
     * @type {string}
     * @memberof PayoutReturned
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {PayoutReturnedStatus}
     * @memberof PayoutReturned
     */
    'status'?: PayoutReturnedStatus;
}

export const PayoutReturnedPayoutTypeEnum = {
    Card: 'card',
    Cash: 'cash',
    Ewallet: 'ewallet',
    Bank: 'bank',
    RapydEwallet: 'rapyd_ewallet'
} as const;

export type PayoutReturnedPayoutTypeEnum = typeof PayoutReturnedPayoutTypeEnum[keyof typeof PayoutReturnedPayoutTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutReturnedStatus = {
    Returned: 'Returned',
    Created: 'Created',
    Completed: 'Completed',
    Canceled: 'Canceled',
    Rejected: 'Rejected',
    Error: 'Error',
    Confirmation: 'Confirmation',
    Expired: 'Expired'
} as const;

export type PayoutReturnedStatus = typeof PayoutReturnedStatus[keyof typeof PayoutReturnedStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Created: 'Created',
    Completed: 'Completed',
    Canceled: 'Canceled',
    Rejected: 'Rejected',
    Error: 'Error',
    Confirmation: 'Confirmation',
    Expired: 'Expired',
    Returned: 'Returned'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * 
 * @export
 * @interface PayoutsBeneficiaryBody
 */
export interface PayoutsBeneficiaryBody {
    /**
     * 
     * @type {Category}
     * @memberof PayoutsBeneficiaryBody
     */
    'category': Category;
    /**
     * Name of the beneficiary company. Relevant when `entity_type` is company.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'company_name'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'currency': string;
    /**
     * The type of payout method for the beneficiary. The two-letter prefix must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'default_payout_method_type'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof PayoutsBeneficiaryBody
     */
    'entity_type': EntityType;
    /**
     * First name of the beneficiary. Relevant when `entity_type` is individual.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'first_name'?: string;
    /**
     * Type of identification document for the beneficiary.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'identification_type'?: string;
    /**
     * Identification number on the document mentioned in `identification_type`.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'identification_value'?: string;
    /**
     * Family name of the beneficiary. Relevant when `entity_type` is individual.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'last_name'?: string;
    /**
     * ID defined by the client.
     * @type {string}
     * @memberof PayoutsBeneficiaryBody
     */
    'merchant_reference_id'?: string;
}


/**
 * 
 * @export
 * @interface PayoutsExtendedBeneficiaryBody
 */
export interface PayoutsExtendedBeneficiaryBody {
    /**
     * Beneficiary\'s street address including the build number.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'address': string;
    /**
     * City of the beneficiary.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'city': string;
    /**
     * 
     * @type {Category}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'category': Category;
    /**
     * Name of the beneficiary company. Required when `entity_type` is **company**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'company_name'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'country': string;
    /**
     * The country where the company was registered. Two-letter ISO 3166-1 ALPHA-2 code. Required when `entity_type` is **company**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'country_of_incorporation'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'currency': string;
    /**
     * Date of birth of the individual. Format: DD/MM/YYYY. Required when `entity_type` is **individual**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'date_of_birth'?: string;
    /**
     * The date when the company was registered. Format: DD/MM/YYYY. Required when `entity_type` is **company**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'date_of_incorporation'?: string;
    /**
     * The type of payout method for the beneficiary. The two-letter prefix must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'default_payout_method_type'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'entity_type': EntityType;
    /**
     * First name of the beneficiary. Required when `entity_type` is **individual**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'first_name'?: string;
    /**
     * 
     * @type {Gender}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'gender'?: Gender;
    /**
     * Type of identification document for the beneficiary. When `entity_type` is **company**, this field must be**company_registered_number**. When `entity_type` is **individual**:
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'identification_type': PayoutsExtendedBeneficiaryBodyIdentificationTypeEnum;
    /**
     * Identification number on the document mentioned in `identification_type`.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'identification_value': string;
    /**
     * Family name of the beneficiary. Required when `entity_type` is **individual**. Required when `entity_type` is **individual**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'last_name'?: string;
    /**
     * ID defined by the client.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'merchant_reference_id'?: string;
    /**
     * The citizenship of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code for the country. To determine the code for a country, see \'List Countries\'. Required when `entity_type` is **individual**.
     * @type {string}
     * @memberof PayoutsExtendedBeneficiaryBody
     */
    'nationality'?: string;
}

export const PayoutsExtendedBeneficiaryBodyIdentificationTypeEnum = {
    DriversLicense: 'drivers_license',
    IdentificationId: 'identification_id',
    InternationalPassport: 'international_passport',
    ResidencePermit: 'residence_permit',
    SocialSecurity: 'social_security',
    WorkPermit: 'work_permit'
} as const;

export type PayoutsExtendedBeneficiaryBodyIdentificationTypeEnum = typeof PayoutsExtendedBeneficiaryBodyIdentificationTypeEnum[keyof typeof PayoutsExtendedBeneficiaryBodyIdentificationTypeEnum];

/**
 * 
 * @export
 * @interface PayoutsPayoutIdBody
 */
export interface PayoutsPayoutIdBody {
    /**
     * Description of the payout.
     * @type {string}
     * @memberof PayoutsPayoutIdBody
     */
    'description'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PayoutsPayoutIdBody
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface PayoutsSenderBody
 */
export interface PayoutsSenderBody {
    /**
     * Name of the sender company. Relevant when `entity_type` is **company**.
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'company_name'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'currency': string;
    /**
     * 
     * @type {EntityType}
     * @memberof PayoutsSenderBody
     */
    'entity_type': EntityType;
    /**
     * First name of the sebder. Relevant when entity_type is individual.
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'first_name'?: string;
    /**
     * Type of identification document for the sender.
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'identification_type'?: string;
    /**
     * Identification number on the document mentioned in identification_type.
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'identification_value'?: string;
    /**
     * Last name of the sender. Relevant when `entity_type` is **individual**.
     * @type {string}
     * @memberof PayoutsSenderBody
     */
    'last_name'?: string;
}


/**
 * Describes the pricing structure for the invoice item. For details of the fields in the `plan` object, see \'Create Plan\'.
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * Indicates whether the plan is available to be added to a subscription.
     * @type {boolean}
     * @memberof Plan
     */
    'active'?: boolean;
    /**
     * Determines which quantity is used to calculate the pricing. One of the following:  * max - The maximum reported usage within the billing cycle.  * sum - The sum of all usage during a billing cycle. This is the default.  * last_during_period - The last usage reported within the billing cycle.  * last_ever - The last usage ever reported, if the latest billing cycles contain no usage at all. Required when usage_type is metered. Relevant when billing_scheme is set to per_unit. 
     * @type {string}
     * @memberof Plan
     */
    'aggregate_usage'?: PlanAggregateUsageEnum;
    /**
     * The amount to charge, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal. For a free service, use 0. Must be null when tiers is set. Relevant when `billing_scheme` is set to **per_unit**.
     * @type {number}
     * @memberof Plan
     */
    'amount'?: number;
    /**
     * Describes how to compute the price. One of the following:  * per_unit - The amount specified in amount is charged for each unit. Also set these related fields: amount, transform_usage, usage_type, aggregate_usage. This is the default.  * tiered - The unit pricing is computed using a tiering strategy as defined with the tiers and tiers_mode fields. 
     * @type {string}
     * @memberof Plan
     */
    'billing_scheme'?: PlanBillingSchemeEnum;
    /**
     * Time the \'plan\' object was created, in Unix time. Response only.
     * @type {number}
     * @memberof Plan
     */
    'created_at'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Plan
     */
    'currency'?: string;
    /**
     * Unique ID for this plan. English alphanumeric characters with no special characters except underscore. If the client does not define an ID, Rapyd generates a string starting with **plan_**.
     * @type {string}
     * @memberof Plan
     */
    'id'?: string;
    /**
     * Specifies the units used in defining the billing cycle. One of the following:  * day  * week  * month  * year Maximum interval is 1 year.  
     * @type {string}
     * @memberof Plan
     */
    'interval'?: PlanIntervalEnum;
    /**
     * Number of time intervals in the billing cycle. Integer
     * @type {number}
     * @memberof Plan
     */
    'interval_count'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Plan
     */
    'metadata'?: object;
    /**
     * Brief description of the plan.
     * @type {string}
     * @memberof Plan
     */
    'nickname'?: string;
    /**
     * 
     * @type {PlanProduct}
     * @memberof Plan
     */
    'product'?: PlanProduct | null;
    /**
     * Defines a tiered pricing structure. Each tier object represents a pricing tier.
     * @type {Array<PlanTiers>}
     * @memberof Plan
     */
    'tiers'?: Array<PlanTiers>;
    /**
     * Determines the mode for calculating the total tiered charge. One of the following values:  * graduated - The total cost at each price tier is calculated separately, then all tier charges are added together.  * volume - The total cost is calculated as the number of items times the applicable tier price. Relevant when billing_scheme is set to tiered 
     * @type {string}
     * @memberof Plan
     */
    'tiers_mode'?: PlanTiersModeEnum;
    /**
     * 
     * @type {PlanTransformUsage}
     * @memberof Plan
     */
    'transform_usage'?: PlanTransformUsage;
    /**
     * Specifies the number of days before charges begin to accrue. Use this parameter to define a free trial period for a service.
     * @type {number}
     * @memberof Plan
     */
    'trial_period_days'?: number;
    /**
     * Determines whether the customer is billed when the service is not actually used. Relevant when billing_scheme is set to per_unit. One of the following:  * metered - The customer is billed only for actual usage. You must also set aggregate_usage.  * licensed - The customer is billed even if the service is not used. This is the default. 
     * @type {string}
     * @memberof Plan
     */
    'usage_type'?: PlanUsageTypeEnum;
}

export const PlanAggregateUsageEnum = {
    Max: 'max',
    Sum: 'sum',
    LastDuringPeriod: 'last_during_period',
    LastEver: 'last_ever'
} as const;

export type PlanAggregateUsageEnum = typeof PlanAggregateUsageEnum[keyof typeof PlanAggregateUsageEnum];
export const PlanBillingSchemeEnum = {
    PerUnit: 'per_unit',
    Tiered: 'tiered'
} as const;

export type PlanBillingSchemeEnum = typeof PlanBillingSchemeEnum[keyof typeof PlanBillingSchemeEnum];
export const PlanIntervalEnum = {
    Month: 'month',
    Day: 'day',
    Week: 'week',
    Year: 'year'
} as const;

export type PlanIntervalEnum = typeof PlanIntervalEnum[keyof typeof PlanIntervalEnum];
export const PlanTiersModeEnum = {
    Graduated: 'graduated',
    Volume: 'volume'
} as const;

export type PlanTiersModeEnum = typeof PlanTiersModeEnum[keyof typeof PlanTiersModeEnum];
export const PlanUsageTypeEnum = {
    Metered: 'metered',
    Licensed: 'licensed'
} as const;

export type PlanUsageTypeEnum = typeof PlanUsageTypeEnum[keyof typeof PlanUsageTypeEnum];

/**
 * 
 * @export
 * @interface PlanObject
 */
export interface PlanObject {
    /**
     * Determines which quantity is used to calculate the pricing. One of the following:  * max - The maximum reported usage within the billing cycle.  * sum - The sum of all usage during a billing cycle. This is the default.  * last_during_period - The last usage reported within the billing cycle.  * last_ever - The last usage ever reported, if the latest billing cycles contain no usage at all. Required when usage_type is metered. Relevant when billing_scheme is set to per_unit. 
     * @type {string}
     * @memberof PlanObject
     */
    'aggregate_usage'?: PlanObjectAggregateUsageEnum;
    /**
     * The amount to charge, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal. For a free service, use 0. Must be null when tiers is set. Relevant when billing_scheme is set to per_unit.
     * @type {number}
     * @memberof PlanObject
     */
    'amount'?: number;
    /**
     * Describes how to compute the price. One of the following:  * per_unit - The amount specified in amount is charged for each unit. Also set these related fields: amount, transform_usage, usage_type, aggregate_usage. This is the default.  * tiered - The unit pricing is computed using a tiering strategy as defined with the tiers and tiers_mode fields. 
     * @type {string}
     * @memberof PlanObject
     */
    'billing_scheme'?: string;
    /**
     * Time the \'plan\' object was created, in Unix time. Response only.
     * @type {number}
     * @memberof PlanObject
     */
    'created_at'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof PlanObject
     */
    'currency'?: string;
    /**
     * Unique ID for this plan. English alphanumeric characters with no special characters except underscore. If the client does not define an ID, Rapyd generates a string starting with plan_.
     * @type {string}
     * @memberof PlanObject
     */
    'id'?: string;
    /**
     * Specifies the units used in defining the billing cycle. One of the following:  * day  * week  * month  * year Maximum interval is 1 year.  
     * @type {string}
     * @memberof PlanObject
     */
    'interval'?: PlanObjectIntervalEnum;
    /**
     * Number of time intervals in the billing cycle. Integer
     * @type {number}
     * @memberof PlanObject
     */
    'interval_count'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PlanObject
     */
    'metadata'?: object;
    /**
     * Brief description of the plan.
     * @type {string}
     * @memberof PlanObject
     */
    'nickname'?: string;
    /**
     * 
     * @type {PlanObjectProduct}
     * @memberof PlanObject
     */
    'product'?: PlanObjectProduct;
    /**
     * Defines a tiered pricing structure. Each tier object represents a pricing tier.
     * @type {Array<PlanObjectTiers>}
     * @memberof PlanObject
     */
    'tiers'?: Array<PlanObjectTiers>;
    /**
     * Determines the mode for calculating the total tiered charge. One of the following values:  * graduated - The total cost at each price tier is calculated separately, then all tier charges are added together.  * volume - The total cost is calculated as the number of items times the applicable tier price. Relevant when billing_scheme is set to tiered 
     * @type {string}
     * @memberof PlanObject
     */
    'tiers_mode'?: PlanObjectTiersModeEnum;
    /**
     * 
     * @type {PlanTransformUsage}
     * @memberof PlanObject
     */
    'transform_usage'?: PlanTransformUsage;
    /**
     * Specifies the number of days before charges begin to accrue. Use this parameter to define a free trial period for a service.
     * @type {number}
     * @memberof PlanObject
     */
    'trial_period_days'?: number;
    /**
     * Determines whether the customer is billed when the service is not actually used. Relevant when billing_scheme is set to per_unit. One of the following:  * metered - The customer is billed only for actual usage. You must also set aggregate_usage.  * licensed - The customer is billed even if the service is not used. This is the default. 
     * @type {string}
     * @memberof PlanObject
     */
    'usage_type'?: PlanObjectUsageTypeEnum;
}

export const PlanObjectAggregateUsageEnum = {
    Max: 'max',
    Sum: 'sum',
    LastDuringPeriod: 'last_during_period',
    LastEver: 'last_ever'
} as const;

export type PlanObjectAggregateUsageEnum = typeof PlanObjectAggregateUsageEnum[keyof typeof PlanObjectAggregateUsageEnum];
export const PlanObjectIntervalEnum = {
    Month: 'month',
    Day: 'day',
    Week: 'week',
    Year: 'year'
} as const;

export type PlanObjectIntervalEnum = typeof PlanObjectIntervalEnum[keyof typeof PlanObjectIntervalEnum];
export const PlanObjectTiersModeEnum = {
    Graduated: 'graduated',
    Volume: 'volume'
} as const;

export type PlanObjectTiersModeEnum = typeof PlanObjectTiersModeEnum[keyof typeof PlanObjectTiersModeEnum];
export const PlanObjectUsageTypeEnum = {
    Metered: 'metered',
    Licensed: 'licensed'
} as const;

export type PlanObjectUsageTypeEnum = typeof PlanObjectUsageTypeEnum[keyof typeof PlanObjectUsageTypeEnum];

/**
 * @type PlanObjectProduct
 * The ID of the product that this plan is for, and fields describing this product in the plan.
 * @export
 */
export type PlanObjectProduct = Product | string;

/**
 * 
 * @export
 * @interface PlanObjectTiers
 */
export interface PlanObjectTiers {
    /**
     * The price for each item in this tier. Decimal number.
     * @type {number}
     * @memberof PlanObjectTiers
     */
    'amount'?: number;
    /**
     * Additional price for the entire tier. Default is 0.
     * @type {number}
     * @memberof PlanObjectTiers
     */
    'flat_amount'?: number;
    /**
     * 
     * @type {PlanObjectTiersUpTo}
     * @memberof PlanObjectTiers
     */
    'up_to'?: PlanObjectTiersUpTo;
}
/**
 * @type PlanObjectTiersUpTo
 * The upper volume limit for this tier. Valid values: inf (infinite) or an integer. 
 * @export
 */
export type PlanObjectTiersUpTo = number | string;

/**
 * @type PlanProduct
 * The ID of the product that this plan is for, and fields describing this product in the plan.
 * @export
 */
export type PlanProduct = Product | string;

/**
 * 
 * @export
 * @interface PlanTiers
 */
export interface PlanTiers {
    /**
     * The price for each item in this tier. Decimal number.
     * @type {number}
     * @memberof PlanTiers
     */
    'amount'?: number;
    /**
     * Additional price for the entire tier. Default is 0.
     * @type {number}
     * @memberof PlanTiers
     */
    'flat_amount'?: number;
    /**
     * 
     * @type {PlanTiersUpTo}
     * @memberof PlanTiers
     */
    'up_to'?: PlanTiersUpTo;
}
/**
 * @type PlanTiersUpTo
 * The upper volume limit for this tier. Valid values: inf (infinite) or an integer.
 * @export
 */
export type PlanTiersUpTo = number | string;

/**
 * Defines the transformation that is applied to the reported usage before the billed price is computed. The transformation divides the quantity by the divisor specified in divide_by, then rounds up or down according to the setting in round. Relevant when billing_scheme is set to per_unit.
 * @export
 * @interface PlanTransformUsage
 */
export interface PlanTransformUsage {
    /**
     * Indicates the divisor in the transformation calculation. Integer. Default is 1.
     * @type {number}
     * @memberof PlanTransformUsage
     */
    'divide_by'?: number;
    /**
     * Indicates whether the reported number of units should be rounded up or down to the next whole quantity specified in divide_by. String. Default is up.
     * @type {string}
     * @memberof PlanTransformUsage
     */
    'round'?: string;
}
/**
 * 
 * @export
 * @interface PlansPlanIdBody
 */
export interface PlansPlanIdBody {
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof PlansPlanIdBody
     */
    'metadata'?: object;
    /**
     * Brief description of the pricing plan.
     * @type {string}
     * @memberof PlansPlanIdBody
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Indicates whether the product is currently available for purchase.
     * @type {boolean}
     * @memberof Product
     */
    'active'?: boolean;
    /**
     * Up to 5 unique alphanumeric strings defined by the merchant. Cannot contain spaces. For example: [ > \"size\", > \"color\"] Each string defines the key in a key-value pair in the \'attributes\' object in the corresponding \'sku\' objects.
     * @type {Array<string>}
     * @memberof Product
     */
    'attributes'?: Array<string>;
    /**
     * Time of creation of this product, in Unix time. Response only.
     * @type {number}
     * @memberof Product
     */
    'created_at'?: number;
    /**
     * Full text description of the product.
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * Unique string for identification of the product. Legal input includes alphanumeric characters and the underscore () character. If the merchant does not define an ID, Rapyd generates it with a string that starts with **product**.
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * Images associated with the product.
     * @type {Array<string>}
     * @memberof Product
     */
    'images'?: Array<string>;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Product
     */
    'metadata'?: object;
    /**
     * The name of the product or service that appears in the line items in invoices.
     * @type {string}
     * @memberof Product
     */
    'name'?: string;
    /**
     * 
     * @type {ProductPackageDimensions}
     * @memberof Product
     */
    'package_dimensions'?: ProductPackageDimensions;
    /**
     * Indicates whether the product can be shipped.
     * @type {boolean}
     * @memberof Product
     */
    'shippable'?: boolean;
    /**
     * 
     * @type {Array<Sku>}
     * @memberof Product
     */
    'skus'?: Array<Sku>;
    /**
     * Description that is suitable for a customer\'s statement. Limited to 22 characters. Relevant when type is service. Must be null when type is goods.
     * @type {string}
     * @memberof Product
     */
    'statement_descriptor'?: string;
    /**
     * One of the following:  * services - Relevant to subscriptions and plans.  * goods - Relevant to orders and SKUs. 
     * @type {string}
     * @memberof Product
     */
    'type'?: ProductTypeEnum;
    /**
     * Determines what one unit of this product is called on customersâ€™ receipts and invoices, such as minutes, viewings, kilometers or packages. Relevant when type is service. Must be null when type is goods.
     * @type {string}
     * @memberof Product
     */
    'unit_label'?: string;
    /**
     * Time that this product was last updated, in Unix time. Response only.
     * @type {number}
     * @memberof Product
     */
    'updated_at'?: number;
}

export const ProductTypeEnum = {
    Goods: 'goods',
    Services: 'services'
} as const;

export type ProductTypeEnum = typeof ProductTypeEnum[keyof typeof ProductTypeEnum];

/**
 * Describes the physical size and weight of the product. Contains the following fields:  * height  * length  * weight  * width  These fields are represented as numbers, but it is the responsibility of the merchant to define and interpret the relevant units of length and weight. 
 * @export
 * @interface ProductPackageDimensions
 */
export interface ProductPackageDimensions {
    /**
     * NA
     * @type {number}
     * @memberof ProductPackageDimensions
     */
    'height'?: number;
    /**
     * NA
     * @type {number}
     * @memberof ProductPackageDimensions
     */
    'length'?: number;
    /**
     * NA
     * @type {number}
     * @memberof ProductPackageDimensions
     */
    'weight'?: number;
    /**
     * NA
     * @type {number}
     * @memberof ProductPackageDimensions
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface ProductsProductsIdBody
 */
export interface ProductsProductsIdBody {
    /**
     * Indicates whether the product is currently available for purchase. Default is true.
     * @type {boolean}
     * @memberof ProductsProductsIdBody
     */
    'active'?: boolean;
    /**
     * Array of up to 5 alphanumeric strings defined by the merchant. Each string defines the key in a key-value pair in the \'attributes\' object in the corresponding \'sku\' objects.
     * @type {Array<string>}
     * @memberof ProductsProductsIdBody
     */
    'attributes'?: Array<string>;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof ProductsProductsIdBody
     */
    'metadata'?: object;
    /**
     * The name of the product or service that is displayed to the customer.
     * @type {string}
     * @memberof ProductsProductsIdBody
     */
    'name': string;
    /**
     * 
     * @type {V1productsPackageDimensions}
     * @memberof ProductsProductsIdBody
     */
    'package_dimensions'?: V1productsPackageDimensions;
    /**
     * A text description that appears in the customer\'s invoice. Limited to 22 characters. Relevant when type is service.
     * @type {string}
     * @memberof ProductsProductsIdBody
     */
    'statement_descriptor'?: string;
    /**
     * A label that represents units of this product, such as seats, on customersâ€™
     * @type {string}
     * @memberof ProductsProductsIdBody
     */
    'unit_label'?: string;
}
/**
 * 
 * @export
 * @interface PutFundsOnHoldResponse
 */
export interface PutFundsOnHoldResponse {
    /**
     *  * **Transactions** - Amount of the transaction, in units of the currency defined in `currency`. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 4217:2015.<BR> * **Wallet Account Operations** - Amount of the account limit.
     * @type {number}
     * @memberof PutFundsOnHoldResponse
     */
    'amount'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the `amount` field.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'currency_code'?: string;
    /**
     * ID of the wallet owner\'s user. UUID.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'destination_account_id'?: string;
    /**
     * Balance type that the funds are transferred to. See \'Wallet Balance Types\'.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'destination_balance_type'?: PutFundsOnHoldResponseDestinationBalanceTypeEnum;
    /**
     * ID of the transaction with regard to the destination. String starting with **wt_**.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'destination_transaction_id'?: string;
    /**
     * ID of the wallet owner\'s user. UUID.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'destination_user_profile_id'?: string;
    /**
     * ID of the transaction. UUID.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'id'?: string;
    /**
     * Balance type that the funds are transferred from. See \'Wallet Balance Types\'. See \'Wallet Balance Types\'.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'source_balance_type'?: PutFundsOnHoldResponseSourceBalanceTypeEnum;
    /**
     * ID of the transaction with regard to the source. String starting with **wt_**.
     * @type {object}
     * @memberof PutFundsOnHoldResponse
     */
    'source_transaction_id'?: object;
    /**
     * ID of the wallet owner\'s user. UUID.
     * @type {string}
     * @memberof PutFundsOnHoldResponse
     */
    'source_user_profile_id'?: string;
}

export const PutFundsOnHoldResponseDestinationBalanceTypeEnum = {
    AvailableBalance: 'available_balance',
    OnHoldBalance: 'on_hold_balance',
    ReceivedBalance: 'received_balance',
    ReserveBalance: 'reserve_balance'
} as const;

export type PutFundsOnHoldResponseDestinationBalanceTypeEnum = typeof PutFundsOnHoldResponseDestinationBalanceTypeEnum[keyof typeof PutFundsOnHoldResponseDestinationBalanceTypeEnum];
export const PutFundsOnHoldResponseSourceBalanceTypeEnum = {
    AvailableBalance: 'available_balance',
    OnHoldBalance: 'on_hold_balance',
    ReceivedBalance: 'received_balance',
    ReserveBalance: 'reserve_balance'
} as const;

export type PutFundsOnHoldResponseSourceBalanceTypeEnum = typeof PutFundsOnHoldResponseSourceBalanceTypeEnum[keyof typeof PutFundsOnHoldResponseSourceBalanceTypeEnum];

/**
 * 
 * @export
 * @interface Refund
 */
export interface Refund {
    /**
     * Amount of the refund, in units defined by currency in the original payment. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {number}
     * @memberof Refund
     */
    'amount'?: number;
    /**
     * Time of creation of this refund, in Unix time. Response only.
     * @type {number}
     * @memberof Refund
     */
    'created_at'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Refund
     */
    'currency'?: string;
    /**
     * An array of one object, which contains the following fields: * ewallet_id - The ID of the wallet that the money is transferred from, a string starting with ewallet_. * amount - Amount of the transaction in currency units defined in currency. * percent - A decimal number representing a percentage of the total payout. Response only.
     * @type {Array<RefundEwallets>}
     * @memberof Refund
     */
    'ewallets'?: Array<RefundEwallets>;
    /**
     * Indicates the reason that the refund failed.
     * @type {string}
     * @memberof Refund
     */
    'failure_reason'?: string;
    /**
     * Indicates whether the FX rate is fixed for the buy side or for the sell side. Relevant for refunds with foreign exchange. Response only.
     * @type {string}
     * @memberof Refund
     */
    'fixed_side'?: string;
    /**
     * Exchange rate for the transaction. When fixed_side is buy, fx_rate is the buy rate. When fixed_side is sell, fx_rate is the sell rate. Decimal number as string. Relevant to refunds with foreign exchange. Response only.
     * @type {string}
     * @memberof Refund
     */
    'fx_rate'?: string;
    /**
     * ID of the Refund object. String starting with **refund_**.
     * @type {string}
     * @memberof Refund
     */
    'id'?: string;
    /**
     * Amount debited from the merchant. Relevant to refunds with foreign exchange. Response only.
     * @type {string}
     * @memberof Refund
     */
    'merchant_debited_amount'?: string;
    /**
     * Indicates the currency that is debited from the merchant. Three-letter ISO 4217 code. Relevant to refunds with foreign exchange. Response only.
     * @type {string}
     * @memberof Refund
     */
    'merchant_debited_currency'?: string;
    /**
     * Merchant-defined ID. Limited to 255 characters.
     * @type {string}
     * @memberof Refund
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Refund
     */
    'metadata'?: object;
    /**
     * D of the Payment object that the refund is credited against. String starting with payment_.
     * @type {string}
     * @memberof Refund
     */
    'payment'?: string;
    /**
     * Time that the original payment was created, in Unix time. Response only.
     * @type {number}
     * @memberof Refund
     */
    'payment_created_at'?: number;
    /**
     * The original payment payment method type. Use List Payment Methods by Country for a list of supported types for a country
     * @type {string}
     * @memberof Refund
     */
    'payment_method_type'?: string;
    /**
     * Indicates whether the refund was returned in proportion to the amounts received by the wallets in the payment. Relevant to a refund for a payment split among multiple wallets.
     * @type {boolean}
     * @memberof Refund
     */
    'proportional_refund'?: boolean;
    /**
     * Description of the reason for the refund, provided by the merchant.
     * @type {string}
     * @memberof Refund
     */
    'reason'?: string;
    /**
     * Number of the receipt for the refund, provided by the merchant. Response only.
     * @type {number}
     * @memberof Refund
     */
    'receipt_number'?: number;
    /**
     * Indicates the status of the refund operation
     * @type {string}
     * @memberof Refund
     */
    'status'?: string;
    /**
     * Time that this refund was last updated, in Unix time. Response only.
     * @type {number}
     * @memberof Refund
     */
    'updated_at'?: number;
}
/**
 * 
 * @export
 * @interface RefundEwallets
 */
export interface RefundEwallets {
    /**
     * The amount of the payment to the wallet, in units of the currency defined in currency. Decimal. If the total amount of the payment is not fully accounted for, the balance appears in the client wallet. Relevant when percentage is not set.
     * @type {number}
     * @memberof RefundEwallets
     */
    'amount'?: number;
    /**
     * ID of the wallet. String starting with **ewallet_**. Read-only.
     * @type {string}
     * @memberof RefundEwallets
     */
    'ewallet'?: string;
}
/**
 * 
 * @export
 * @interface RefundsCompleteBody
 */
export interface RefundsCompleteBody {
    /**
     * ID of the refund. String starting with **refund_**.
     * @type {string}
     * @memberof RefundsCompleteBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RefundsGroupPaymentsBody
 */
export interface RefundsGroupPaymentsBody {
    /**
     * The amount of the refund, in the currency of the group payment. Decimal. If this parameter is omitted, the entire group payment is refunded.
     * @type {number}
     * @memberof RefundsGroupPaymentsBody
     */
    'amount'?: number;
    /**
     * ID of the group payment that the refund is charged against. String starting with **gp_**.
     * @type {string}
     * @memberof RefundsGroupPaymentsBody
     */
    'group_payment': string;
}
/**
 * 
 * @export
 * @interface RefundsRefundIdBody
 */
export interface RefundsRefundIdBody {
    /**
     * A JSON object defined by the client.
     * @type {any}
     * @memberof RefundsRefundIdBody
     */
    'metadata'?: any;
}
/**
 * 
 * @export
 * @interface ResendWebhookResponse
 */
export interface ResendWebhookResponse {
    /**
     * 
     * @type {ListWebhooksResponseAttempts}
     * @memberof ResendWebhookResponse
     */
    'attempts'?: ListWebhooksResponseAttempts;
    /**
     * Timestamp for the creation of the webhook. Unix time.
     * @type {number}
     * @memberof ResendWebhookResponse
     */
    'created_at'?: number;
    /**
     * The data section of the webhook itself.
     * @type {object}
     * @memberof ResendWebhookResponse
     */
    'data'?: object;
    /**
     * Timestamp of the last attempt at sending the webhook. Unix time.
     * @type {number}
     * @memberof ResendWebhookResponse
     */
    'last_attempt_at'?: number;
    /**
     * Timestamp of the next attempt at sending the webhook. Unix time.
     * @type {number}
     * @memberof ResendWebhookResponse
     */
    'next_attempt_at'?: number;
    /**
     * Status of the webhook. One of the following: <BR> * **NEW** (new) - The webhook was created and has not yet been sent successfully. <BR> * **CLO** (closed) - The webhook was sent successfully.<BR> * **ERR** (error) - Attempts were made to send the webhook, but the maximum number of retries was reached. The automatic retry process failed. The webhook was not sent. <BR> * **RET** (retried) - The webhook was resent.
     * @type {string}
     * @memberof ResendWebhookResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Sender
 */
export interface Sender {
    /**
     * Bank account number of sender.
     * @type {string}
     * @memberof Sender
     */
    'account_number'?: string;
    /**
     * Additional data required by the payout method. Object..
     * @type {object}
     * @memberof Sender
     */
    'additional_data'?: object;
    /**
     * The person\'s second last name.
     * @type {string}
     * @memberof Sender
     */
    'additional_last_name'?: string;
    /**
     * The address of the sender.
     * @type {string}
     * @memberof Sender
     */
    'address'?: string;
    /**
     * Domestic identifier of the bank.
     * @type {string}
     * @memberof Sender
     */
    'bank_code'?: string;
    /**
     * Name of the bank.
     * @type {string}
     * @memberof Sender
     */
    'bank_name'?: string;
    /**
     * When the beneficiary is not a relative of the sender, the relationship should be specified as client or non-relative.
     * @type {string}
     * @memberof Sender
     */
    'beneficiary_relationship'?: string;
    /**
     * City where the sender is located.
     * @type {string}
     * @memberof Sender
     */
    'city'?: string;
    /**
     * Name of the sender company. Relevant when entity_type is company.
     * @type {string}
     * @memberof Sender
     */
    'company_name'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof Sender
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sender
     */
    'currency'?: string;
    /**
     * The date of birth of the sender. Relevant when entity_type is individual.
     * @type {string}
     * @memberof Sender
     */
    'date_of_birth'?: string;
    /**
     * Date of incorporation of the corporation.
     * @type {string}
     * @memberof Sender
     */
    'date_of_incorporation'?: string;
    /**
     * The person\'s email address.
     * @type {string}
     * @memberof Sender
     */
    'email'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof Sender
     */
    'entity_type'?: EntityType;
    /**
     * First name of the sender. Relevant when `entity_type` is **individual**.
     * @type {string}
     * @memberof Sender
     */
    'first_name'?: string;
    /**
     * ID of the Sender object. String starting with **sender_**. Response only.
     * @type {string}
     * @memberof Sender
     */
    'id'?: string;
    /**
     * The date of issuance of the person\'s identification document.
     * @type {string}
     * @memberof Sender
     */
    'id_date_of_issue'?: string;
    /**
     * The expiration date of the person\'s identification document.
     * @type {string}
     * @memberof Sender
     */
    'id_expiry'?: string;
    /**
     * The government agency that issued the person\'s identification document.
     * @type {string}
     * @memberof Sender
     */
    'id_issue_authority'?: string;
    /**
     * The location where the person\'s identification document was issued.
     * @type {string}
     * @memberof Sender
     */
    'id_issue_location'?: string;
    /**
     * Type of identification document for the sender. When entity_type is company, this field must be company_registered_number. When entity_type is individual, one of the following values:  * drivers_license  * identification_id  * international_passport  * residence_permit* social_security  * work_permit 
     * @type {string}
     * @memberof Sender
     */
    'identification_type'?: string;
    /**
     * identification number on the document mentioned in `identification_type`.
     * @type {string}
     * @memberof Sender
     */
    'identification_value'?: string;
    /**
     * Last name of the sender. Relevant when `entity_type` is individual.
     * @type {string}
     * @memberof Sender
     */
    'last_name'?: string;
    /**
     * ID defined by the merchant. Rapyd does not validate this value to enforce uniqueness.
     * @type {string}
     * @memberof Sender
     */
    'merchant_reference_id'?: string;
    /**
     * The person\'s middle name.
     * @type {string}
     * @memberof Sender
     */
    'middle_name'?: string;
    /**
     * Mobile phone number in E.164 format.
     * @type {string}
     * @memberof Sender
     */
    'mobile_number'?: string;
    /**
     * Name of the sender. Relevant when `entity_type` is company.
     * @type {string}
     * @memberof Sender
     */
    'name'?: string;
    /**
     * The person\'s nationality.
     * @type {string}
     * @memberof Sender
     */
    'nationality'?: string;
    /**
     * The person\'s occupation.
     * @type {string}
     * @memberof Sender
     */
    'occupation'?: string;
    /**
     * The country code of the person\'s phone.
     * @type {string}
     * @memberof Sender
     */
    'phone_country_code'?: string;
    /**
     * Phone number in E.164 format.
     * @type {string}
     * @memberof Sender
     */
    'phone_number'?: string;
    /**
     * Postal code of the sender.
     * @type {string}
     * @memberof Sender
     */
    'postcode'?: string;
    /**
     * Province portion of the address.
     * @type {string}
     * @memberof Sender
     */
    'province'?: string;
    /**
     * Reason for the payout.
     * @type {string}
     * @memberof Sender
     */
    'purpose_code'?: string;
    /**
     * The person\'s source of income.
     * @type {string}
     * @memberof Sender
     */
    'source_of_income'?: string;
    /**
     * State where the sender is located.
     * @type {string}
     * @memberof Sender
     */
    'state'?: string;
    /**
     * District of the sender\'s or beneficiary\'s city.
     * @type {string}
     * @memberof Sender
     */
    'suburb'?: string;
    /**
     * Tax identification number.
     * @type {string}
     * @memberof Sender
     */
    'tax_id'?: string;
}


/**
 * 
 * @export
 * @interface SetPINResponse
 */
export interface SetPINResponse {
    /**
     * Time that the card was activated, in Unix time.
     * @type {number}
     * @memberof SetPINResponse
     */
    'activated_at'?: number;
    /**
     * Time that the card was assigned to a cardholder, in Unix time.
     * @type {string}
     * @memberof SetPINResponse
     */
    'assigned_at'?: string;
    /**
     * Bank Identifier Number for the institution issuing the card.
     * @type {string}
     * @memberof SetPINResponse
     */
    'bin'?: string;
    /**
     * Reason for blocking the card.
     * @type {string}
     * @memberof SetPINResponse
     */
    'blocked_reason'?: SetPINResponseBlockedReasonEnum;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof SetPINResponse
     */
    'card_id'?: string;
    /**
     * ID of the card program that the card is issued from. String starting with **cardprog_**.
     * @type {string}
     * @memberof SetPINResponse
     */
    'card_program'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof SetPINResponse
     */
    'card_tracking_id'?: string;
    /**
     * The country where the card is issued. Two-letter ISO 3166-1 ALPHA-2 code.
     * @type {string}
     * @memberof SetPINResponse
     */
    'country_iso_alpha_2'?: string;
    /**
     * Time of creation of the issued card object, in Unix time.
     * @type {number}
     * @memberof SetPINResponse
     */
    'created_at'?: number;
    /**
     * Card security code. only.
     * @type {number}
     * @memberof SetPINResponse
     */
    'cvv'?: number;
    /**
     * Expiration month of the card. Two digits. Relevant when the card issuer supports it for the country. only.
     * @type {string}
     * @memberof SetPINResponse
     */
    'expiration_month'?: string;
    /**
     * Expiration year of the card. Two digits. Relevant when the card issuer supports it for the country.
     * @type {string}
     * @memberof SetPINResponse
     */
    'expiration_year'?: string;
    /**
     * Describes the wallet contact that the card is assigned to. String starting with **cont_**. For details about the fields of the \'contact\' object, see \'Add Contact to Wallet\'in online API reference.
     * @type {string}
     * @memberof SetPINResponse
     */
    'ewallet_contact'?: string;
    /**
     * ID of the issued card object. String starting with **ci_**.
     * @type {string}
     * @memberof SetPINResponse
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {string}
     * @memberof SetPINResponse
     */
    'metadata'?: string;
    /**
     * Status of the card. One of the following:<BR>* **ACT** - Active.<BR> * **BLO** - Blocked.<BR>* **IMP** - Imported in bulk, but not yet personalized.<BR>* **INA** - Inactive.<BR>
     * @type {string}
     * @memberof SetPINResponse
     */
    'status'?: SetPINResponseStatusEnum;
    /**
     * Two-digit code.
     * @type {string}
     * @memberof SetPINResponse
     */
    'sub_bin'?: string;
}

export const SetPINResponseBlockedReasonEnum = {
    BlockedReversible: 'blocked_reversible',
    Canceled: 'canceled',
    Compliance: 'compliance',
    LockedIncorrectPin: 'locked_incorrect_pin',
    Migrated: 'migrated',
    None: 'none',
    Other: 'other',
    Reissued: 'reissued',
    SuspectedFraud: 'suspected_fraud'
} as const;

export type SetPINResponseBlockedReasonEnum = typeof SetPINResponseBlockedReasonEnum[keyof typeof SetPINResponseBlockedReasonEnum];
export const SetPINResponseStatusEnum = {
    Act: 'ACT',
    Blo: 'BLO',
    Imp: 'IMP',
    Ina: 'INA'
} as const;

export type SetPINResponseStatusEnum = typeof SetPINResponseStatusEnum[keyof typeof SetPINResponseStatusEnum];

/**
 * 
 * @export
 * @interface SimulateBlockCardResponse
 */
export interface SimulateBlockCardResponse {
    /**
     * Time that the card was activated, in Unix time.
     * @type {number}
     * @memberof SimulateBlockCardResponse
     */
    'activated_at'?: number;
    /**
     * Time that the card was assigned to a cardholder, in Unix time.
     * @type {number}
     * @memberof SimulateBlockCardResponse
     */
    'assigned_at'?: number;
    /**
     * Reason for blocking the card.
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'blocked_reason'?: SimulateBlockCardResponseBlockedReasonEnum;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'card_id'?: string;
    /**
     * The country where the card is issued. Two-letter ISO 3166-1 ALPHA-2 code.
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'country_iso_alpha_2'?: string;
    /**
     * Time of creation of the issued card object, in Unix time. only.
     * @type {number}
     * @memberof SimulateBlockCardResponse
     */
    'created_at'?: number;
    /**
     * Describes the wallet contact that the card is assigned to. String starting with **cont_**. For details about the fields of the \'contact\' object, see \'Add Contact to Wallet\'.
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'ewallet_contact'?: string;
    /**
     * ID of the issued card object. String starting with **ci_**.
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'metadata'?: string;
    /**
     * Status of the card. One of the following:<BR>* **ACT** - Active.<BR> * **BLO** - Blocked.<BR>* **IMP** - Imported in bulk, but not yet personalized.<BR>* **INA** - Inactive.<BR>
     * @type {string}
     * @memberof SimulateBlockCardResponse
     */
    'status'?: SimulateBlockCardResponseStatusEnum;
}

export const SimulateBlockCardResponseBlockedReasonEnum = {
    BlockedReversible: 'blocked_reversible',
    Canceled: 'canceled',
    Compliance: 'compliance',
    LockedIncorrectPin: 'locked_incorrect_pin',
    Migrated: 'migrated',
    None: 'none',
    Other: 'other',
    Reissued: 'reissued',
    SuspectedFraud: 'suspected_fraud'
} as const;

export type SimulateBlockCardResponseBlockedReasonEnum = typeof SimulateBlockCardResponseBlockedReasonEnum[keyof typeof SimulateBlockCardResponseBlockedReasonEnum];
export const SimulateBlockCardResponseStatusEnum = {
    Act: 'ACT',
    Blo: 'BLO',
    Imp: 'IMP',
    Ina: 'INA'
} as const;

export type SimulateBlockCardResponseStatusEnum = typeof SimulateBlockCardResponseStatusEnum[keyof typeof SimulateBlockCardResponseStatusEnum];

/**
 * 
 * @export
 * @interface SimulateCardTransactionAuthorizationRequestEEA
 */
export interface SimulateCardTransactionAuthorizationRequestEEA {
    /**
     * Amount of the transaction, in units defined in `currency`.
     * @type {number}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'amount'?: number;
    /**
     * 
     * @type {SimulateCardTransactionAuthorizationRequestEEAAuthResponse}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'auth_response'?: SimulateCardTransactionAuthorizationRequestEEAAuthResponse;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'card_id'?: string;
    /**
     * ID of the transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'card_transaction_id'?: string;
    /**
     * Currency of the transaction. Three-letter ISO 4217 code.Currency of the refund transaction. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'currency_code'?: string;
    /**
     * The exchange rate. Relevant to capture (clearing) transactions.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'fx_rate'?: string;
    /**
     * ID of the issued card transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'id'?: string;
    /**
     * Type of transaction on the issued card.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'issuing_txn_type'?: SimulateCardTransactionAuthorizationRequestEEAIssuingTxnTypeEnum;
    /**
     * Last 4 digits of the card number.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'last4'?: string;
    /**
     * Four-digit merchant category code (MCC) of the initiator of the transaction, as defined in ISO 18245.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'merchant_category_code'?: string;
    /**
     * Name and location of the merchant.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'merchant_name_location'?: string;
    /**
     * ID of the original issued card transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'original_transaction_id'?: string;
    /**
     * Original amount for FX transactions, when `currency` is different from `original_txn_currency`.
     * @type {number}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'original_txn_amount'?: number;
    /**
     * Original currency in an FX transaction.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'original_txn_currency'?: string;
    /**
     * The mode of entry of the transaction at the point of sale.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'pos_entry_mode'?: SimulateCardTransactionAuthorizationRequestEEAPosEntryModeEnum;
    /**
     * Retrieval reference number for the card transaction.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'retrieval_reference_number'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'systems_trace_audit_number'?: string;
    /**
     * ID of the wallet transaction String starting with **wt_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEA
     */
    'wallet_transaction_id'?: string;
}

export const SimulateCardTransactionAuthorizationRequestEEAIssuingTxnTypeEnum = {
    Adjustment: 'ADJUSTMENT',
    AtmFee: 'ATM_FEE',
    Credit: 'CREDIT',
    Refund: 'REFUND',
    Reversal: 'REVERSAL',
    Sale: 'SALE'
} as const;

export type SimulateCardTransactionAuthorizationRequestEEAIssuingTxnTypeEnum = typeof SimulateCardTransactionAuthorizationRequestEEAIssuingTxnTypeEnum[keyof typeof SimulateCardTransactionAuthorizationRequestEEAIssuingTxnTypeEnum];
export const SimulateCardTransactionAuthorizationRequestEEAPosEntryModeEnum = {
    Adjustment: 'adjustment',
    Ecommerce: 'ecommerce',
    Emv: 'emv',
    EmvStandin: 'emv_standin',
    Magstripe: 'magstripe',
    ManualEntered: 'manual_entered',
    NetworkToken: 'network_token',
    Nfc: 'nfc',
    _3dsEcommerce: '3ds_ecommerce'
} as const;

export type SimulateCardTransactionAuthorizationRequestEEAPosEntryModeEnum = typeof SimulateCardTransactionAuthorizationRequestEEAPosEntryModeEnum[keyof typeof SimulateCardTransactionAuthorizationRequestEEAPosEntryModeEnum];

/**
 * Response related to an authorization. Contains the following fields:
 * @export
 * @interface SimulateCardTransactionAuthorizationRequestEEAAuthResponse
 */
export interface SimulateCardTransactionAuthorizationRequestEEAAuthResponse {
    /**
     * Indicates success or reason for failure.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEAAuthResponse
     */
    'code'?: string;
    /**
     * Descriptive text.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationRequestEEAAuthResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SimulateCardTransactionAuthorizationReversalEEA
 */
export interface SimulateCardTransactionAuthorizationReversalEEA {
    /**
     * Amount of the refund, in units defined in `currency`.
     * @type {number}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'amount'?: number;
    /**
     * 
     * @type {SimulateCardTransactionAuthorizationRequestEEAAuthResponse}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'auth_response'?: SimulateCardTransactionAuthorizationRequestEEAAuthResponse;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'card_id'?: string;
    /**
     * ID of the transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'card_transaction_id'?: string;
    /**
     * Currency of the transaction. Three-letter ISO 4217 code.Currency of the refund transaction. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'currency_code'?: string;
    /**
     * The exchange rate. Relevant to capture (clearing) transactions.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'fx_rate'?: string;
    /**
     * ID of the issued card transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'id'?: string;
    /**
     * Indicates whether remote authorization is enabled.
     * @type {boolean}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'is_remote_auth'?: boolean;
    /**
     * Four-digit merchant category code (MCC) of the initiator of the transaction, as defined in ISO 18245.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'merchant_category_code'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'merchant_identification_code'?: string;
    /**
     * Name and location of the merchant. Maximum 40 characters.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'merchant_name_location'?: string;
    /**
     * The URL where the remote authorization is sent.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'remote_auth_endpoint'?: string;
    /**
     * 
     * @type {SimulateClearingCardTransactionEEARemoteAuthResponse}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'remote_auth_response'?: SimulateClearingCardTransactionEEARemoteAuthResponse;
    /**
     * Amount debited from the Rapyd Wallet. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {number}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'transaction_amount'?: number;
    /**
     * Type of transaction.
     * @type {string}
     * @memberof SimulateCardTransactionAuthorizationReversalEEA
     */
    'txn_type'?: SimulateCardTransactionAuthorizationReversalEEATxnTypeEnum;
}

export const SimulateCardTransactionAuthorizationReversalEEATxnTypeEnum = {
    Adjustment: 'ADJUSTMENT',
    AtmFee: 'ATM_FEE',
    Credit: 'CREDIT',
    Refund: 'REFUND',
    Reversal: 'REVERSAL',
    Sale: 'SALE'
} as const;

export type SimulateCardTransactionAuthorizationReversalEEATxnTypeEnum = typeof SimulateCardTransactionAuthorizationReversalEEATxnTypeEnum[keyof typeof SimulateCardTransactionAuthorizationReversalEEATxnTypeEnum];

/**
 * 
 * @export
 * @interface SimulateClearingCardTransactionEEA
 */
export interface SimulateClearingCardTransactionEEA {
    /**
     * Amount of the transaction, in units defined in `currency`.
     * @type {number}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'amount'?: number;
    /**
     * 
     * @type {SimulateCardTransactionAuthorizationRequestEEAAuthResponse}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'auth_response'?: SimulateCardTransactionAuthorizationRequestEEAAuthResponse;
    /**
     * ID of the card. String starting with **card_**.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'card_id'?: string;
    /**
     * ID of the transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'card_transaction_id'?: string;
    /**
     * Currency of the transaction. Three-letter ISO 4217 code.Currency of the refund transaction. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'currency_code'?: string;
    /**
     * The exchange rate. Relevant to capture (clearing) transactions.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'fx_rate'?: string;
    /**
     * ID of the issued card transaction. String starting with **cit_**.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'id'?: string;
    /**
     * Indicates whether remote authorization is enabled.
     * @type {boolean}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'is_remote_auth'?: boolean;
    /**
     * Four-digit merchant category code (MCC) of the initiator of the transaction, as defined in ISO 18245.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'merchant_category_code'?: string;
    /**
     * Reserved.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'merchant_identification_code'?: string;
    /**
     * Name and location of the merchant. Maximum 40 characters.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'merchant_name_location'?: string;
    /**
     * The URL where the remote authorization is sent.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'remote_auth_endpoint'?: string;
    /**
     * 
     * @type {SimulateClearingCardTransactionEEARemoteAuthResponse}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'remote_auth_response'?: SimulateClearingCardTransactionEEARemoteAuthResponse;
    /**
     * Amount debited from the Rapyd Wallet. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {number}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'transaction_amount'?: number;
    /**
     * Original transaction currency, if different from the currency credited to the Rapyd Wallet. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'transaction_currency_code'?: string;
    /**
     * Type of transaction.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEA
     */
    'txn_type'?: SimulateClearingCardTransactionEEATxnTypeEnum;
}

export const SimulateClearingCardTransactionEEATxnTypeEnum = {
    Adjustment: 'ADJUSTMENT',
    AtmFee: 'ATM_FEE',
    Credit: 'CREDIT',
    Refund: 'REFUND',
    Reversal: 'REVERSAL',
    Sale: 'SALE'
} as const;

export type SimulateClearingCardTransactionEEATxnTypeEnum = typeof SimulateClearingCardTransactionEEATxnTypeEnum[keyof typeof SimulateClearingCardTransactionEEATxnTypeEnum];

/**
 * Response to a successful remote authorization request. Contains the following fields:
 * @export
 * @interface SimulateClearingCardTransactionEEARemoteAuthResponse
 */
export interface SimulateClearingCardTransactionEEARemoteAuthResponse {
    /**
     * ID of the authorization. String starting with **cardauth_**.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEARemoteAuthResponse
     */
    'authorization_id'?: string;
    /**
     * Code returned by the client in the response to the remote authorization.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEARemoteAuthResponse
     */
    'response_code'?: string;
    /**
     * Authorization code returned by the client in the response to the remote authorization.
     * @type {string}
     * @memberof SimulateClearingCardTransactionEEARemoteAuthResponse
     */
    'auth_code'?: string;
}
/**
 * 
 * @export
 * @interface Sku
 */
export interface Sku {
    /**
     * Indicates whether the product is currently being sold. Default is false.
     * @type {boolean}
     * @memberof Sku
     */
    'active'?: boolean;
    /**
     * Up to 5 alphanumeric key-value pairs defined by the merchant. Each key must match a string in the attributes list of the corresponding product object.
     * @type {object}
     * @memberof Sku
     */
    'attributes'?: object;
    /**
     * Time of creation of this SKU, in Unix time. Response  only.
     * @type {number}
     * @memberof Sku
     */
    'created_at'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof Sku
     */
    'currency'?: string;
    /**
     * ID of the SKU object. Alphanumeric characters and underscores. Defined by the merchant, or a string starting with **sku**.
     * @type {string}
     * @memberof Sku
     */
    'id'?: string;
    /**
     * URL of image associated with the product.
     * @type {string}
     * @memberof Sku
     */
    'image'?: string;
    /**
     * Contains the following fields: type - One of the following values: finite - Physical objects that can be counted. infinite - Products such as downloadable software. bucket - Products that are sold by measurable quantity. quantity - The number of units available in inventory. Integer. Relevant when type is finite. value - The status of the product on hand in inventory. Relevant when type is bucket. One of the following: in_stock - A normal amount of product is available in inventory. limited - There is enough product in inventory for small orders only. * out_of_stock - No product remains in inventory.
     * @type {object}
     * @memberof Sku
     */
    'inventory'?: object;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Sku
     */
    'metadata'?: object;
    /**
     * 
     * @type {SkuPackageDimensions}
     * @memberof Sku
     */
    'package_dimensions'?: SkuPackageDimensions;
    /**
     * Price of one unit. Decimal.
     * @type {number}
     * @memberof Sku
     */
    'price'?: number;
    /**
     * ID of the product that this SKU relates to.
     * @type {string}
     * @memberof Sku
     */
    'product'?: string;
    /**
     * Time that this product was last updated, in Unix time. Response only.
     * @type {number}
     * @memberof Sku
     */
    'updated_at'?: number;
}
/**
 * Physical attributes of the SKU item. Contains the following fields, height length weight width These fields are represented as numbers, but it is the responsibility of the merchant to define and interpret the relevant units of length and weight.
 * @export
 * @interface SkuPackageDimensions
 */
export interface SkuPackageDimensions {
    /**
     * NA
     * @type {number}
     * @memberof SkuPackageDimensions
     */
    'height'?: number;
    /**
     * NA
     * @type {number}
     * @memberof SkuPackageDimensions
     */
    'length'?: number;
    /**
     * NA
     * @type {number}
     * @memberof SkuPackageDimensions
     */
    'weight'?: number;
    /**
     * NA
     * @type {number}
     * @memberof SkuPackageDimensions
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface SkusSkuIdBody
 */
export interface SkusSkuIdBody {
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof SkusSkuIdBody
     */
    'currency'?: string;
    /**
     * 
     * @type {V1skusskuIdInventory}
     * @memberof SkusSkuIdBody
     */
    'inventory'?: V1skusskuIdInventory;
    /**
     * The amount of the price. Decimal.
     * @type {number}
     * @memberof SkusSkuIdBody
     */
    'price'?: number;
    /**
     * ID of the product that this SKU relates to. The type field of the product must be set to goods.
     * @type {string}
     * @memberof SkusSkuIdBody
     */
    'product'?: string;
    /**
     * Indicates whether the product is currently available for purchase.
     * @type {boolean}
     * @memberof SkusSkuIdBody
     */
    'active'?: boolean;
    /**
     * Array of alphanumeric key-value pairs defined by the merchant. Each key must match a string in the \"attributes\" list of the corresponding \"product\" object.
     * @type {Array<string>}
     * @memberof SkusSkuIdBody
     */
    'attributes'?: Array<string>;
    /**
     * URL of image associated with the product.
     * @type {string}
     * @memberof SkusSkuIdBody
     */
    'image'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof SkusSkuIdBody
     */
    'metadata'?: object;
    /**
     * 
     * @type {V1skusskuIdPackageDimensions}
     * @memberof SkusSkuIdBody
     */
    'package_dimensions'?: V1skusskuIdPackageDimensions;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Error code of the API request. Empty when response is successful.
     * @type {string}
     * @memberof Status
     */
    'error_code'?: string;
    /**
     * Description of the API error message. Empty when response is successful.
     * @type {string}
     * @memberof Status
     */
    'message'?: string;
    /**
     * Unique identifier (UUID)) to track the request.
     * @type {string}
     * @memberof Status
     */
    'operation_id'?: string;
    /**
     * Response code of the API error message. Empty when response is successful.
     * @type {string}
     * @memberof Status
     */
    'response_code'?: string;
    /**
     * Status of the API indicating success or failure.
     * @type {boolean}
     * @memberof Status
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface Status1
 */
export interface Status1 {
    /**
     * Error code of the API request. Empty when the response is successful.
     * @type {string}
     * @memberof Status1
     */
    'error_code'?: string;
    /**
     * Description about the API error. Empty when the response is successful.
     * @type {string}
     * @memberof Status1
     */
    'message'?: string;
    /**
     * Unique identifier (UUID) of the response.
     * @type {string}
     * @memberof Status1
     */
    'operation_id'?: string;
    /**
     * Response code of the API error. Empty when the response is successful.
     * @type {string}
     * @memberof Status1
     */
    'response_code'?: string;
    /**
     * Status of the API response indicating success or failure.
     * @type {string}
     * @memberof Status1
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Determines the method of billing at the end of the billing cycle. Set to pay_automatically - Rapyd generates a \'payment\' object, then attempts to pay it using the designated payment method.
     * @type {string}
     * @memberof Subscription
     */
    'billing'?: string;
    /**
     * 
     * @type {SubscriptionBillingCycleAnchor}
     * @memberof Subscription
     */
    'billing_cycle_anchor'?: SubscriptionBillingCycleAnchor;
    /**
     * Determines the last date that charges accrue. true - Charges accrue until the end of the current billing period, then the subscription is canceled.  * When no trial period is set, after cancel_at_period_end is set to true the subscription will not be renewed at the next interval.  * When a trial period is set after cancel_at_period_end is set to true, the subscription will not begin. false - This is the default.  * When the subscription is created, no end is defined. * When Cancel Subscription is run, charges stop immediately and the subscription is canceled. 
     * @type {boolean}
     * @memberof Subscription
     */
    'cancel_at_period_end'?: boolean;
    /**
     * Date and time that the subscription is canceled by the customer or by the client. Unix time. Response only.
     * @type {number}
     * @memberof Subscription
     */
    'canceled_at'?: number | null;
    /**
     * Time of creation of this subscription, in Unix time. Response only.
     * @type {number}
     * @memberof Subscription
     */
    'created_at'?: number | null;
    /**
     * End of the current billing cycle, in Unix time. Response only.
     * @type {number}
     * @memberof Subscription
     */
    'current_period_end'?: number;
    /**
     * Start of the current billing cycle, in Unix time. Response only.
     * @type {number}
     * @memberof Subscription
     */
    'current_period_start'?: number;
    /**
     * ID of the customer who pays for this subscription. String starting with cus_. Response only.
     * @type {string}
     * @memberof Subscription
     */
    'customer_token'?: string;
    /**
     * Number of days from the invoice date for customer to complete the payment.
     * @type {number}
     * @memberof Subscription
     */
    'days_until_due'?: number | null;
    /**
     * 
     * @type {Discount}
     * @memberof Subscription
     */
    'discount'?: Discount | null;
    /**
     * Date that the subscription was canceled or otherwise terminated. Unix time. Response only.
     * @type {number}
     * @memberof Subscription
     */
    'ended_at'?: number | null;
    /**
     * ID of the Subscription object. String starting with sub_.
     * @type {string}
     * @memberof Subscription
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Subscription
     */
    'metadata'?: object;
    /**
     * Additional payment_options fields.
     * @type {object}
     * @memberof Subscription
     */
    'payment_fields'?: object | null;
    /**
     * Payment method ID or Payment Method object. if not specified in this field, the payment method is the default payment method specified for the customer.
     * @type {string}
     * @memberof Subscription
     */
    'payment_method'?: string;
    /**
     * Reserved.
     * @type {object}
     * @memberof Subscription
     */
    'payout_fields'?: object | null;
    /**
     * Determines whether each upcoming subscription invoice is issued immediately.  * true - The invoice is issued when the subscription is created.  * false - The invoice is issued an hour after the subscription is created. This is the default. 
     * @type {boolean}
     * @memberof Subscription
     */
    'simultaneous_invoice'?: boolean;
    /**
     * Status of the subscription. One of the following:  * active - The customer is currently paying for this subscription.  * canceled - The customer has canceled this subscription, but it remains in the Rapyd database.  * past_due - Payment for this subscription was not received by the end of the billing period.  * trialing - The subscription is in its free trial period. * unpaid - An error occurred in the payment for this subscription. Response only. 
     * @type {string}
     * @memberof Subscription
     */
    'status'?: SubscriptionStatusEnum;
    /**
     * 
     * @type {SubscriptionItems}
     * @memberof Subscription
     */
    'subscription_items'?: SubscriptionItems;
    /**
     * The percentage tax rate that is applied to the subtotal of the invoice, after subtracting all discounts. Decimal. Range: 0-100, with up to four decimal places.
     * @type {number}
     * @memberof Subscription
     */
    'tax_percent'?: number;
    /**
     * The date and time of the end of the customer\'s free trial period, in Unix time, or the string now. Takes precedence over trial_period_days. If trial_end is not set by the client, Rapyd calculates this date by adding trial_period_days to the date in created_at. Relevant when trial_period_days is not defined.
     * @type {number}
     * @memberof Subscription
     */
    'trial_end'?: number | null;
    /**
     * Date and time of the start of the customer\'s free trial period, in Unix time. Response only.
     * @type {number}
     * @memberof Subscription
     */
    'trial_start'?: number | null;
    /**
     * The type of the subscription. One of the following values: * payment  * payout  Response only. 
     * @type {string}
     * @memberof Subscription
     */
    'type'?: SubscriptionTypeEnum | null;
}

export const SubscriptionStatusEnum = {
    Active: 'active',
    Canceled: 'canceled',
    PastDue: 'past_due',
    Trialing: 'trialing',
    Unpaid: 'unpaid'
} as const;

export type SubscriptionStatusEnum = typeof SubscriptionStatusEnum[keyof typeof SubscriptionStatusEnum];
export const SubscriptionTypeEnum = {
    Payout: 'payout',
    Payment: 'payment'
} as const;

export type SubscriptionTypeEnum = typeof SubscriptionTypeEnum[keyof typeof SubscriptionTypeEnum];

/**
 * @type SubscriptionBillingCycleAnchor
 * Determines the start of the next full billing cycle, as defined in the plan described in the \'items\'. One of the following values:  * now - The present day. The next billing cycle starts right now.  * Timestamp in Unix time - A time in the future, at or after the end of the free trial period, not more than the length of the billing cycle. The current billing cycle will be shorter than all other billing cycles. Relevant to creation of the subscription.  * unchanged - The original billing cycle anchor is unchanged. Relevant to updating a subscription. 
 * @export
 */
export type SubscriptionBillingCycleAnchor = number | string;

/**
 * Describes the fields relating to discounts in REST messages and webhooks for customer profiles and subscriptions Contains information about the coupon that applies to the customer. Read-only field. Adding a discount is a 2-step process - 1. Create Coupon, which returns a coupon ID. 2. Add the coupon ID to the coupon field of the customer with Create Customer or Update Customer.
 * @export
 * @interface SubscriptionDiscount
 */
export interface SubscriptionDiscount {
    /**
     * 
     * @type {Coupon}
     * @memberof SubscriptionDiscount
     */
    'coupon'?: Coupon | null;
    /**
     * The final time that a discount can be used, in Unix time. When the value is -1, the discount never expires. Response only.
     * @type {number}
     * @memberof SubscriptionDiscount
     */
    'end'?: number;
    /**
     * ID of the Discount object. String starting with dis_. Response only.
     * @type {string}
     * @memberof SubscriptionDiscount
     */
    'id'?: string;
    /**
     * The number of times that the discount was used for a specific customer or subscription. The initial value is 0. The value is incremented by 1 each time that the discount is used. Response only.
     * @type {number}
     * @memberof SubscriptionDiscount
     */
    'number_of_uses'?: number;
    /**
     * The time that a discount was created, in Unix time. Response only.
     * @type {number}
     * @memberof SubscriptionDiscount
     */
    'start'?: number;
    /**
     * ID of the Subscription object that the discount applies to. String starting with sub_. Response only.
     * @type {string}
     * @memberof SubscriptionDiscount
     */
    'subscription'?: string;
    /**
     * Indicates whether the discount can be used. Response only.
     * @type {boolean}
     * @memberof SubscriptionDiscount
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionHostedPageReponse
 */
export interface SubscriptionHostedPageReponse {
    /**
     * Determines the method of billing at the end of the billing cycle. Set to pay_automatically - Rapyd generates a \'payment\' object, then attempts to pay it using the designated payment method.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'billing'?: string;
    /**
     * 
     * @type {SubscriptionHostedPageReponseBillingCycleAnchor}
     * @memberof SubscriptionHostedPageReponse
     */
    'billing_cycle_anchor'?: SubscriptionHostedPageReponseBillingCycleAnchor;
    /**
     * Determines the last date that charges accrue. **true** - Charges accrue until the end of the current billing period, then the subscription is canceled.  * When no trial period is set, after `cancel_at_period_end` is set to **true** the subscription will not be renewed at the next interval.  * When a trial period is set after `cancel_at_period_end` is set to **true**, the subscription will not begin. <BR> * **false** - This is the default.  * When the subscription is created, no end is defined. * When \'Cancel Subscription\' is run, charges stop immediately and the subscription is canceled. 
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponse
     */
    'cancel_at_period_end'?: boolean;
    /**
     * URL where the customer is redirected after pressing **Back to Website** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs. or by the client. Unix time. Response only.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'cancel_checkout_url'?: string;
    /**
     * Date and time that the subscription is canceled by the customer or by the client. Unix time. Response only.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'canceled_at'?: number | null;
    /**
     * URL where the customer is redirected after pressing **Finish** to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'complete_checkout_url'?: string;
    /**
     * URL where the customer is redirected when payment is successful, after returning from an external page such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'complete_payment_url'?: string;
    /**
     * The two-letter ISO 3166-1 ALPHA-2 code for the country.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'country'?: string;
    /**
     * ID of a coupon to apply a discount to the subscription. String starting with **coupon_**.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'coupon'?: string;
    /**
     * Time of creation of this subscription, in Unix time. Response only.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'created_at'?: number | null;
    /**
     * End of the current billing cycle, in Unix time. Response only.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'current_period_end'?: number;
    /**
     * Start of the current billing cycle, in Unix time. Response only.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'current_period_start'?: number;
    /**
     * 
     * @type {SubscriptionHostedPageReponseCustomElements}
     * @memberof SubscriptionHostedPageReponse
     */
    'custom_elements'?: SubscriptionHostedPageReponseCustomElements;
    /**
     * ID of the customer who pays for this subscription. String starting with cus_. Response only.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'customer'?: string;
    /**
     * Number of days from the invoice date for customer to complete the payment.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'days_until_due'?: number | null;
    /**
     * 
     * @type {Discount}
     * @memberof SubscriptionHostedPageReponse
     */
    'discount'?: Discount | null;
    /**
     * URL where the customer is redirected when payment is not successful, after returning from an external page, such as a 3DS page. Does not support localhost URLs.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'error_payment_url'?: string;
    /**
     * ID of the subscription. String starting with **hp_sub_**.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'id'?: string;
    /**
     * Determines the default language of the hosted page. For a list of values, see List Supported Languages.<BR> * When this parameter is null, the language of the user\'s browser is used.<BR> * If the language of the user\'s browser cannot be determined, the default language is English.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'language'?: string;
    /**
     * Client\'s name.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_alias'?: string;
    /**
     * Color of the call-to-action (CTA) button on the hosted page.<BR> To configure this field, use the Client Portal.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {SubscriptionHostedPageReponseMerchantCustomerSupport}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_customer_support'?: SubscriptionHostedPageReponseMerchantCustomerSupport;
    /**
     * Indicates the text for the call-to-action button on the subscription checkout page.
     * @type {object}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_main_button'?: object;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers.<BR> To configure this field, use the Client Portal. See Customizing Your Hosted Page.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_privacy_policy'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit: 45 characters.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_reference_id'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_terms'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page.<BR> Relevant when one or both of the following fields is unset:<BR>* **cancel_url**<BR>* **complete_url**<BR> To configure this field, use the Client Portal. See Customizing Your Hosted Page.URL for the client\'s terms and conditions. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'merchant_website'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof SubscriptionHostedPageReponse
     */
    'metadata'?: object;
    /**
     * End of the time when the customer can use the hosted page, in Unix time. If page_expiration is not set, the hosted page expires 14 days after creation.<BR> * **Range**: 1 minute to 30 days.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'page_expiration'?: number;
    /**
     * Describes the payment that will result from the hosted page. The id and status values are **null** until the customer successfully submits the information on the hosted page. For more information about the fields in the \'payment\' object, see Create Payment.
     * @type {object}
     * @memberof SubscriptionHostedPageReponse
     */
    'payment'?: object;
    /**
     * Additional `payment_options` fields.
     * @type {object}
     * @memberof SubscriptionHostedPageReponse
     */
    'payment_fields'?: object | null;
    /**
     * Payment method used for paying invoices generated by this subscription. The ID is a string starting with **card_** or **other_**.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'payment_method'?: string;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'redirect_url'?: string;
    /**
     * Status of the subscription. One of the following:  * active - The customer is currently paying for this subscription.  * canceled - The customer has canceled this subscription, but it remains in the Rapyd database.  * past_due - Payment for this subscription was not received by the end of the billing period.  * trialing - The subscription is in its free trial period. * unpaid - An error occurred in the payment for this subscription. Response only. 
     * @type {string}
     * @memberof SubscriptionHostedPageReponse
     */
    'status'?: SubscriptionHostedPageReponseStatusEnum;
    /**
     * 
     * @type {SubscriptionItems}
     * @memberof SubscriptionHostedPageReponse
     */
    'subscription_items'?: SubscriptionItems;
    /**
     * The percentage tax rate that is applied to the subtotal of the invoice, after subtracting all discounts. Decimal. Range: 0-100, with up to four decimal places.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'tax_percent'?: number;
    /**
     * Total number of subscription items.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'total_count'?: number;
    /**
     * The date and time of the end of the customer\'s free trial period, in Unix time, or the string **now**. Takes precedence over `trial_period_days`. If `trial_end` is not set by the client, Rapyd calculates this date by adding `trial_period_days` to the date in `created_at`. Relevant when `trial_period_days` is not defined.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'trial_end'?: number | null;
    /**
     * Determines whether a free trial period can be defined in a plan attached to the subscription.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponse
     */
    'trial_from_plan'?: boolean;
    /**
     * The number of days in the customer\'s free trial period. Integer. Range: 0-730. This value takes precedence over trial periods that are defined in a plan. Relevant when `trial_end` is not defined.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'trial_period_days'?: number;
    /**
     * Date and time of the start of the customer\'s free trial period, in Unix time.
     * @type {number}
     * @memberof SubscriptionHostedPageReponse
     */
    'trial_start'?: number | null;
}

export const SubscriptionHostedPageReponseStatusEnum = {
    Active: 'active',
    Canceled: 'canceled',
    PastDue: 'past_due',
    Trialing: 'trialing',
    Unpaid: 'unpaid'
} as const;

export type SubscriptionHostedPageReponseStatusEnum = typeof SubscriptionHostedPageReponseStatusEnum[keyof typeof SubscriptionHostedPageReponseStatusEnum];

/**
 * @type SubscriptionHostedPageReponseBillingCycleAnchor
 * Determines the start of the next full billing cycle, as defined in the plan described in the \'items\'. One of the following values:  * **now** - The present day. The next billing cycle starts right now.  * <em>Timestamp</em> in Unix time - A time in the future, at or after the end of the free trial period, not more than the length of the billing cycle. The current billing cycle will be shorter than all other billing cycles. Relevant to creation of the subscription.  * **unchanged** - The original billing cycle anchor is unchanged. Relevant to updating a subscription. 
 * @export
 */
export type SubscriptionHostedPageReponseBillingCycleAnchor = number | string;

/**
 * Description of the payment transaction.
 * @export
 * @interface SubscriptionHostedPageReponseCustomElements
 */
export interface SubscriptionHostedPageReponseCustomElements {
    /**
     * Determines whether the customer is asked to fill in the billing address. Relevant when a card payment method is selected. <BR> * **true** - The address fields appear on the checkout page.<BR> * **false** - The address fields appear only if the country is **US, **GB** or **CA**.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'billing_address_collect'?: boolean;
    /**
     * The name of the card owner, printed on the front of the card.
     * @type {string}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'cardholder_name'?: string;
    /**
     * Determines whether the checkout page displays the payment description.<BR>* **true** - The payment description appears.<BR> * **false** - The payment description does not appear.<BR> Relevant when description is passed in the Create Checkout Page request.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'display_description'?: boolean;
    /**
     * Determines whether the checkout page displays multiple currency options for a payment.<BR> * **true** - Multiple currency options appear.<BR> * **false** - Currency options do not appear.<BR>When the customer selects the requested currency, the checkout page displays the following information:<BR>* The original amount and currency.<BR> * The converted amount in the requested currency.<BR> * The exchange rate.<BR> Relevant when: <BR> * The Create Checkout Page request passes requested_currency.<BR> * `fixed_side` is **buy**. <BR> * One or more payment methods support the values for `currency` and `requested_currency`.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'dynamic_currency_conversion'?: boolean;
    /**
     * reserved
     * @type {string}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'merchant_color'?: string;
    /**
     * In a payment with FX where fixed_side=**buy**, determines whether the buyer\'s currency and the exchange rate appear. One of the following:<BR> * **true** - The currency and the exchange rate are hidden.<BR> * **false** - The currency and the exchange rate appear.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'merchant_currency_only'?: boolean;
    /**
     * Determines whether payment fees appear on the checkout page.<BR> * **true** - Payment fees appear when the `payment_fees` object is set in the \'Create Checkout Page\' request.<BR> * **false** - Payment fees do not appear.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'payment_fees_display'?: boolean;
    /**
     * Indicates the list of fields that the customer has to fill in on the payment page before completing the payment via hosted checkout. Valid values include:<BR>* **name** – The customer\'s full name (default).<BR> * **email** – The customer\'s email address.<BR> * **phone_number** – The customer\'s phone number.<BR> * **address** – The address of the customer.
     * @type {any}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'required_customer_fields'?: any;
    /**
     * Determines whether the save card checkbox is checked by default.<BR> * **true** - The **save card** checkbox is checked.<BR> * **false** - The **save card** checkbox is cleared.<BR> Relevant when `customer_id` is passed in the \'Create Checkout Page\' request.
     * @type {boolean}
     * @memberof SubscriptionHostedPageReponseCustomElements
     */
    'save_card_default'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionHostedPageReponseMerchantCustomerSupport
 */
export interface SubscriptionHostedPageReponseMerchantCustomerSupport {
    /**
     * Email address.
     * @type {string}
     * @memberof SubscriptionHostedPageReponseMerchantCustomerSupport
     */
    'email'?: string;
    /**
     * URL for the client\'s customer support service.
     * @type {string}
     * @memberof SubscriptionHostedPageReponseMerchantCustomerSupport
     */
    'url'?: string;
    /**
     * Phone number for contacting the client\'s customer support service.
     * @type {string}
     * @memberof SubscriptionHostedPageReponseMerchantCustomerSupport
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionItem
 */
export interface SubscriptionItem {
    /**
     * The time the subscription item was created, in Unix time. Response only.
     * @type {number}
     * @memberof SubscriptionItem
     */
    'created'?: number;
    /**
     * ID of the Subscription Item object. String starting with subi_.
     * @type {string}
     * @memberof SubscriptionItem
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof SubscriptionItem
     */
    'metadata'?: object;
    /**
     * 
     * @type {Plan}
     * @memberof SubscriptionItem
     */
    'plan'?: Plan;
    /**
     * The number of units of the service defined in the plan. Integer. This number can be updated during the billing cycle using Update Subscription or Update Subscription Item.
     * @type {number}
     * @memberof SubscriptionItem
     */
    'quantity'?: number;
    /**
     * ID of the subscription that this item belongs to. String starting with sub_.
     * @type {string}
     * @memberof SubscriptionItem
     */
    'subscription_id'?: string | null;
}
/**
 * 
 * @export
 * @interface SubscriptionItemIdUsageRecordsBody
 */
export interface SubscriptionItemIdUsageRecordsBody {
    /**
     * Determines how the quantity is defined in the usage record.
     * @type {string}
     * @memberof SubscriptionItemIdUsageRecordsBody
     */
    'action'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof SubscriptionItemIdUsageRecordsBody
     */
    'metadata'?: object;
    /**
     * The usage quantity for the specified date and time (timestamp).
     * @type {number}
     * @memberof SubscriptionItemIdUsageRecordsBody
     */
    'quantity': number;
    /**
     * Timestamp for the usage record in Unix time.
     * @type {number}
     * @memberof SubscriptionItemIdUsageRecordsBody
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface SubscriptionItems
 */
export interface SubscriptionItems {
    /**
     * A list of up to three subscription items.
     * @type {Array<SubscriptionItem>}
     * @memberof SubscriptionItems
     */
    'data'?: Array<SubscriptionItem>;
    /**
     * Indicates whether there are more than three items in this subscription.
     * @type {boolean}
     * @memberof SubscriptionItems
     */
    'has_more'?: boolean;
    /**
     * Total number of items in this subscription.
     * @type {number}
     * @memberof SubscriptionItems
     */
    'total_count'?: number;
    /**
     * URL for requesting all of the items in this subscription.
     * @type {string}
     * @memberof SubscriptionItems
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionItemsSubscriptionItemIdBody
 */
export interface SubscriptionItemsSubscriptionItemIdBody {
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof SubscriptionItemsSubscriptionItemIdBody
     */
    'metadata'?: object;
    /**
     * Determines whether the charge is prorated when a subscription item is switched from one subscription to another in a billing cycle.
     * @type {boolean}
     * @memberof SubscriptionItemsSubscriptionItemIdBody
     */
    'prorate'?: boolean;
    /**
     * Indicates the date in the middle of the billing period that is the start of the prorated charges.
     * @type {number}
     * @memberof SubscriptionItemsSubscriptionItemIdBody
     */
    'proration_date'?: number;
    /**
     * The number of units of the service defined in the plan.
     * @type {number}
     * @memberof SubscriptionItemsSubscriptionItemIdBody
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionsSubscriptionIdBody
 */
export interface SubscriptionsSubscriptionIdBody {
    /**
     * Determines the method of billing. Set to pay_automatically.
     * @type {string}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'billing'?: string;
    /**
     * Determines the start of the next billing cycle, as defined in the plan described in the \'items\'. Value must be timestamp in Unix time.
     * @type {string}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'billing_cycle_anchor'?: string;
    /**
     * Terminates the subscription at the end of the current billing period.
     * @type {boolean}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'cancel_at_period_end'?: boolean;
    /**
     * The ID of a discount coupon that applies to all subscription items associated with this subscription. If the coupon defines a fixed monetary discount, it must use the same currency as the subscription\'s plan.
     * @type {string}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'coupon'?: string;
    /**
     * Number of days from the invoice date for customer to complete the payment.
     * @type {number}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'days_until_due'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'metadata'?: object;
    /**
     * 
     * @type {PaymentOptions}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'payment_fields'?: PaymentOptions;
    /**
     * 
     * @type {V1PaymentsBodyPaymentMethod}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'payment_method'?: V1PaymentsBodyPaymentMethod;
    /**
     * Determines whether each upcoming subscription invoice is issued immediately. When true, the invoice is issued when the subscription is created. When false (the default), the invoice is issued an hour after the subscription is created.
     * @type {boolean}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'simultaneous_invoice'?: boolean;
    /**
     * Array of subscription items. Each item contains a plan (required) and a quantity
     * @type {Array<string>}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'subscription_items'?: Array<string>;
    /**
     * The percentage of tax that is applied to the entire amount of the invoice.
     * @type {number}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'tax_percent'?: number;
    /**
     * The time of the end of the customer\'s free trial period. If trial_from_plan is set, leave this parameter unset.
     * @type {number}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'trial_end'?: number;
    /**
     * Determines whether a free trial period can be defined in a \'plan\' object attached to the subscription. If trial_end is set, leave this parameter unset.
     * @type {boolean}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'trial_from_plan'?: boolean;
    /**
     * The number of days in the customer\'s free trial period.
     * @type {number}
     * @memberof SubscriptionsSubscriptionIdBody
     */
    'trial_period_days'?: number;
}
/**
 * Describes the fee for processing the transaction.
 * @export
 * @interface TransactionFee
 */
export interface TransactionFee {
    /**
     * Specifies how the fee is calculated. One of the following:  * net - The fee is deducted from the amount paid.  For example, in a payout of $100 with a fee of 5%, the recipient receives $95.00 and the $5.00 fee goes to the client wallet.  * gross - The fee is charged on top of the amount paid.  For example, for a transaction of $100 with a fee of 5%, the sender pays $105.00. The recipient receives $100.00 and the $5.00 fee goes to the client wallet. 
     * @type {string}
     * @memberof TransactionFee
     */
    'calc_type'?: string;
    /**
     * One of the following:  percentage - A percentage of the transaction amount.  For example, 5 percent is represented by value=5. absolute - A fixed amount 
     * @type {string}
     * @memberof TransactionFee
     */
    'fee_type'?: string;
    /**
     * The amount of the fee. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {number}
     * @memberof TransactionFee
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * Amount of the transfer. Decimal.
     * @type {number}
     * @memberof Transfer
     */
    'amount'?: number;
    /**
     * Time the transaction was made, in Unix time.
     * @type {number}
     * @memberof Transfer
     */
    'created_at'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the amount field.
     * @type {string}
     * @memberof Transfer
     */
    'currency_code'?: string;
    /**
     * ID of the wallet receiving the money. String starting with **ewallet_**. Response only.
     * @type {string}
     * @memberof Transfer
     */
    'destination_ewallet_id'?: string;
    /**
     * Phone number of the owner of the wallet receiving the money, in E.164 format.
     * @type {string}
     * @memberof Transfer
     */
    'destination_phone_number'?: string;
    /**
     * ID of the transaction with regard to the destination. String starting with **wt_**.
     * @type {string}
     * @memberof Transfer
     */
    'destination_transaction_id'?: string;
    /**
     * ID of the transaction. String starting with **wt_** or UUID.
     * @type {string}
     * @memberof Transfer
     */
    'id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof Transfer
     */
    'metadata'?: object;
    /**
     * Metadata created with Set Transfer Response. Response only.
     * @type {object}
     * @memberof Transfer
     */
    'response_metadata'?: object;
    /**
     * ID of the wallet sending the money. String starting with **ewallet_**. Response only.
     * @type {string}
     * @memberof Transfer
     */
    'source_ewallet_id'?: string;
    /**
     * ID of the transaction with regard to the source. String starting with **wt_**.
     * @type {string}
     * @memberof Transfer
     */
    'source_transaction_id'?: string;
    /**
     * < Status of the transaction. CAN - Canceled. The transferor canceled the transfer. CLO - Closed. The transferee accepted the funds. DEC - Declined. The transferee rejected the transfer. EXP - Expired. The transferee did not respond before the transfer expired. HLD - Hold. Rapyd Protect is putting this transfer on hold and reviewing it. PEN - Pending. Waiting for the transferee to accept. REJ - Rejected. Rapyd Protect has rejected this transfer.
     * @type {string}
     * @memberof Transfer
     */
    'status'?: TransferStatusEnum;
    /**
     * Time of the Set Transfer Response operation, in Unix time. Read-only.
     * @type {number}
     * @memberof Transfer
     */
    'transfer_response_at'?: number;
    /**
     * Determines the day the transfer expires, in Unix time. Acceptance of the transfer must occur before the start of this day. Default is 14 days after creation of the transfer.
     * @type {number}
     * @memberof Transfer
     */
    'expiration'?: number;
}

export const TransferStatusEnum = {
    Can: 'CAN',
    Clo: 'CLO',
    Dec: 'DEC',
    Exp: 'EXP',
    Hld: 'HLD',
    Pen: 'PEN',
    Rej: 'REJ'
} as const;

export type TransferStatusEnum = typeof TransferStatusEnum[keyof typeof TransferStatusEnum];

/**
 * 
 * @export
 * @interface TransferResponseBody
 */
export interface TransferResponseBody {
    /**
     * ID of the transfer transaction, from the `id` field in the `data` object of the response. 32-digit hexadecimal.
     * @type {string}
     * @memberof TransferResponseBody
     */
    'id': string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof TransferResponseBody
     */
    'metadata'?: object;
    /**
     * Determines how to handle the transfer. One of the following values - accept, decline, cancel
     * @type {string}
     * @memberof TransferResponseBody
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V1AddressesBody
 */
export interface V1AddressesBody {
    /**
     * Name of the canton administrative subdivision, as used in banking.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'canton'?: string;
    /**
     * City portion of the address. Required for issuance of a card to the wallet contact.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'city'?: string;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'country'?: string;
    /**
     * Time of creation of the payment, in Unix time. Response only.
     * @type {number}
     * @memberof V1AddressesBody
     */
    'created_at'?: number;
    /**
     * Name of the district administrative subdivision, as used in banking.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'district'?: string;
    /**
     * ID of the Address object. String starting with **address_**.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'id'?: string;
    /**
     * Line 1 of the address, such as a building number and street name.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'line_1': string;
    /**
     * Line 2 of the address, such as a suite or apartment number, or the name of a named building.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'line_2'?: string;
    /**
     * Line 3 of the address, such as a suite or apartment number, or the name of a named building.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'line_3'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1AddressesBody
     */
    'metadata'?: object;
    /**
     * The name of a contact person or an \'in care of\' person at this address. For a **personal** wallet contact type, alphabetic characters and spaces.A JSON object defined by the client.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'name': string;
    /**
     * Phone number associated with this specific address in E.164 format. Must be unique.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'phone_number'?: string;
    /**
     * State or province portion of the address.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'state'?: string;
    /**
     * Postal code portion of the address.
     * @type {string}
     * @memberof V1AddressesBody
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface V1CheckoutBody
 */
export interface V1CheckoutBody {
    /**
     * Details of an account funding transaction (AFT), which transfers funds from a card to a cardholder\'s wallet.
     * @type {object}
     * @memberof V1CheckoutBody
     */
    'account_funding_transaction'?: object;
    /**
     * The amount of the payment, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {number}
     * @memberof V1CheckoutBody
     */
    'amount': number;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'cancel_checkout_url'?: string;
    /**
     * 
     * @type {HostedPageAdditionalResponseCartItems}
     * @memberof V1CheckoutBody
     */
    'cart_items'?: HostedPageAdditionalResponseCartItems;
    /**
     * URL where the customer is redirected after pressing Finish to exit the hosted page. This URL overrides the `merchant_website` URL. Does not support localhost URLs.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'complete_checkout_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'country': string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'currency': string;
    /**
     * Description of the payment transaction. To display the description, set display_description to true in custom_elements.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'customer'?: string;
    /**
     * Determines whether the payment is held in escrow for later release.
     * @type {boolean}
     * @memberof V1CheckoutBody
     */
    'escrow'?: boolean;
    /**
     * Determines the number of days after creation of the payment that funds are released from escrow. Funds are released at 5:00 pm GMT on the day indicated. Integer, range: 1-90.
     * @type {number}
     * @memberof V1CheckoutBody
     */
    'escrow_release_days'?: number;
    /**
     * ID of the Rapyd checkout page. String starting with **checkout_**.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'id'?: string;
    /**
     * A string that represents the text on the main Call to Action (CTA) button. One of the following:<BR>* place_your_order - Place Your Order.<BR>* pay - Pay.<BR>* pay_now - Pay Now.<BR>* make_payment - Make Payment.<BR>* purchase - Purchase.<BR>* buy - Buy.<BR>* donate - Donate.<BR>* To configure this button, use the Client Portal.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'merchant_main_button'?: string;
    /**
     * URL for the terms and conditions of the agreement between the client and the client’s customers. To configure this field, use the Client Portal.
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'merchant_privacy_policy'?: string;
    /**
     * URL for the client\'s terms and conditions. To configure this field, use the Client Portal
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'merchant_terms'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page. Relevant when one or both of the following fields is unset: <BR>* `cancel_url` <BR>* `complete_url`.<BR> To configure this field, use the Client Portal
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'merchant_website'?: string;
    /**
     * 
     * @type {HostedPageAdditionalResponseCustomElements}
     * @memberof V1CheckoutBody
     */
    'custom_elements'?: HostedPageAdditionalResponseCustomElements;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof V1CheckoutBody
     */
    'page_expiration'?: number;
    /**
     * 
     * @type {Payment}
     * @memberof V1CheckoutBody
     */
    'payment'?: Payment;
    /**
     * Length of time for the payment to be completed after it is created, measured in seconds. When both expiration and payment_expiration are set, the payment expires at the earlier time.
     * @type {number}
     * @memberof V1CheckoutBody
     */
    'payment_expiration'?: number;
    /**
     * The type of the payment method. For example, **it_visa_card**
     * @type {string}
     * @memberof V1CheckoutBody
     */
    'payment_method_type'?: string;
    /**
     * A list of the categories of payment method that are supported on the checkout page. The categories appear on the page in the order provided
     * @type {Array<string>}
     * @memberof V1CheckoutBody
     */
    'payment_method_type_categories'?: Array<string>;
    /**
     * List of payment methods that are excluded from display on the checkout page.
     * @type {Array<string>}
     * @memberof V1CheckoutBody
     */
    'payment_method_types_exclude'?: Array<string>;
    /**
     * List of payment methods that are displayed on the checkout page. The payment methods appear on the page in the order provided.
     * @type {Array<string>}
     * @memberof V1CheckoutBody
     */
    'payment_method_types_include'?: Array<string>;
    /**
     * Time of creation of the checkout page, in Unix time.
     * @type {number}
     * @memberof V1CheckoutBody
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface V1CustomersBody
 */
export interface V1CustomersBody {
    /**
     * Array of address objects associated with this customer. For more information
     * @type {Array<Address1>}
     * @memberof V1CustomersBody
     */
    'addresses'?: Array<Address1>;
    /**
     * The tax ID number of the customer
     * @type {string}
     * @memberof V1CustomersBody
     */
    'business_vat_id'?: string;
    /**
     * The ID of a coupon that is assigned to this customer
     * @type {string}
     * @memberof V1CustomersBody
     */
    'coupon'?: string;
    /**
     * 
     * @type {CustomerRequestPaymentMethod}
     * @memberof V1CustomersBody
     */
    'payment_method'?: CustomerRequestPaymentMethod;
    /**
     * A text description of the customer
     * @type {string}
     * @memberof V1CustomersBody
     */
    'description'?: string;
    /**
     * Customer\'s email address
     * @type {string}
     * @memberof V1CustomersBody
     */
    'email'?: string;
    /**
     * ID of the wallet that is linked to the customer. String starting with **ewallet_**.
     * @type {string}
     * @memberof V1CustomersBody
     */
    'ewallet'?: string;
    /**
     * A custom string that is prefixed to all invoices for this customer.
     * @type {string}
     * @memberof V1CustomersBody
     */
    'invoice_prefix'?: string;
    /**
     * A JSON object defined by the Rapyd partner
     * @type {object}
     * @memberof V1CustomersBody
     */
    'metadata'?: object;
    /**
     * The name of the individual customer or the business name
     * @type {string}
     * @memberof V1CustomersBody
     */
    'name': string;
    /**
     * Customer\'s primary phone number in E.164 format
     * @type {string}
     * @memberof V1CustomersBody
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface V1EwalletsBody
 */
export interface V1EwalletsBody {
    /**
     * 
     * @type {V1ewalletsContact}
     * @memberof V1EwalletsBody
     */
    'contact': V1ewalletsContact;
    /**
     * Rapyd Wallet ID defined by the customer or end user. Must be unique.
     * @type {string}
     * @memberof V1EwalletsBody
     */
    'ewallet_reference_id'?: string;
    /**
     * First name of the Rapyd Wallet owner.
     * @type {string}
     * @memberof V1EwalletsBody
     */
    'first_name'?: string;
    /**
     * Last name of the Rapyd Wallet owner.
     * @type {string}
     * @memberof V1EwalletsBody
     */
    'last_name'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1EwalletsBody
     */
    'metadata'?: object;
    /**
     * Type of wallet, company or person. Default is person.
     * @type {string}
     * @memberof V1EwalletsBody
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface V1IdentitiesBody
 */
export interface V1IdentitiesBody {
    /**
     * Base-64-encoded image of the back of the identity document.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'back_side_image'?: string;
    /**
     * MIME type of the back side image of the identity document. Default is
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'back_side_image_mime_type'?: string;
    /**
     * ID of a personal contact for a \'person\' wallet.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'contact'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'country': string;
    /**
     * Type of the identification document. Two-letter code.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'document_type': string;
    /**
     * ID of the Rapyd Wallet. String starting with ewallet_.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'ewallet': string;
    /**
     * Base-64-encoded image of the face.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'face_image': string;
    /**
     * MIME type of the face image. Default is image/jpeg.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'face_image_mime_type'?: string;
    /**
     * Base-64-encoded image of the front of the identity document.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'front_side_image': string;
    /**
     * MIME type of the front side image of the identity document. Default is image/jpeg.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'front_side_image_mime_type'?: string;
    /**
     * ID of the identity verification request. Must be unique for each request. Defined by the client. Maximum length: 36 characters. In sandbox, to simulate success or failure, the string must contain one of the following values: success, failure For example: 12345678success
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'reference_id': string;
    /**
     * Determines the action that is taken on the request.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'request_type'?: string;
    /**
     * Determines whether a webhook is sent with the results of the verification request.
     * @type {string}
     * @memberof V1IdentitiesBody
     */
    'send_callback'?: string;
}
/**
 * 
 * @export
 * @interface V1InvoiceItemsBody
 */
export interface V1InvoiceItemsBody {
    /**
     * The amount of the total charge or credit for this item. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.<BR> This is `quantity` times `unit_amount`. A credit is indicated by a negative number.
     * @type {number}
     * @memberof V1InvoiceItemsBody
     */
    'amount'?: number;
    /**
     * Three-letter ISO 4217 code for the currency used in the `amount` field.
     * @type {string}
     * @memberof V1InvoiceItemsBody
     */
    'currency': string;
    /**
     * ID of the customer. String starting with **cus_**.
     * @type {string}
     * @memberof V1InvoiceItemsBody
     */
    'customer': string;
    /**
     * Description of the invoice item.
     * @type {string}
     * @memberof V1InvoiceItemsBody
     */
    'description'?: string;
    /**
     * Determines whether this invoice item is subject to the discount defined in the coupon that is assigned to the customer or subscription.<BR> For negative amounts and prorations, the default is **false**, and for all other invoice items, the default is **true**.
     * @type {boolean}
     * @memberof V1InvoiceItemsBody
     */
    'discountable'?: boolean;
    /**
     * ID of the invoice that this invoice item is assigned to. Relevant when `subscription` is not set.
     * @type {string}
     * @memberof V1InvoiceItemsBody
     */
    'invoice'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1InvoiceItemsBody
     */
    'metadata'?: object;
    /**
     * Indicates the number of units charged as a single invoice item. Integer.
     * @type {number}
     * @memberof V1InvoiceItemsBody
     */
    'quantity'?: number;
    /**
     * ID of the subscription to assign this invoice item to. By default, the invoice item is assigned to the customer\'s subscription whose current billing cycle ends first. Relevant when `invoice` is not set.
     * @type {string}
     * @memberof V1InvoiceItemsBody
     */
    'subscription'?: string;
    /**
     * Per-unit price of the product or service, adjusted as defined in the plan. Decimal.
     * @type {number}
     * @memberof V1InvoiceItemsBody
     */
    'unit_amount'?: number;
}
/**
 * 
 * @export
 * @interface V1InvoicesBody
 */
export interface V1InvoicesBody {
    /**
     * Determines the method of billing at the end of the billing cycle. Set to **pay_automatically** - Rapyd generates a `payment` object, then attempts to pay it using the designated payment method.The number of days until the due date.
     * @type {number}
     * @memberof V1InvoicesBody
     */
    'billing': number;
    /**
     * Three-letter ISO 4217 currency code for the currency used in all fields that refer to a monetary amount. Required when the subscription field is not provided. If subscription field is provided, then the currency defined in the subscription\'s plan is used.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'currency'?: string;
    /**
     * ID of the customer that pays this invoice. String starting with **cus_**.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'customer': string;
    /**
     * The number of days until the due date.
     * @type {number}
     * @memberof V1InvoicesBody
     */
    'days_until_due'?: number;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'description'?: string;
    /**
     * The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the `days_until_due` field. Relevant when `billing` is **send_invoice**.  Format is in Unix time.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'due_date'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1InvoicesBody
     */
    'metadata'?: object;
    /**
     * Object containing additional payment_options fields.
     * @type {object}
     * @memberof V1InvoicesBody
     */
    'payment_fields'?: object;
    /**
     * ID of the payment method for paying the invoice. If not provided, then the payment method is taken from the subscription. If the payment method is not provided in the subscription, the payment method is the customer\'s default payment method.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'payment_method'?: string;
    /**
     * Description of the invoice for the customer\'s credit card statement. Limited to 22 characters.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'statement_descriptor'?: string;
    /**
     * ID of the subscription that generates charges to this customer. String starting with **sub_**.
     * @type {string}
     * @memberof V1InvoicesBody
     */
    'subscription'?: string;
    /**
     * The tax rate, defined as a percentage.
     * @type {number}
     * @memberof V1InvoicesBody
     */
    'tax_percent'?: number;
}
/**
 * 
 * @export
 * @interface V1OrdersBody
 */
export interface V1OrdersBody {
    /**
     * ID of a coupon that is applied against this order. String starting with coupon_. The duration field of the coupon must be set to **repeating**, and the `duration_in_months` and `discount_duration_in_uses` fields must be set to **1**.
     * @type {string}
     * @memberof V1OrdersBody
     */
    'coupon'?: string;
    /**
     * ID of the customer. String starting with cus_.
     * @type {string}
     * @memberof V1OrdersBody
     */
    'customer': string;
    /**
     * Three-letter ISO 4217 code for the currency used in the objects in the \'items\' list.
     * @type {string}
     * @memberof V1OrdersBody
     */
    'currency': string;
    /**
     * Email address of the customer.
     * @type {string}
     * @memberof V1OrdersBody
     */
    'email'?: string;
    /**
     * Array of line items.
     * @type {Array<V1ordersItems>}
     * @memberof V1OrdersBody
     */
    'items': Array<V1ordersItems>;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1OrdersBody
     */
    'metadata'?: object;
    /**
     * 
     * @type {Address1}
     * @memberof V1OrdersBody
     */
    'shipping_address'?: Address1;
    /**
     * Percentage of tax to charge. Decimal.
     * @type {number}
     * @memberof V1OrdersBody
     */
    'tax_percent'?: number;
    /**
     * Merchant-defined ID for the order. If the merchant does not define an ID, Rapyd generates it.
     * @type {string}
     * @memberof V1OrdersBody
     */
    'upstream_id'?: string;
}
/**
 * 
 * @export
 * @interface V1PaymentsBody
 */
export interface V1PaymentsBody {
    /**
     * 
     * @type {Address1}
     * @memberof V1PaymentsBody
     */
    'address'?: Address1;
    /**
     * The amount received by the recipient, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. To verify a card, set to 0.
     * @type {number}
     * @memberof V1PaymentsBody
     */
    'amount': number;
    /**
     * Determines when the payment is processed for capture. When true, the payment is captured immediately. When false, the payment is captured at a later time. Relevant to cards. Default is true.
     * @type {boolean}
     * @memberof V1PaymentsBody
     */
    'capture'?: boolean;
    /**
     * 
     * @type {ClientDetailsObject}
     * @memberof V1PaymentsBody
     */
    'client_details'?: ClientDetailsObject;
    /**
     * URL where the customer is redirected after successfully completing an operation on an external page.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'complete_payment_url'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'currency': string;
    /**
     * string - ID of the customer who is making the payment. String starting with cus_. Required if payment_method is blank. object - Contains all required fields
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'customer'?: string;
    /**
     * Description of the payment
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'description'?: string;
    /**
     * URL where the customer is redirected in case of an error in the operation. Provided by the client.Relevant to bank redirect payment methods
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'error_payment_url'?: string;
    /**
     * Determines whether the payment is held in escrow for later release.
     * @type {boolean}
     * @memberof V1PaymentsBody
     */
    'escrow'?: boolean;
    /**
     * Determines the number of days after creation of the payment that funds are released from escrow. Funds are released at 5:00 pm GMT on the day indicated. Integer, range between 1-90. Default is 90.
     * @type {number}
     * @memberof V1PaymentsBody
     */
    'escrow_release_days'?: number;
    /**
     * ID of the wallet that the money is paid into. String starting with **ewallet_**. Relevant when the request includes a single wallet.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'ewallet'?: string;
    /**
     * Represents the wallets that the money is paid into. Array of objects.
     * @type {any}
     * @memberof V1PaymentsBody
     */
    'ewallets'?: any;
    /**
     * End of the time allowed for customer to make this payment, in Unix time. Must be after the current time
     * @type {number}
     * @memberof V1PaymentsBody
     */
    'expiration'?: number;
    /**
     * Indicates whether the FX rate is fixed for the buy side (seller\'s Rapyd Wallet) or for the sell side (buyer).
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'fixed_side'?: string;
    /**
     * ID of the group payment, a string starting with \'gp_\'. Relevant to replacing a payment that failed.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'group_payment'?: string;
    /**
     * Describes how the transaction was initiated.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'initiation_type'?: V1PaymentsBodyInitiationTypeEnum;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1PaymentsBody
     */
    'metadata'?: object;
    /**
     * 
     * @type {Fee}
     * @memberof V1PaymentsBody
     */
    'payment_fees'?: Fee | null;
    /**
     * 
     * @type {V1PaymentsBodyPaymentMethod}
     * @memberof V1PaymentsBody
     */
    'payment_method'?: V1PaymentsBodyPaymentMethod;
    /**
     * Object describing additional information required for the payment. The object is returned by Get Payment Method Required Fields. Note that Transactions with 3DS authentication must be authenticated within 15 minutes, after which the possibility to authenticate expires.
     * @type {object}
     * @memberof V1PaymentsBody
     */
    'payment_method_options'?: object;
    /**
     * Email address that the receipt for this transaction is sent to.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'receipt_email'?: string;
    /**
     * When fixed_side is sell, it is the currency received in the Rapyd Wallet. . When fixed_side is buy, it is the currency charged to the buyer (customer). Three-letter ISO 4217 code.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'requested_currency'?: string;
    /**
     * A text description that appears in the customer\'s bank statement.
     * @type {string}
     * @memberof V1PaymentsBody
     */
    'statement_descriptor'?: string;
}

export const V1PaymentsBodyInitiationTypeEnum = {
    CustomerPresent: 'customer_present',
    Installment: 'installment',
    Moto: 'moto',
    Recurring: 'recurring',
    Unscheduled: 'unscheduled'
} as const;

export type V1PaymentsBodyInitiationTypeEnum = typeof V1PaymentsBodyInitiationTypeEnum[keyof typeof V1PaymentsBodyInitiationTypeEnum];

/**
 * @type V1PaymentsBodyPaymentMethod
 * Payment Method object or ID.
 * @export
 */
export type V1PaymentsBodyPaymentMethod = PaymentMethodType | string;

/**
 * 
 * @export
 * @interface V1PayoutsBody
 */
export interface V1PayoutsBody {
    /**
     * String starting with **beneficiary_** or the object describing the beneficiary.
     * @type {string | Beneficiary}
     * @memberof V1PayoutsBody
     */
    'beneficiary': string | Beneficiary;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'beneficiary_country'?: string;
    /**
     * Type of entity for the beneficiary. One of the following: **individual** | **company**
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'beneficiary_entity_type': PayoutRequestBeneficiaryEntityTypeEnum;
    /**
     * Determines whether completion of the payout requires confirmation of the FX rate. Relevant to payouts with foreign exchange. Default is false.
     * @type {boolean}
     * @memberof V1PayoutsBody
     */
    'confirm_automatically'?: boolean;
    /**
     * conversion rate
     * @type {number}
     * @memberof V1PayoutsBody
     */
    'converstion_rate'?: number;
    /**
     * Description of the payout transaction.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'description'?: string;
    /**
     * ID of the wallet that the money is transferred from. String starting with **ewallet_**.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'ewallet'?: string;
    /**
     * Determines the day the payout expires, in Unix time. The payout must be completed before the start of this day. Relevant to cash payouts.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'expiration'?: string;
    /**
     * Location of the payout transaction.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'location'?: string;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1PayoutsBody
     */
    'metadata'?: object;
    /**
     * Amount of the payout, in units of the currency defined in `payout_currency`. Mandatory when `sender_amount` is not used. Decimal.
     * @type {number}
     * @memberof V1PayoutsBody
     */
    'payout_amount': number;
    /**
     * 
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'payout_currency': string;
    /**
     * The type of payout method. The two-letter prefix must match the beneficiary country code. Required when the beneficiary does not have a default payout method type.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'payout_method_type'?: string;
    /**
     * Payout options
     * @type {object}
     * @memberof V1PayoutsBody
     */
    'payout_options'?: object;
    /**
     * String starting with **sender_** or the object describing the sender.
     * @type {string | Sender}
     * @memberof V1PayoutsBody
     */
    'sender': string | Sender;
    /**
     * Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. The two-letter prefix of the payout method type must match the beneficiary country code.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'sender_country': string;
    /**
     * 
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'sender_currency': string;
    /**
     * 
     * @type {EntityType}
     * @memberof V1PayoutsBody
     */
    'sender_entity_type': EntityType;
    /**
     * A statement that includes the reason for the payout. Limited to 35 characters.
     * @type {string}
     * @memberof V1PayoutsBody
     */
    'statement_descriptor'?: string;
}
/**
 * 
 * @export
 * @interface V1PlansBody
 */
export interface V1PlansBody {
    /**
     * Determines which quantity is used to calculate the pricing. Relevant when usage_type is metered. Default is sum.
     * @type {string}
     * @memberof V1PlansBody
     */
    'aggregate_usage'?: string;
    /**
     * The amount to charge in the billing cycle. For a free service, use 0. Relevant when billing_scheme is set to per_unit. When the billing_scheme is set to tiered, set the amount in the tiers array.
     * @type {number}
     * @memberof V1PlansBody
     */
    'amount'?: number;
    /**
     * Describes how to compute the price per billing period. One of the following values - per_unit, tiered
     * @type {string}
     * @memberof V1PlansBody
     */
    'billing_scheme'?: string;
    /**
     * Three-letter ISO 4217 code for the currency used in fields that represent monetary amounts. Uppercase.
     * @type {string}
     * @memberof V1PlansBody
     */
    'currency': string;
    /**
     * Unique ID for this payment plan. English alphanumeric characters and underscore. Limited to 44 characters. If the merchant does not define an ID, Rapyd generates a string starting with plan_.
     * @type {string}
     * @memberof V1PlansBody
     */
    'id'?: string;
    /**
     * Specifies the units used in defining the billing cycle.
     * @type {string}
     * @memberof V1PlansBody
     */
    'interval': string;
    /**
     * Number of intervals in the billing cycle. Default is 1.
     * @type {number}
     * @memberof V1PlansBody
     */
    'interval_count'?: number;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1PlansBody
     */
    'metadata'?: object;
    /**
     * Brief description of the pricing plan.
     * @type {string}
     * @memberof V1PlansBody
     */
    'nickname'?: string;
    /**
     * ID of the \'product\' object that this plan is for. The product must have type set to service.
     * @type {string}
     * @memberof V1PlansBody
     */
    'product': string;
    /**
     * Defines a tiered pricing structure. Array of objects. Must be null when billing_scheme is set to per_unit.
     * @type {string}
     * @memberof V1PlansBody
     */
    'tiers'?: string;
    /**
     * Determines the mode for calculating the total tiered charge.
     * @type {string}
     * @memberof V1PlansBody
     */
    'tiers_mode'?: string;
    /**
     * Defines the transformation that is applied to the reported usage before the billed price is computed.
     * @type {object}
     * @memberof V1PlansBody
     */
    'transform_usage'?: object;
    /**
     * Specifies the number of days before charges begin to accrue. Use this parameter to define a free trial period for a service.
     * @type {number}
     * @memberof V1PlansBody
     */
    'trial_period_days'?: number;
    /**
     * Determines whether the customer is billed when the service is not actually used. One of the following values - metered, licensed
     * @type {string}
     * @memberof V1PlansBody
     */
    'usage_type'?: string;
}
/**
 * 
 * @export
 * @interface V1ProductsBody
 */
export interface V1ProductsBody {
    /**
     * Indicates whether the product is currently available for purchase. Default is true.
     * @type {boolean}
     * @memberof V1ProductsBody
     */
    'active'?: boolean;
    /**
     * Array of up to 5 alphanumeric strings defined by the merchant. Each string defines the key in a key-value pair in the \'attributes\' object in the corresponding \'sku\' objects.
     * @type {Array<string>}
     * @memberof V1ProductsBody
     */
    'attributes'?: Array<string>;
    /**
     * Full text description of the product.
     * @type {string}
     * @memberof V1ProductsBody
     */
    'description'?: string;
    /**
     * Unique string for identification of the product. Legal input includes all the English alphanumeric characters and the underscore (_) character. If the merchant does not define an ID, Rapyd generates it with a string that starts with product_
     * @type {string}
     * @memberof V1ProductsBody
     */
    'id'?: string;
    /**
     * An array of images. Each image is a string in Base64 encoding.
     * @type {Array<string>}
     * @memberof V1ProductsBody
     */
    'images'?: Array<string>;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1ProductsBody
     */
    'metadata'?: object;
    /**
     * The name of the product or service that is displayed to the customer.
     * @type {string}
     * @memberof V1ProductsBody
     */
    'name': string;
    /**
     * 
     * @type {V1productsPackageDimensions}
     * @memberof V1ProductsBody
     */
    'package_dimensions'?: V1productsPackageDimensions;
    /**
     * Indicates whether the product is physically shipped to the customer. Relevant when type is goods. Default is false.
     * @type {boolean}
     * @memberof V1ProductsBody
     */
    'shippable'?: boolean;
    /**
     * A text description that appears in the customer\'s invoice. Limited to 22 characters. Relevant when type is service.
     * @type {string}
     * @memberof V1ProductsBody
     */
    'statement_descriptor'?: string;
    /**
     * One of the following - services, goods
     * @type {string}
     * @memberof V1ProductsBody
     */
    'type': V1ProductsBodyTypeEnum;
    /**
     * A label that represents units of this product, such as seats, on customers’ invoices. Relevant when type is service.
     * @type {string}
     * @memberof V1ProductsBody
     */
    'unit_label'?: string;
}

export const V1ProductsBodyTypeEnum = {
    Services: 'services',
    Goods: 'goods'
} as const;

export type V1ProductsBodyTypeEnum = typeof V1ProductsBodyTypeEnum[keyof typeof V1ProductsBodyTypeEnum];

/**
 * 
 * @export
 * @interface V1RefundsBody
 */
export interface V1RefundsBody {
    /**
     * The amount of the refund. Decimal.
     * @type {number}
     * @memberof V1RefundsBody
     */
    'amount'?: number;
    /**
     * The currency of the amount received by the original payment source. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof V1RefundsBody
     */
    'currency'?: string;
    /**
     * ID of the wallet contact that the card is assigned to. String starting with **cont_**.
     * @type {Array<string>}
     * @memberof V1RefundsBody
     */
    'ewallets'?: Array<string>;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof V1RefundsBody
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1RefundsBody
     */
    'metadata'?: object;
    /**
     * ID of the Payment object that the refund is charged against. String starting with **payment_**.
     * @type {string}
     * @memberof V1RefundsBody
     */
    'payment': string;
    /**
     * Description of the reason for the refund.
     * @type {string}
     * @memberof V1RefundsBody
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface V1SkusBody
 */
export interface V1SkusBody {
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof V1SkusBody
     */
    'currency': string;
    /**
     * 
     * @type {V1skusskuIdInventory}
     * @memberof V1SkusBody
     */
    'inventory': V1skusskuIdInventory;
    /**
     * The amount of the price. Decimal.
     * @type {number}
     * @memberof V1SkusBody
     */
    'price': number;
    /**
     * ID of the product that this SKU relates to. The type field of the product must be set to goods.
     * @type {string}
     * @memberof V1SkusBody
     */
    'product': string;
    /**
     * Indicates whether the product is currently available for purchase.
     * @type {boolean}
     * @memberof V1SkusBody
     */
    'active'?: boolean;
    /**
     * Array of alphanumeric key-value pairs defined by the merchant. Each key must match a string in the \"attributes\" list of the corresponding \"product\" object.
     * @type {Array<string>}
     * @memberof V1SkusBody
     */
    'attributes'?: Array<string>;
    /**
     * URL of image associated with the product.
     * @type {string}
     * @memberof V1SkusBody
     */
    'image'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1SkusBody
     */
    'metadata'?: object;
    /**
     * 
     * @type {V1skusskuIdPackageDimensions}
     * @memberof V1SkusBody
     */
    'package_dimensions'?: V1skusskuIdPackageDimensions;
}
/**
 * 
 * @export
 * @interface V1SubscriptionItemsBody
 */
export interface V1SubscriptionItemsBody {
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1SubscriptionItemsBody
     */
    'metadata'?: object;
    /**
     * ID of the plan assigned to this subscription item. Cannot be a plan that is already part of the subscription.
     * @type {string}
     * @memberof V1SubscriptionItemsBody
     */
    'plan': string;
    /**
     * Determines whether the charge is prorated when a subscription item is switched from one subscription to another in a billing cycle.
     * @type {boolean}
     * @memberof V1SubscriptionItemsBody
     */
    'prorate'?: boolean;
    /**
     * Indicates the date in the middle of the billing period that is the start of the prorated charges.
     * @type {number}
     * @memberof V1SubscriptionItemsBody
     */
    'proration_date'?: number;
    /**
     * The number of units of the service defined in the plan.
     * @type {number}
     * @memberof V1SubscriptionItemsBody
     */
    'quantity'?: number;
    /**
     * ID of the subscription that this item belongs to. String starting with **sub_**.
     * @type {string}
     * @memberof V1SubscriptionItemsBody
     */
    'subscription': string;
}
/**
 * 
 * @export
 * @interface V1VirtualAccountsBody
 */
export interface V1VirtualAccountsBody {
    /**
     * The country that the account number will be associated with. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @type {string}
     * @memberof V1VirtualAccountsBody
     */
    'country': string;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof V1VirtualAccountsBody
     */
    'currency': string;
    /**
     * Description of the account.
     * @type {string}
     * @memberof V1VirtualAccountsBody
     */
    'description'?: string;
    /**
     * ID of the wallet the bank account number is issued to. String starting with ewallet_.
     * @type {string}
     * @memberof V1VirtualAccountsBody
     */
    'ewallet': string;
    /**
     * ID of this account, as provided by the merchant. Limited to 45 characters.
     * @type {string}
     * @memberof V1VirtualAccountsBody
     */
    'merchant_reference_id'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1VirtualAccountsBody
     */
    'metadata'?: object;
    /**
     * *Currency received by the virtual account after conversion. Uppercase. One of the following: AUD - Australian Dollar EUR - Euro GBP - Pound Sterling HKD - Hong Kong Dollar SGD - Singapore Dollar USD - US Dollar When not specified, the funds appear in the walletâ€™s currency account for the currency of the transaction.*
     * @type {string}
     * @memberof V1VirtualAccountsBody
     */
    'requested_currency'?: string;
}
/**
 * Information about the merchant who is the subject of the query.
 * @export
 * @interface V1cnlterminationQueryQueriedMerchant
 */
export interface V1cnlterminationQueryQueriedMerchant {
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchantAddress}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'address'?: V1cnlterminationQueryQueriedMerchantAddress;
    /**
     * Business phone numbers of the merchant.<BR<Array of strings. Maximum - 2. Each string is a phone number in the format +[country code]/[phone number], where the forward slash (/) represents a separator between the country code and the telephone number.<BR>The plus sign before the country code is optional. The country code may only contain digits.<BR>The slash is required and must follow the country code.<BR>The telephone number may include blank spaces and hyphens (-).<BR>For example, in **+1/555 555-5555**, the country code is 1 and the telephone number is 5555555555.<BR>Length of each phone number: 8-15.
     * @type {object}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'phone_numbers'?: object;
    /**
     * The category of the merchant\'s business.
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'business_category'?: V1cnlterminationQueryQueriedMerchantBusinessCategoryEnum;
    /**
     * The \"doing business as\" name of the merchant.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 4-60
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'dba_name'?: string;
    /**
     * Merchant category codes of the merchant\'s business.<BR>Array of strings. Numbers or US letters. Maximum - 5 items. <BR>Length of each string: 4.
     * @type {object}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'mcc'?: object;
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchantPrincipals}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'principals'?: V1cnlterminationQueryQueriedMerchantPrincipals;
    /**
     * Indicates whether the merchant trades through the internet.
     * @type {boolean}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'is_ecommerce'?: boolean;
    /**
     * The family name of the owner.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 1-40
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'legal_name'?: string;
    /**
     * Web addresses associated with the merchant.<BR>Array of strings. Numbers or US letters. Maximum - 3 items. For example: [\"https://fourstarmarket.com\", \"https://fourstarmarket.net\"]<BR>Length: Maximum - 40
     * @type {object}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'url'?: object;
    /**
     * The primary email address of the owner.<BR>String that starts with a combination of letters, numbers, ., _, %, or - before an **@** sign. After the **@** sign, a domain name with letters, numbers, ., or -, ending with a dot and a 2 to 4 letter domain type, such as **.com**. For example: **davidsmith@snapphoto.com**<BR>Length: Maximum - 90
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchant
     */
    'email'?: string;
}

export const V1cnlterminationQueryQueriedMerchantBusinessCategoryEnum = {
    Merchant: 'Merchant',
    PaymentFacilitator: 'Payment Facilitator',
    IndependentSalesOrganization: 'Independent Sales Organization',
    Marketplace: 'Marketplace',
    StagedDigitalWalletOperator: 'Staged Digital Wallet Operator',
    SponsoredMerchant: 'Sponsored Merchant'
} as const;

export type V1cnlterminationQueryQueriedMerchantBusinessCategoryEnum = typeof V1cnlterminationQueryQueriedMerchantBusinessCategoryEnum[keyof typeof V1cnlterminationQueryQueriedMerchantBusinessCategoryEnum];

/**
 * Details of the merchant\'s business address.
 * @export
 * @interface V1cnlterminationQueryQueriedMerchantAddress
 */
export interface V1cnlterminationQueryQueriedMerchantAddress {
    /**
     * Line 1 of the address, such as a building number and street name.<BR>String with letters, numbers, numeric letters, and spaces. Applicable street details in this order: building number/name, street number and name, shop number, floor number.<BR>Length: 1-60
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantAddress
     */
    'address_line_1': string;
    /**
     * Line 2 of the address, such as a building number and street name.<BR>String with letters, numbers, numeric letters, and spaces.<BR>Length: 1-60
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantAddress
     */
    'address_line_2': string;
    /**
     * City portion of the address.<BR>String with letters, numbers, and spaces.<BR>Length: 1-20
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantAddress
     */
    'city': string;
    /**
     * Code for the country.<BR>The two-letter ISO 3166-1 ALPHA-2 country code.<BR>Length: 2
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantAddress
     */
    'country': string;
    /**
     * Postal code portion of the address.<BR>String with letters, numbers, and spaces.<BR>Length: 1-10
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantAddress
     */
    'postal_code'?: string;
}
/**
 * Details of the registered principal owners of the merchant.<BR> Maximum - 3.
 * @export
 * @interface V1cnlterminationQueryQueriedMerchantPrincipals
 */
export interface V1cnlterminationQueryQueriedMerchantPrincipals {
    /**
     * The first name of the owner.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 1-35
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipals
     */
    'first_name'?: string;
    /**
     * The initial letter of the owner\'s middle name.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: Maximum - 1
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipals
     */
    'middle_initial'?: string;
    /**
     * The family name of the owner.<BR>String that starts and ends with any combination of characters, whitespace, a specified range of Latin letters with diacritics, and a specific set of special characters.<BR>Length: 1-40
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipals
     */
    'last_name'?: string;
    /**
     * The primary email address of the merchant.<BR>String that starts with a combination of letters, numbers, ., _, %, or - before an **@** sign. After the **@** sign, a domain name with letters, numbers, ., or -, ending with a dot and a 2 to 4 letter domain type, such as **.com**. For example: **billsmith@snapphoto.com**<BR>Length: Maximum - 90
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipals
     */
    'email'?: string;
    /**
     * The phone number of the owner.<BR> Phone number in the format +[country code]/[phone number], where the forward slash (/) represents a separator between the country code and the telephone number.<BR>The plus sign before the country code is optional. The country code may only contain digits.<BR>The slash is required and must follow the country code.<BR>The telephone number may include blank spaces and hyphens (-).<BR>For example, in **+1/555 555-5555**, the country code is 1 and the telephone number is 5555555555.<BR>Length: 8-15
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipals
     */
    'phone_number'?: string;
    /**
     * 
     * @type {V1cnlterminationQueryQueriedMerchantPrincipalsAddress}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipals
     */
    'address'?: V1cnlterminationQueryQueriedMerchantPrincipalsAddress;
}
/**
 * Details of the owner\'s business address.
 * @export
 * @interface V1cnlterminationQueryQueriedMerchantPrincipalsAddress
 */
export interface V1cnlterminationQueryQueriedMerchantPrincipalsAddress {
    /**
     * Line 1 of the address, such as a building number and street name.<BR>String with letters, numbers, numeric letters, and spaces. Applicable street details in this order: building number/name, street number and name, shop number, floor number.<BR>Length: 1-60
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipalsAddress
     */
    'address_line_1'?: string;
    /**
     * Line 2 of the address, such as a building number and street name.<BR>String with letters, numbers, numeric letters, and spaces.<BR>Length: 1-60
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipalsAddress
     */
    'address_line_2'?: string;
    /**
     * City portion of the address.<BR>String with letters, numbers, and spaces.<BR>Length: 1-20
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipalsAddress
     */
    'city'?: string;
    /**
     * Code for the country.<BR>The two-letter ISO 3166-1 ALPHA-2 country code.<BR>Length: 2
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipalsAddress
     */
    'country'?: string;
    /**
     * Postal code portion of the address.<BR>String with letters, numbers, and spaces.<BR>Length: 1-10
     * @type {string}
     * @memberof V1cnlterminationQueryQueriedMerchantPrincipalsAddress
     */
    'postal_code'?: string;
}
/**
 * Specifies search criteria for the query.
 * @export
 * @interface V1cnlterminationQuerySearchCriteria
 */
export interface V1cnlterminationQuerySearchCriteria {
    /**
     * The geographic range of the query. One of the following:<BR>* **global** - The query is geographically unlimited.<BR>* **local** - The query is limited to the merchant\'s country.<BR>* **regional** - The query is limited to the merchant\'s region, such as APAC.
     * @type {string}
     * @memberof V1cnlterminationQuerySearchCriteria
     */
    'search_area'?: V1cnlterminationQuerySearchCriteriaSearchAreaEnum;
}

export const V1cnlterminationQuerySearchCriteriaSearchAreaEnum = {
    Global: 'global',
    Local: 'local',
    Regional: 'regional'
} as const;

export type V1cnlterminationQuerySearchCriteriaSearchAreaEnum = typeof V1cnlterminationQuerySearchCriteriaSearchAreaEnum[keyof typeof V1cnlterminationQuerySearchCriteriaSearchAreaEnum];

/**
 * 
 * @export
 * @interface V1ewalletsContact
 */
export interface V1ewalletsContact {
    /**
     * 
     * @type {Array<Contact>}
     * @memberof V1ewalletsContact
     */
    'data'?: Array<Contact>;
    /**
     * 
     * @type {number}
     * @memberof V1ewalletsContact
     */
    'total_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1ewalletsContact
     */
    'has_more'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1ewalletsContact
     */
    'url'?: string;
    /**
     * Rapyd Wallet ID defined by the customer or end user. Must be unique.
     * @type {string}
     * @memberof V1ewalletsContact
     */
    'ewallet_reference_id'?: string;
    /**
     * First name of the Rapyd Wallet owner.
     * @type {string}
     * @memberof V1ewalletsContact
     */
    'first_name'?: string;
    /**
     * Last name of the Rapyd Wallet owner.
     * @type {string}
     * @memberof V1ewalletsContact
     */
    'last_name'?: string;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof V1ewalletsContact
     */
    'metadata'?: object;
    /**
     * Type of wallet, company or person. Default is person.
     * @type {string}
     * @memberof V1ewalletsContact
     */
    'type'?: string;
    /**
     * Phone number of the Rapyd Wallet owner.
     * @type {string}
     * @memberof V1ewalletsContact
     */
    'phone_number'?: string;
}
/**
 * Contains details about the card.
 * @export
 * @interface V1hostedcollectcardCardFields
 */
export interface V1hostedcollectcardCardFields {
    /**
     * Specifies the primary intended purpose of the saved payment method. See Saving a European Card While Creating a Payment. One of the following values: <BR> * **installment** - Regular payments for a defined number of payment cycles. <BR> * **recurring** - Regular payments for an indefinite period. <BR> * **unscheduled** - Individual unrelated payments.
     * @type {string}
     * @memberof V1hostedcollectcardCardFields
     */
    'recurrence_type'?: string;
}
/**
 * 
 * @export
 * @interface V1hosteddisbursebeneficiaryBeneficiaryOptionalFields
 */
export interface V1hosteddisbursebeneficiaryBeneficiaryOptionalFields {
    /**
     * The name of the beneficiary\'s company. Relevant to beneficiaries that are not individuals. If the request does not contain this information, the hosted page prompts the customer for it. <BR> If `beneficiary_entity_type` is **individual**, this field must be omitted.
     * @type {string}
     * @memberof V1hosteddisbursebeneficiaryBeneficiaryOptionalFields
     */
    'company_name'?: string;
    /**
     * The first name of the beneficiary. Relevant to individual beneficiaries. If the request does not contain this information, the redirect page prompts the customer for it.
     * @type {string}
     * @memberof V1hosteddisbursebeneficiaryBeneficiaryOptionalFields
     */
    'first_name'?: string;
    /**
     * Type of identification document. When `entity_type` is **company**, this field must be **company_registered_number**. When `entity_type` is **individual**, one of the following values: <BR> * **drivers_license**<BR> * **identification_id** <BR> * **international_passport** <BR> * **residence_permit**<BR> * **social_security**<BR> * **work_permit** type: string
     * @type {any}
     * @memberof V1hosteddisbursebeneficiaryBeneficiaryOptionalFields
     */
    'identification_type': any;
    /**
     * The identification of the document mentioned in identification_type.
     * @type {string}
     * @memberof V1hosteddisbursebeneficiaryBeneficiaryOptionalFields
     */
    'identification_value': string;
    /**
     * The last name of the beneficiary. Relevant to individual beneficiaries. If the request does not contain this information, the redirect page prompts the customer for it.
     * @type {string}
     * @memberof V1hosteddisbursebeneficiaryBeneficiaryOptionalFields
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface V1ordersItems
 */
export interface V1ordersItems {
    /**
     * Price of one SKU unit, in the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @type {string}
     * @memberof V1ordersItems
     */
    'amount'?: string;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof V1ordersItems
     */
    'currency'?: string;
    /**
     * Description of the item.
     * @type {string}
     * @memberof V1ordersItems
     */
    'description'?: string;
    /**
     * ID of the SKU object that represents the product. String starting with sku_. Each SKU can appear in this list only one time, for items of type \'sku\'. Required when type is sku. Must be null when type is shipping.
     * @type {string}
     * @memberof V1ordersItems
     */
    'parent'?: string;
    /**
     * Type of line item.
     * @type {string}
     * @memberof V1ordersItems
     */
    'type'?: V1ordersItemsTypeEnum;
    /**
     * Quantity of the product in the line item. Integer. Required when type is sku.
     * @type {number}
     * @memberof V1ordersItems
     */
    'quantity'?: number;
}

export const V1ordersItemsTypeEnum = {
    Shipping: 'shipping',
    Sku: 'sku'
} as const;

export type V1ordersItemsTypeEnum = typeof V1ordersItemsTypeEnum[keyof typeof V1ordersItemsTypeEnum];

/**
 * 
 * @export
 * @interface V1ordersorderIdreturnsItems
 */
export interface V1ordersorderIdreturnsItems {
    /**
     * 
     * @type {string}
     * @memberof V1ordersorderIdreturnsItems
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ordersorderIdreturnsItems
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ordersorderIdreturnsItems
     */
    'type'?: V1ordersorderIdreturnsItemsTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V1ordersorderIdreturnsItems
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1ordersorderIdreturnsItems
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ordersorderIdreturnsItems
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1ordersorderIdreturnsItems
     */
    'order_id'?: string;
}

export const V1ordersorderIdreturnsItemsTypeEnum = {
    Sku: 'sku',
    Shipping: 'shipping',
    Tax: 'tax'
} as const;

export type V1ordersorderIdreturnsItemsTypeEnum = typeof V1ordersorderIdreturnsItemsTypeEnum[keyof typeof V1ordersorderIdreturnsItemsTypeEnum];

/**
 * 
 * @export
 * @interface V1paymentssubscriptionsSubscriptionItems
 */
export interface V1paymentssubscriptionsSubscriptionItems {
    /**
     * ID of the plan assigned to this subscription item.
     * @type {string}
     * @memberof V1paymentssubscriptionsSubscriptionItems
     */
    'plan'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1paymentssubscriptionsSubscriptionItems
     */
    'quantity'?: number;
}
/**
 * Describes the physical size and weight of the product. Relevant when type is goods.
 * @export
 * @interface V1productsPackageDimensions
 */
export interface V1productsPackageDimensions {
    /**
     * 
     * @type {number}
     * @memberof V1productsPackageDimensions
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1productsPackageDimensions
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1productsPackageDimensions
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1productsPackageDimensions
     */
    'width'?: number;
}
/**
 * inventory object {quantity, type, value}
 * @export
 * @interface V1skusskuIdInventory
 */
export interface V1skusskuIdInventory {
    /**
     * 
     * @type {string}
     * @memberof V1skusskuIdInventory
     */
    'type'?: V1skusskuIdInventoryTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V1skusskuIdInventory
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1skusskuIdInventory
     */
    'value'?: V1skusskuIdInventoryValueEnum;
}

export const V1skusskuIdInventoryTypeEnum = {
    Finite: 'finite',
    Infinite: 'infinite',
    Bucket: 'bucket'
} as const;

export type V1skusskuIdInventoryTypeEnum = typeof V1skusskuIdInventoryTypeEnum[keyof typeof V1skusskuIdInventoryTypeEnum];
export const V1skusskuIdInventoryValueEnum = {
    InStock: 'in_stock',
    Limited: 'limited',
    OutOfStock: 'out_of_stock'
} as const;

export type V1skusskuIdInventoryValueEnum = typeof V1skusskuIdInventoryValueEnum[keyof typeof V1skusskuIdInventoryValueEnum];

/**
 * Physical attributes of the SKU item. Object containing the following fields - height, length, weight, width
 * @export
 * @interface V1skusskuIdPackageDimensions
 */
export interface V1skusskuIdPackageDimensions {
    /**
     * 
     * @type {number}
     * @memberof V1skusskuIdPackageDimensions
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1skusskuIdPackageDimensions
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1skusskuIdPackageDimensions
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1skusskuIdPackageDimensions
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface VerifyHostedAppResponse
 */
export interface VerifyHostedAppResponse {
    /**
     * Identifier of the hosted application. String starting with happ_.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'token'?: string;
    /**
     * The ID of the Rapyd wallet of the company. String starting with ewallet_. Must be a company type wallet.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'rapyd_entity_token'?: string;
    /**
     * URL where the customer is redirected after pressing Back to Website to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'cancel_url'?: string;
    /**
     * URL where the customer is redirected after pressing Close to exit the hosted page. This URL overrides the merchant_website URL. Does not support localhost URLs.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'complete_url'?: string;
    /**
     * ID defined by the client. Limited to 255 characters.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'client_reference_id'?: string;
    /**
     * Identifier of the application. String starting with app_.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'application_token'?: string;
    /**
     * The phone number of the applicant. This is the phone number where an authentication code is sent. Must have a leading plus sign (+).
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'phone_number'?: string;
    /**
     * 
     * @type {VerifyHostedAppResponseMerchantDetails}
     * @memberof VerifyHostedAppResponse
     */
    'merchant_details'?: VerifyHostedAppResponseMerchantDetails;
    /**
     * URL of the hosted page that is shown to the customer.
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'redirect_url'?: string;
    /**
     * A JSON object defined by the client
     * @type {object}
     * @memberof VerifyHostedAppResponse
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponse
     */
    'authorized_user_email'?: string;
}
/**
 * Object containing information about the merchant.
 * @export
 * @interface VerifyHostedAppResponseMerchantDetails
 */
export interface VerifyHostedAppResponseMerchantDetails {
    /**
     * The name that appears on the hosted page when merchant_logo is not specified. To change this value, contact Client Support. Response only.
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_alias'?: string;
    /**
     * Determines the default language of the application page.  The values are documented in List Hosted Page Supported Languages. 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_language'?: string;
    /**
     * URL for the image of the client\'s logo. Response only. To configure this feature, use the Client Portal.
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_logo'?: string;
    /**
     * The URL where the customer is redirected after exiting the hosted page.
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_website'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_design'?: string;
    /**
     * 
     * @type {VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_customer_support'?: VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_terms'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetails
     */
    'merchant_privacy_policy'?: string;
}
/**
 * 
 * @export
 * @interface VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport
 */
export interface VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport {
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyHostedAppResponseMerchantDetailsMerchantCustomerSupport
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountIssuing
 */
export interface VirtualAccountIssuing {
    /**
     * ID of the virtual account number object. String starting with issuing_.
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'id'?: string;
    /**
     * Identifier defined by the client for reference purposes. Limit - 45 characters.
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'merchant_reference_id'?: string;
    /**
     * ID of the Rapyd Wallet that the virtual account is attached to. String starting with ewallet_.
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'ewallet'?: string;
    /**
     * Details about the virtual account.
     * @type {object}
     * @memberof VirtualAccountIssuing
     */
    'bank_account'?: object | null;
    /**
     * A JSON object defined by the client.
     * @type {object}
     * @memberof VirtualAccountIssuing
     */
    'metadata'?: object;
    /**
     * Indicates the status of the virtual account. * ACT (Active) * CLO (Closed)  * ERR (Error)  * PEN (Pending)  * REJ (REjected)  * DIS  * ENA 
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'status'?: VirtualAccountIssuingStatusEnum;
    /**
     * Description of the transaction, as defined by the client.
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'description'?: string;
    /**
     * Issuied virtual account funding instructions.
     * @type {object}
     * @memberof VirtualAccountIssuing
     */
    'funding_instructions'?: object | null;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'currency'?: string;
    /**
     * Currency received by the virtual account after conversion. One of the following: AUD - Australian Dollar EUR - Euro GBP - Pound Sterling HKD - Hong Kong Dollar SGD - Singapore Dollar USD - US Dollar 
     * @type {string}
     * @memberof VirtualAccountIssuing
     */
    'requested_currency'?: string;
    /**
     * Issuied virtual account transactions.
     * @type {Array<VirtualAccountTransactionResponse>}
     * @memberof VirtualAccountIssuing
     */
    'transactions'?: Array<VirtualAccountTransactionResponse>;
}

export const VirtualAccountIssuingStatusEnum = {
    Act: 'ACT',
    Clo: 'CLO',
    Err: 'ERR',
    Pen: 'PEN',
    Rej: 'REJ',
    Dis: 'DIS',
    Ena: 'ENA'
} as const;

export type VirtualAccountIssuingStatusEnum = typeof VirtualAccountIssuingStatusEnum[keyof typeof VirtualAccountIssuingStatusEnum];

/**
 * virtual account transaction.
 * @export
 * @interface VirtualAccountTransactionResponse
 */
export interface VirtualAccountTransactionResponse {
    /**
     * The amount sent by the sender to the virtual account, in units of the currency defined in original_currency.
     * @type {number}
     * @memberof VirtualAccountTransactionResponse
     */
    'original_amount'?: number;
    /**
     * In transactions without FX, defines the currency of the transaction. Three-letter ISO 4217 code.<BR> In FX transactions:<BR> * When `fixed_side` is **buy**, it is the currency received in the Rapyd wallet.<BR> * When `fixed_side` is **sell**, it is the currency charged to the buyer.
     * @type {string}
     * @memberof VirtualAccountTransactionResponse
     */
    'original_currency'?: string;
    /**
     * Currency conversion rate for the transaction.
     * @type {number}
     * @memberof VirtualAccountTransactionResponse
     */
    'fx_rate'?: number;
    /**
     * ID of the virtual bank account.
     * @type {string}
     * @memberof VirtualAccountTransactionResponse
     */
    'account_id'?: string;
    /**
     * Type of the virtual account number.
     * @type {string}
     * @memberof VirtualAccountTransactionResponse
     */
    'account_id_type'?: string;
    /**
     * Amount of the transaction, in units defined in currency.
     * @type {number}
     * @memberof VirtualAccountTransactionResponse
     */
    'amount'?: number;
    /**
     * Timestamp for the transaction, in Unix time
     * @type {number}
     * @memberof VirtualAccountTransactionResponse
     */
    'created_at'?: number;
    /**
     * Currency of the account. Three-letter ISO 4217 code.
     * @type {string}
     * @memberof VirtualAccountTransactionResponse
     */
    'currency'?: string;
    /**
     * ID of the Rapyd Wallet that is attached to the virtual account. String starting with ewallet_.
     * @type {string}
     * @memberof VirtualAccountTransactionResponse
     */
    'ewallet'?: string;
    /**
     * ID of the transaction. String starting with isutran_.
     * @type {string}
     * @memberof VirtualAccountTransactionResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountsTransactionsBody
 */
export interface VirtualAccountsTransactionsBody {
    /**
     * The amount of the transaction, in units of the currency defined in currency. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015. If the amount is a whole number, use an integer and not a decimal.
     * @type {string}
     * @memberof VirtualAccountsTransactionsBody
     */
    'amount': string;
    /**
     * Currency of the transaction. Three-letter ISO 4217 code. Must be the same as the currency of the virtual account.
     * @type {string}
     * @memberof VirtualAccountsTransactionsBody
     */
    'currency': string;
    /**
     * ID of the Virtual Account Number object. String starting with issuing_
     * @type {string}
     * @memberof VirtualAccountsTransactionsBody
     */
    'issued_bank_account': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountsVirtualAccountIdBody
 */
export interface VirtualAccountsVirtualAccountIdBody {
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountsVirtualAccountIdBody
     */
    'requesting_currency'?: string;
}

/**
 * CardNetworkLookupServiceApi - axios parameter creator
 * @export
 */
export const CardNetworkLookupServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
         * @summary Initiate Merchant Query
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CnlTerminationQueryBody} cnlTerminationQueryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateMerchantQuery: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cnlTerminationQueryBody: CnlTerminationQueryBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('initiateMerchantQuery', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('initiateMerchantQuery', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('initiateMerchantQuery', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('initiateMerchantQuery', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('initiateMerchantQuery', 'timestamp', timestamp)
            // verify required parameter 'cnlTerminationQueryBody' is not null or undefined
            assertParamExists('initiateMerchantQuery', 'cnlTerminationQueryBody', cnlTerminationQueryBody)
            const localVarPath = `/v1/cnl/termination_query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cnlTerminationQueryBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
         * @summary Retrieve Query Results
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} partnerQueryReference Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveQueryResults: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, partnerQueryReference: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveQueryResults', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveQueryResults', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveQueryResults', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveQueryResults', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveQueryResults', 'timestamp', timestamp)
            // verify required parameter 'partnerQueryReference' is not null or undefined
            assertParamExists('retrieveQueryResults', 'partnerQueryReference', partnerQueryReference)
            const localVarPath = `/v1/cnl/termination_query/{partner_query_reference}`
                .replace(`{${"partner_query_reference"}}`, encodeURIComponent(String(partnerQueryReference)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardNetworkLookupServiceApi - functional programming interface
 * @export
 */
export const CardNetworkLookupServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardNetworkLookupServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
         * @summary Initiate Merchant Query
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CnlTerminationQueryBody} cnlTerminationQueryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateMerchantQuery(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cnlTerminationQueryBody: CnlTerminationQueryBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200118>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateMerchantQuery(accessKey, contentType, salt, signature, timestamp, cnlTerminationQueryBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardNetworkLookupServiceApi.initiateMerchantQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
         * @summary Retrieve Query Results
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} partnerQueryReference Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveQueryResults(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, partnerQueryReference: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200119>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveQueryResults(accessKey, contentType, salt, signature, timestamp, partnerQueryReference, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardNetworkLookupServiceApi.retrieveQueryResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardNetworkLookupServiceApi - factory interface
 * @export
 */
export const CardNetworkLookupServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardNetworkLookupServiceApiFp(configuration)
    return {
        /**
         * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
         * @summary Initiate Merchant Query
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CnlTerminationQueryBody} cnlTerminationQueryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateMerchantQuery(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cnlTerminationQueryBody: CnlTerminationQueryBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200118> {
            return localVarFp.initiateMerchantQuery(accessKey, contentType, salt, signature, timestamp, cnlTerminationQueryBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
         * @summary Retrieve Query Results
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} partnerQueryReference Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveQueryResults(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, partnerQueryReference: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200119> {
            return localVarFp.retrieveQueryResults(accessKey, contentType, salt, signature, timestamp, partnerQueryReference, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardNetworkLookupServiceApi - object-oriented interface
 * @export
 * @class CardNetworkLookupServiceApi
 * @extends {BaseAPI}
 */
export class CardNetworkLookupServiceApi extends BaseAPI {
    /**
     * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
     * @summary Initiate Merchant Query
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CnlTerminationQueryBody} cnlTerminationQueryBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardNetworkLookupServiceApi
     */
    public initiateMerchantQuery(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cnlTerminationQueryBody: CnlTerminationQueryBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CardNetworkLookupServiceApiFp(this.configuration).initiateMerchantQuery(accessKey, contentType, salt, signature, timestamp, cnlTerminationQueryBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit information about a merchant to begin the process of querying the merchant history in the databases of the card networks.<BR>This method validates the data in your request.<BR>This is the first step in the process of querying the card networks about a potential new merchant. When this step is completed successfully, proceed to \'Retrieve Query Results\'.
     * @summary Retrieve Query Results
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} partnerQueryReference Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardNetworkLookupServiceApi
     */
    public retrieveQueryResults(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, partnerQueryReference: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CardNetworkLookupServiceApiFp(this.configuration).retrieveQueryResults(accessKey, contentType, salt, signature, timestamp, partnerQueryReference, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CheckoutPageApi - axios parameter creator
 * @export
 */
export const CheckoutPageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a checkout page that makes a payment.
         * @summary Create checkout page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1CheckoutBody} [v1CheckoutBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateHostedPagePayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1CheckoutBody?: V1CheckoutBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('generateHostedPagePayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('generateHostedPagePayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('generateHostedPagePayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('generateHostedPagePayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('generateHostedPagePayment', 'timestamp', timestamp)
            const localVarPath = `/v1/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1CheckoutBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a checkout page.
         * @summary Retrieve checkout page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} checkoutToken ID of the checkout page. String starting with **checkout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedPagePayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, checkoutToken: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getHostedPagePayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getHostedPagePayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getHostedPagePayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getHostedPagePayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getHostedPagePayment', 'timestamp', timestamp)
            // verify required parameter 'checkoutToken' is not null or undefined
            assertParamExists('getHostedPagePayment', 'checkoutToken', checkoutToken)
            const localVarPath = `/v1/checkout/{checkout_token}`
                .replace(`{${"checkout_token"}}`, encodeURIComponent(String(checkoutToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutPageApi - functional programming interface
 * @export
 */
export const CheckoutPageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutPageApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a checkout page that makes a payment.
         * @summary Create checkout page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1CheckoutBody} [v1CheckoutBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateHostedPagePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1CheckoutBody?: V1CheckoutBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateHostedPagePayment(accessKey, contentType, salt, signature, timestamp, idempotency, v1CheckoutBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutPageApi.generateHostedPagePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a checkout page.
         * @summary Retrieve checkout page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} checkoutToken ID of the checkout page. String starting with **checkout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHostedPagePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, checkoutToken: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHostedPagePayment(accessKey, contentType, salt, signature, timestamp, checkoutToken, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutPageApi.getHostedPagePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckoutPageApi - factory interface
 * @export
 */
export const CheckoutPageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutPageApiFp(configuration)
    return {
        /**
         * Create a checkout page that makes a payment.
         * @summary Create checkout page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1CheckoutBody} [v1CheckoutBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateHostedPagePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1CheckoutBody?: V1CheckoutBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2004> {
            return localVarFp.generateHostedPagePayment(accessKey, contentType, salt, signature, timestamp, idempotency, v1CheckoutBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a checkout page.
         * @summary Retrieve checkout page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} checkoutToken ID of the checkout page. String starting with **checkout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedPagePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, checkoutToken: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2004> {
            return localVarFp.getHostedPagePayment(accessKey, contentType, salt, signature, timestamp, checkoutToken, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutPageApi - object-oriented interface
 * @export
 * @class CheckoutPageApi
 * @extends {BaseAPI}
 */
export class CheckoutPageApi extends BaseAPI {
    /**
     * Create a checkout page that makes a payment.
     * @summary Create checkout page
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {V1CheckoutBody} [v1CheckoutBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutPageApi
     */
    public generateHostedPagePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1CheckoutBody?: V1CheckoutBody, options?: RawAxiosRequestConfig) {
        return CheckoutPageApiFp(this.configuration).generateHostedPagePayment(accessKey, contentType, salt, signature, timestamp, idempotency, v1CheckoutBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a checkout page.
     * @summary Retrieve checkout page
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} checkoutToken ID of the checkout page. String starting with **checkout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutPageApi
     */
    public getHostedPagePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, checkoutToken: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CheckoutPageApiFp(this.configuration).getHostedPagePayment(accessKey, contentType, salt, signature, timestamp, checkoutToken, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CouponApi - axios parameter creator
 * @export
 */
export const CouponApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a coupon
         * @summary Create new coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {Coupon | null} coupon Coupon to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoupon: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, coupon: Coupon | null, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createCoupon', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createCoupon', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createCoupon', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createCoupon', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCoupon', 'timestamp', timestamp)
            // verify required parameter 'coupon' is not null or undefined
            assertParamExists('createCoupon', 'coupon', coupon)
            const localVarPath = `/v1/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coupon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a coupon from the Rapyd platform. Deleting a coupon removes it from all customers and subscriptions, but does not affect invoices and payment authorizations that have already been calculated.
         * @summary Delete coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId Coupon ID. String starting with **coupon_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteCoupon', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteCoupon', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteCoupon', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteCoupon', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCoupon', 'timestamp', timestamp)
            // verify required parameter 'couponId' is not null or undefined
            assertParamExists('deleteCoupon', 'couponId', couponId)
            const localVarPath = `/v1/coupons/{couponId}`
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all coupons.
         * @summary Retrieve list of coupons
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve.
         * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to       retrieve.
         * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoupon: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listCoupon', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listCoupon', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listCoupon', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listCoupon', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listCoupon', 'timestamp', timestamp)
            const localVarPath = `/v1/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a coupon
         * @summary Retrieve coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId coupon ID. String starting with **coupon_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCoupon: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveCoupon', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveCoupon', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveCoupon', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveCoupon', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveCoupon', 'timestamp', timestamp)
            // verify required parameter 'couponId' is not null or undefined
            assertParamExists('retrieveCoupon', 'couponId', couponId)
            const localVarPath = `/v1/coupons/{couponId}`
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the metadata of a coupon with a coupon ID in Path
         * @summary Update coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId coupon ID. String starting with **coupon_**.
         * @param {Coupon | null} coupon Coupon to add.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, coupon: Coupon | null, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateCoupon', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateCoupon', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateCoupon', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateCoupon', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateCoupon', 'timestamp', timestamp)
            // verify required parameter 'couponId' is not null or undefined
            assertParamExists('updateCoupon', 'couponId', couponId)
            // verify required parameter 'coupon' is not null or undefined
            assertParamExists('updateCoupon', 'coupon', coupon)
            const localVarPath = `/v1/coupons/{couponId}`
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coupon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponApi - functional programming interface
 * @export
 */
export const CouponApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponApiAxiosParamCreator(configuration)
    return {
        /**
         * create a coupon
         * @summary Create new coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {Coupon | null} coupon Coupon to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, coupon: Coupon | null, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCoupon(accessKey, contentType, salt, signature, timestamp, coupon, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponApi.createCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a coupon from the Rapyd platform. Deleting a coupon removes it from all customers and subscriptions, but does not affect invoices and payment authorizations that have already been calculated.
         * @summary Delete coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId Coupon ID. String starting with **coupon_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCoupon(accessKey, contentType, salt, signature, timestamp, couponId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponApi.deleteCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all coupons.
         * @summary Retrieve list of coupons
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve.
         * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to       retrieve.
         * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCoupon(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponApi.listCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a coupon
         * @summary Retrieve coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId coupon ID. String starting with **coupon_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCoupon(accessKey, contentType, salt, signature, timestamp, couponId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponApi.retrieveCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify the metadata of a coupon with a coupon ID in Path
         * @summary Update coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId coupon ID. String starting with **coupon_**.
         * @param {Coupon | null} coupon Coupon to add.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, coupon: Coupon | null, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCoupon(accessKey, contentType, salt, signature, timestamp, couponId, coupon, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponApi.updateCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CouponApi - factory interface
 * @export
 */
export const CouponApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponApiFp(configuration)
    return {
        /**
         * create a coupon
         * @summary Create new coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {Coupon | null} coupon Coupon to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, coupon: Coupon | null, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20051> {
            return localVarFp.createCoupon(accessKey, contentType, salt, signature, timestamp, coupon, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a coupon from the Rapyd platform. Deleting a coupon removes it from all customers and subscriptions, but does not affect invoices and payment authorizations that have already been calculated.
         * @summary Delete coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId Coupon ID. String starting with **coupon_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20052> {
            return localVarFp.deleteCoupon(accessKey, contentType, salt, signature, timestamp, couponId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all coupons.
         * @summary Retrieve list of coupons
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve.
         * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to       retrieve.
         * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20050> {
            return localVarFp.listCoupon(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a coupon
         * @summary Retrieve coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId coupon ID. String starting with **coupon_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20051> {
            return localVarFp.retrieveCoupon(accessKey, contentType, salt, signature, timestamp, couponId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify the metadata of a coupon with a coupon ID in Path
         * @summary Update coupon
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} couponId coupon ID. String starting with **coupon_**.
         * @param {Coupon | null} coupon Coupon to add.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, coupon: Coupon | null, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20051> {
            return localVarFp.updateCoupon(accessKey, contentType, salt, signature, timestamp, couponId, coupon, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponApi - object-oriented interface
 * @export
 * @class CouponApi
 * @extends {BaseAPI}
 */
export class CouponApi extends BaseAPI {
    /**
     * create a coupon
     * @summary Create new coupon
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {Coupon | null} coupon Coupon to add
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public createCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, coupon: Coupon | null, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CouponApiFp(this.configuration).createCoupon(accessKey, contentType, salt, signature, timestamp, coupon, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a coupon from the Rapyd platform. Deleting a coupon removes it from all customers and subscriptions, but does not affect invoices and payment authorizations that have already been calculated.
     * @summary Delete coupon
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} couponId Coupon ID. String starting with **coupon_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public deleteCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CouponApiFp(this.configuration).deleteCoupon(accessKey, contentType, salt, signature, timestamp, couponId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all coupons.
     * @summary Retrieve list of coupons
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve.
     * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to       retrieve.
     * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public listCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CouponApiFp(this.configuration).listCoupon(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a coupon
     * @summary Retrieve coupon
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} couponId coupon ID. String starting with **coupon_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public retrieveCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CouponApiFp(this.configuration).retrieveCoupon(accessKey, contentType, salt, signature, timestamp, couponId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify the metadata of a coupon with a coupon ID in Path
     * @summary Update coupon
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} couponId coupon ID. String starting with **coupon_**.
     * @param {Coupon | null} coupon Coupon to add.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public updateCoupon(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, couponId: string, coupon: Coupon | null, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CouponApiFp(this.configuration).updateCoupon(accessKey, contentType, salt, signature, timestamp, couponId, coupon, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a customer to the client.
         * @summary Create customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1CustomersBody} v1CustomersBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1CustomersBody: V1CustomersBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createCustomer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createCustomer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createCustomer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createCustomer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCustomer', 'timestamp', timestamp)
            // verify required parameter 'v1CustomersBody' is not null or undefined
            assertParamExists('createCustomer', 'v1CustomersBody', v1CustomersBody)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1CustomersBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method triggers the Customer Deleted webhook. This webhook contains the same information as the response
         * @summary Delete customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteCustomer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteCustomer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteCustomer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteCustomer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCustomer', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/v1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the discount that has been assigned to a customer through a coupon. This action does not affect the coupon that the discount was derived from. This method triggers the **Customer Discount Deleted** webhook.
         * @summary Remove discount
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerDiscount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteCustomerDiscount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteCustomerDiscount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteCustomerDiscount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteCustomerDiscount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCustomerDiscount', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomerDiscount', 'customerId', customerId)
            const localVarPath = `/v1/customers/{customerId}/discount`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a discount for a customer.
         * @summary Retrieve discount of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} discountId discount Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDiscountById: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCustomerDiscountById', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCustomerDiscountById', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCustomerDiscountById', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCustomerDiscountById', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCustomerDiscountById', 'timestamp', timestamp)
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('getCustomerDiscountById', 'discountId', discountId)
            const localVarPath = `/v1/customers/discount/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all customers
         * @summary Retrieves list of customers.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the customer created before the first customer you want to retrieve
         * @param {string} [endingBefore] The ID of the customer created after the last customer you want to retrieve
         * @param {string} [limit] The maximum number of customers to return. Range is 1-100. Default is 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listCustomer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listCustomer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listCustomer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listCustomer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listCustomer', 'timestamp', timestamp)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a customer.
         * @summary Retrieve customer details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveCustomer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveCustomer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveCustomer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveCustomer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveCustomer', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('retrieveCustomer', 'customerId', customerId)
            const localVarPath = `/v1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer with customer Id in Path
         * @summary Update customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CustomerRequest} [customerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, customerRequest?: CustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateCustomer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateCustomer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateCustomer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateCustomer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateCustomer', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            const localVarPath = `/v1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a customer to the client.
         * @summary Create customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1CustomersBody} v1CustomersBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1CustomersBody: V1CustomersBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(accessKey, contentType, salt, signature, timestamp, v1CustomersBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.createCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method triggers the Customer Deleted webhook. This webhook contains the same information as the response
         * @summary Delete customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.deleteCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the discount that has been assigned to a customer through a coupon. This action does not affect the coupon that the discount was derived from. This method triggers the **Customer Discount Deleted** webhook.
         * @summary Remove discount
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerDiscount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerDiscount(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.deleteCustomerDiscount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a discount for a customer.
         * @summary Retrieve discount of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} discountId discount Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerDiscountById(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerDiscountById(accessKey, contentType, salt, signature, timestamp, discountId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.getCustomerDiscountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all customers
         * @summary Retrieves list of customers.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the customer created before the first customer you want to retrieve
         * @param {string} [endingBefore] The ID of the customer created after the last customer you want to retrieve
         * @param {string} [limit] The maximum number of customers to return. Range is 1-100. Default is 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomer(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.listCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a customer.
         * @summary Retrieve customer details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.retrieveCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a customer with customer Id in Path
         * @summary Update customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CustomerRequest} [customerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, customerRequest?: CustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, customerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.updateCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * Adds a customer to the client.
         * @summary Create customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1CustomersBody} v1CustomersBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1CustomersBody: V1CustomersBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20037> {
            return localVarFp.createCustomer(accessKey, contentType, salt, signature, timestamp, v1CustomersBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * This method triggers the Customer Deleted webhook. This webhook contains the same information as the response
         * @summary Delete customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20023> {
            return localVarFp.deleteCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the discount that has been assigned to a customer through a coupon. This action does not affect the coupon that the discount was derived from. This method triggers the **Customer Discount Deleted** webhook.
         * @summary Remove discount
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerDiscount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20039> {
            return localVarFp.deleteCustomerDiscount(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a discount for a customer.
         * @summary Retrieve discount of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} discountId discount Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDiscountById(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20038> {
            return localVarFp.getCustomerDiscountById(accessKey, contentType, salt, signature, timestamp, discountId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all customers
         * @summary Retrieves list of customers.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the customer created before the first customer you want to retrieve
         * @param {string} [endingBefore] The ID of the customer created after the last customer you want to retrieve
         * @param {string} [limit] The maximum number of customers to return. Range is 1-100. Default is 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20036> {
            return localVarFp.listCustomer(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a customer.
         * @summary Retrieve customer details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20037> {
            return localVarFp.retrieveCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer with customer Id in Path
         * @summary Update customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CustomerRequest} [customerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, customerRequest?: CustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20037> {
            return localVarFp.updateCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, customerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * Adds a customer to the client.
     * @summary Create customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1CustomersBody} v1CustomersBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public createCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1CustomersBody: V1CustomersBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).createCustomer(accessKey, contentType, salt, signature, timestamp, v1CustomersBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method triggers the Customer Deleted webhook. This webhook contains the same information as the response
     * @summary Delete customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public deleteCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).deleteCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the discount that has been assigned to a customer through a coupon. This action does not affect the coupon that the discount was derived from. This method triggers the **Customer Discount Deleted** webhook.
     * @summary Remove discount
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public deleteCustomerDiscount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).deleteCustomerDiscount(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a discount for a customer.
     * @summary Retrieve discount of customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} discountId discount Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomerDiscountById(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).getCustomerDiscountById(accessKey, contentType, salt, signature, timestamp, discountId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all customers
     * @summary Retrieves list of customers.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [startingAfter] The ID of the customer created before the first customer you want to retrieve
     * @param {string} [endingBefore] The ID of the customer created after the last customer you want to retrieve
     * @param {string} [limit] The maximum number of customers to return. Range is 1-100. Default is 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public listCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).listCustomer(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a customer.
     * @summary Retrieve customer details
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public retrieveCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).retrieveCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a customer with customer Id in Path
     * @summary Update customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {CustomerRequest} [customerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public updateCustomer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, customerRequest?: CustomerRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).updateCustomer(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, customerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerPaymentMethodApi - axios parameter creator
 * @export
 */
export const CustomerPaymentMethodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a payment method to a customer profile
         * @summary Add payment method to customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {CustomerIdPaymentMethodsBody} customerIdPaymentMethodsBody customer to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPaymentMethod: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, customerIdPaymentMethodsBody: CustomerIdPaymentMethodsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'customerId', customerId)
            // verify required parameter 'customerIdPaymentMethodsBody' is not null or undefined
            assertParamExists('createCustomerPaymentMethod', 'customerIdPaymentMethodsBody', customerIdPaymentMethodsBody)
            const localVarPath = `/v1/customers/{customerId}/payment_methods`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerIdPaymentMethodsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method triggers the Webhook - Payment Method Canceled webhook. This webhook contains more information than the response.
         * @summary Delete payment method type from customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerPaymentMethod: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'customerId', customerId)
            // verify required parameter 'pmtId' is not null or undefined
            assertParamExists('deleteCustomerPaymentMethod', 'pmtId', pmtId)
            const localVarPath = `/v1/customers/{customerId}/payment_methods/{pmtId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"pmtId"}}`, encodeURIComponent(String(pmtId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a payment method for a specific customer
         * @summary Retrieve payment method of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPaymentMethod: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'customerId', customerId)
            // verify required parameter 'pmtId' is not null or undefined
            assertParamExists('getCustomerPaymentMethod', 'pmtId', pmtId)
            const localVarPath = `/v1/customers/{customerId}/payment_methods/{pmtId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"pmtId"}}`, encodeURIComponent(String(pmtId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve payment methods for a customer
         * @summary List payment methods of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {Category} [category] 
         * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve
         * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to retrieve
         * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
         * @param {string} [type] The type of payment method to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPaymentMethods: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, category?: Category, startingAfter?: string, endingBefore?: string, limit?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCustomerPaymentMethods', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCustomerPaymentMethods', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCustomerPaymentMethods', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCustomerPaymentMethods', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCustomerPaymentMethods', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomerPaymentMethods', 'customerId', customerId)
            const localVarPath = `/v1/customers/{customerId}/payment_methods`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a payment method that was stored in a customer profile
         * @summary Update payment method of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {CustomerPaymentMethod} customerPaymentMethod customer to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPaymentMethod: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, customerPaymentMethod: CustomerPaymentMethod, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'timestamp', timestamp)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'customerId', customerId)
            // verify required parameter 'pmtId' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'pmtId', pmtId)
            // verify required parameter 'customerPaymentMethod' is not null or undefined
            assertParamExists('updateCustomerPaymentMethod', 'customerPaymentMethod', customerPaymentMethod)
            const localVarPath = `/v1/customers/{customerId}/payment_methods/{pmtId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"pmtId"}}`, encodeURIComponent(String(pmtId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerPaymentMethod, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerPaymentMethodApi - functional programming interface
 * @export
 */
export const CustomerPaymentMethodApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerPaymentMethodApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a payment method to a customer profile
         * @summary Add payment method to customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {CustomerIdPaymentMethodsBody} customerIdPaymentMethodsBody customer to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, customerIdPaymentMethodsBody: CustomerIdPaymentMethodsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, customerIdPaymentMethodsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerPaymentMethodApi.createCustomerPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method triggers the Webhook - Payment Method Canceled webhook. This webhook contains more information than the response.
         * @summary Delete payment method type from customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerPaymentMethodApi.deleteCustomerPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a payment method for a specific customer
         * @summary Retrieve payment method of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerPaymentMethodApi.getCustomerPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve payment methods for a customer
         * @summary List payment methods of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {Category} [category] 
         * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve
         * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to retrieve
         * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
         * @param {string} [type] The type of payment method to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerPaymentMethods(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, category?: Category, startingAfter?: string, endingBefore?: string, limit?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerPaymentMethods(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, category, startingAfter, endingBefore, limit, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerPaymentMethodApi.getCustomerPaymentMethods']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a payment method that was stored in a customer profile
         * @summary Update payment method of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {CustomerPaymentMethod} customerPaymentMethod customer to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, customerPaymentMethod: CustomerPaymentMethod, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, customerPaymentMethod, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerPaymentMethodApi.updateCustomerPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerPaymentMethodApi - factory interface
 * @export
 */
export const CustomerPaymentMethodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerPaymentMethodApiFp(configuration)
    return {
        /**
         * Add a payment method to a customer profile
         * @summary Add payment method to customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {CustomerIdPaymentMethodsBody} customerIdPaymentMethodsBody customer to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, customerIdPaymentMethodsBody: CustomerIdPaymentMethodsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20042> {
            return localVarFp.createCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, customerIdPaymentMethodsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * This method triggers the Webhook - Payment Method Canceled webhook. This webhook contains more information than the response.
         * @summary Delete payment method type from customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20043> {
            return localVarFp.deleteCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a payment method for a specific customer
         * @summary Retrieve payment method of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20042> {
            return localVarFp.getCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve payment methods for a customer
         * @summary List payment methods of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {Category} [category] 
         * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve
         * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to retrieve
         * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
         * @param {string} [type] The type of payment method to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPaymentMethods(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, category?: Category, startingAfter?: string, endingBefore?: string, limit?: string, type?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20041> {
            return localVarFp.getCustomerPaymentMethods(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, category, startingAfter, endingBefore, limit, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a payment method that was stored in a customer profile
         * @summary Update payment method of customer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customerId customer Id
         * @param {string} pmtId Pmt Id
         * @param {CustomerPaymentMethod} customerPaymentMethod customer to add
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, customerPaymentMethod: CustomerPaymentMethod, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20042> {
            return localVarFp.updateCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, customerPaymentMethod, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerPaymentMethodApi - object-oriented interface
 * @export
 * @class CustomerPaymentMethodApi
 * @extends {BaseAPI}
 */
export class CustomerPaymentMethodApi extends BaseAPI {
    /**
     * Add a payment method to a customer profile
     * @summary Add payment method to customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {CustomerIdPaymentMethodsBody} customerIdPaymentMethodsBody customer to add
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPaymentMethodApi
     */
    public createCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, customerIdPaymentMethodsBody: CustomerIdPaymentMethodsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerPaymentMethodApiFp(this.configuration).createCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, customerIdPaymentMethodsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method triggers the Webhook - Payment Method Canceled webhook. This webhook contains more information than the response.
     * @summary Delete payment method type from customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} pmtId Pmt Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPaymentMethodApi
     */
    public deleteCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerPaymentMethodApiFp(this.configuration).deleteCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a payment method for a specific customer
     * @summary Retrieve payment method of customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} pmtId Pmt Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPaymentMethodApi
     */
    public getCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerPaymentMethodApiFp(this.configuration).getCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve payment methods for a customer
     * @summary List payment methods of customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {Category} [category] 
     * @param {string} [startingAfter] The ID of the coupon created before the first coupon you want to retrieve
     * @param {string} [endingBefore] The ID of the coupon created after the last coupon you want to retrieve
     * @param {string} [limit] The maximum number of coupons to return. Range is 1-100. Default is 10
     * @param {string} [type] The type of payment method to find.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPaymentMethodApi
     */
    public getCustomerPaymentMethods(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, idempotency?: string, category?: Category, startingAfter?: string, endingBefore?: string, limit?: string, type?: string, options?: RawAxiosRequestConfig) {
        return CustomerPaymentMethodApiFp(this.configuration).getCustomerPaymentMethods(accessKey, contentType, salt, signature, timestamp, customerId, idempotency, category, startingAfter, endingBefore, limit, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a payment method that was stored in a customer profile
     * @summary Update payment method of customer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customerId customer Id
     * @param {string} pmtId Pmt Id
     * @param {CustomerPaymentMethod} customerPaymentMethod customer to add
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPaymentMethodApi
     */
    public updateCustomerPaymentMethod(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customerId: string, pmtId: string, customerPaymentMethod: CustomerPaymentMethod, idempotency?: string, options?: RawAxiosRequestConfig) {
        return CustomerPaymentMethodApiFp(this.configuration).updateCustomerPaymentMethod(accessKey, contentType, salt, signature, timestamp, customerId, pmtId, customerPaymentMethod, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DigitalWalletApi - axios parameter creator
 * @export
 */
export const DigitalWalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the details of an Apple Pay payment session. Each payment that uses Apple Pay has a unique session.  [Activating Apple Pay](https://docs.rapyd.net/en/activating-apple-pay.html) is a prerequisite.
         * @summary Retrieve  details of Apple Pay payment session
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {ApplePayObject} applePayObject 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplePaySession: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, applePayObject: ApplePayObject, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getApplePaySession', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getApplePaySession', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getApplePaySession', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getApplePaySession', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getApplePaySession', 'timestamp', timestamp)
            // verify required parameter 'applePayObject' is not null or undefined
            assertParamExists('getApplePaySession', 'applePayObject', applePayObject)
            const localVarPath = `/v1/digital_wallets/session/apple_pay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applePayObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DigitalWalletApi - functional programming interface
 * @export
 */
export const DigitalWalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DigitalWalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the details of an Apple Pay payment session. Each payment that uses Apple Pay has a unique session.  [Activating Apple Pay](https://docs.rapyd.net/en/activating-apple-pay.html) is a prerequisite.
         * @summary Retrieve  details of Apple Pay payment session
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {ApplePayObject} applePayObject 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplePaySession(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, applePayObject: ApplePayObject, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplePaySession(accessKey, contentType, salt, signature, timestamp, applePayObject, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletApi.getApplePaySession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DigitalWalletApi - factory interface
 * @export
 */
export const DigitalWalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DigitalWalletApiFp(configuration)
    return {
        /**
         * Retrieve the details of an Apple Pay payment session. Each payment that uses Apple Pay has a unique session.  [Activating Apple Pay](https://docs.rapyd.net/en/activating-apple-pay.html) is a prerequisite.
         * @summary Retrieve  details of Apple Pay payment session
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {ApplePayObject} applePayObject 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplePaySession(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, applePayObject: ApplePayObject, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20033> {
            return localVarFp.getApplePaySession(accessKey, contentType, salt, signature, timestamp, applePayObject, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DigitalWalletApi - object-oriented interface
 * @export
 * @class DigitalWalletApi
 * @extends {BaseAPI}
 */
export class DigitalWalletApi extends BaseAPI {
    /**
     * Retrieve the details of an Apple Pay payment session. Each payment that uses Apple Pay has a unique session.  [Activating Apple Pay](https://docs.rapyd.net/en/activating-apple-pay.html) is a prerequisite.
     * @summary Retrieve  details of Apple Pay payment session
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {ApplePayObject} applePayObject 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletApi
     */
    public getApplePaySession(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, applePayObject: ApplePayObject, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletApiFp(this.configuration).getApplePaySession(accessKey, contentType, salt, signature, timestamp, applePayObject, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DisburseApi - axios parameter creator
 * @export
 */
export const DisburseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a customer-facing page for creating a beneficiary token.<BR> This method creates a URL for a page where the customer enters details required for payouts to the beneficiary’s bank account. All available payout methods for the beneficiary’s country are listed.
         * @summary Create Beneficiary Tokenization Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {DisburseBeneficiaryBody} disburseBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beneficiaryTokenizationPage: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disburseBeneficiaryBody: DisburseBeneficiaryBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('beneficiaryTokenizationPage', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('beneficiaryTokenizationPage', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('beneficiaryTokenizationPage', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('beneficiaryTokenizationPage', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('beneficiaryTokenizationPage', 'timestamp', timestamp)
            // verify required parameter 'disburseBeneficiaryBody' is not null or undefined
            assertParamExists('beneficiaryTokenizationPage', 'disburseBeneficiaryBody', disburseBeneficiaryBody)
            const localVarPath = `/v1/hosted/disburse/beneficiary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disburseBeneficiaryBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The payout can be canceled unless its status is confirmation or completed. This method triggers the Payout Canceled webhook. This webhook contains the same information as the response.
         * @summary Cancel Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('cancelPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('cancelPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('cancelPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('cancelPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cancelPayout', 'timestamp', timestamp)
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('cancelPayout', 'payoutId', payoutId)
            const localVarPath = `/v1/payouts/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutToken ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('confirmPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('confirmPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('confirmPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('confirmPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('confirmPayout', 'timestamp', timestamp)
            // verify required parameter 'payoutToken' is not null or undefined
            assertParamExists('confirmPayout', 'payoutToken', payoutToken)
            const localVarPath = `/v1/payouts/confirm/{payoutToken}`
                .replace(`{${"payoutToken"}}`, encodeURIComponent(String(payoutToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a beneficiary for use in payouts. The response provides a unique beneficiary ID, which you can use in place of the Beneficiary object for Create Payout. This method triggers the Beneficiary Created webhook. This webhook contains the same information as the response. Note: In addition to the required fields documented below, you must include all other beneficiary fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a beneficiary that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
         * @summary Create Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsBeneficiaryBody} payoutsBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBeneficiary: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsBeneficiaryBody: PayoutsBeneficiaryBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createBeneficiary', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createBeneficiary', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createBeneficiary', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createBeneficiary', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBeneficiary', 'timestamp', timestamp)
            // verify required parameter 'payoutsBeneficiaryBody' is not null or undefined
            assertParamExists('createBeneficiary', 'payoutsBeneficiaryBody', payoutsBeneficiaryBody)
            const localVarPath = `/v1/payouts/beneficiary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutsBeneficiaryBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a beneficiary that includes all compliance related data for payouts. The response provides a unique beneficiary ID, which you can use in place of the beneficiary object for Create Payout
         * @summary Create Extended Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsExtendedBeneficiaryBody} payoutsExtendedBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExtendedBeneficiary: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsExtendedBeneficiaryBody: PayoutsExtendedBeneficiaryBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createExtendedBeneficiary', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createExtendedBeneficiary', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createExtendedBeneficiary', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createExtendedBeneficiary', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createExtendedBeneficiary', 'timestamp', timestamp)
            // verify required parameter 'payoutsExtendedBeneficiaryBody' is not null or undefined
            assertParamExists('createExtendedBeneficiary', 'payoutsExtendedBeneficiaryBody', payoutsExtendedBeneficiaryBody)
            const localVarPath = `/v1/payouts/extended_beneficiary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutsExtendedBeneficiaryBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch of payouts (disbursements) from a file. To enable the use of this method, contact Rapyd support. A request input file must be added after the header parameters in the following format: <BR> `-F \'file=@/your-file-location/mass-payout-file.csv\'`
         * @summary Create Mass Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMassPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createMassPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createMassPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createMassPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createMassPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMassPayout', 'timestamp', timestamp)
            const localVarPath = `/v1/batch_process/files/mass_payout_pci`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a payout (disbursement). This method triggers the Payout Created webhook. This webhook contains the same information as the response. If the action of a third party is not required, the Payout Completed webhook is also triggered.
         * @summary Create Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PayoutsBody} v1PayoutsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PayoutsBody: V1PayoutsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPayout', 'timestamp', timestamp)
            // verify required parameter 'v1PayoutsBody' is not null or undefined
            assertParamExists('createPayout', 'v1PayoutsBody', v1PayoutsBody)
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1PayoutsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a sender for use in payouts. The response provides a unique sender ID, which you can use in place of the sender object for Create Payout. Note: In addition to the required fields documented below, you must include all other sender fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a sender that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
         * @summary Create Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsSenderBody} payoutsSenderBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSender: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsSenderBody: PayoutsSenderBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createSender', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createSender', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createSender', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createSender', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSender', 'timestamp', timestamp)
            // verify required parameter 'payoutsSenderBody' is not null or undefined
            assertParamExists('createSender', 'payoutsSenderBody', payoutsSenderBody)
            const localVarPath = `/v1/payouts/sender`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutsSenderBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a payout beneficiary from the Rapyd platform.
         * @summary Delete Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBeneficiary: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteBeneficiary', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteBeneficiary', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteBeneficiary', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteBeneficiary', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteBeneficiary', 'timestamp', timestamp)
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('deleteBeneficiary', 'beneficiaryId', beneficiaryId)
            const localVarPath = `/v1/payouts/beneficiary/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a payout sender from the Rapyd platform.
         * @summary Delete Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} senderId ID of the &#x60;sender&#x60; object. String starting with **sender_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deletePayer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deletePayer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deletePayer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deletePayer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deletePayer', 'timestamp', timestamp)
            // verify required parameter 'senderId' is not null or undefined
            assertParamExists('deletePayer', 'senderId', senderId)
            const localVarPath = `/v1/payouts/sender/{senderId}`
                .replace(`{${"senderId"}}`, encodeURIComponent(String(senderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a payout beneficiary.   Note: The \'Retrieve Beneficiary - individual\' response includes additional fields for the \'ca_general_bank\' payout method. The \'Retrieve Beneficiary - company\' response includes additional fields for the \'us_ach_bank\' payout method.
         * @summary Retrieve Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiary: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getBeneficiary', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getBeneficiary', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getBeneficiary', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getBeneficiary', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBeneficiary', 'timestamp', timestamp)
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('getBeneficiary', 'beneficiaryId', beneficiaryId)
            const localVarPath = `/v1/payouts/beneficiary/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: The Retrieve Sender - individual response includes additional fields for the **ca_general_bank** payout method. The Retrieve Sender - company response includes an additional field for the **us_ach_bank** payout method.
         * @summary Retrieve Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} senderId ID of the Sender object. String starting with **sender_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getPayer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPayer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getPayer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getPayer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPayer', 'timestamp', timestamp)
            // verify required parameter 'senderId' is not null or undefined
            assertParamExists('getPayer', 'senderId', senderId)
            const localVarPath = `/v1/payouts/sender/{senderId}`
                .replace(`{${"senderId"}}`, encodeURIComponent(String(senderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a payout.
         * @summary Retrieve Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPayout', 'timestamp', timestamp)
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('getPayout', 'payoutId', payoutId)
            const localVarPath = `/v1/payouts/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of payout method types that you can use when creating a payout. The response contains a list of objects. Each object includes a payout method type and its attributes.
         * @summary List Payout Method Types
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [senderEntityType] Filters the type of entity for the payer. One of the following: **individual** | **company**
         * @param {string} [beneficiaryCountry] Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code.
         * @param {string} [payoutCurrency] Currency received by the beneficiary. Three-letter ISO 4217 code.
         * @param {string} [senderCurrency] Currency that the sender is paying with. Three-letter ISO 4217 code.
         * @param {string} [senderCountry] Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Note: This field does not appear in the response.
         * @param {string} [beneficiaryEntityType] Filters the type of entity for the beneficiary. One of the following: **individual** | **company**
         * @param {string} [category] The category of payout method. One of the following: bank, card, cash, rapyd_ewallet, ewallet
         * @param {boolean} [isCancelable] Indicates whether the payout can be canceled. Relevant when category is cash.
         * @param {boolean} [isLocationSpecific] Indicates whether the payout must be made at a specific physical location. Relevant when category is cash.
         * @param {boolean} [isExpirable] Indicates whether the payout expires if not completed. Relevant when category is cash.
         * @param {string} [startingAfter] The name of a payout method in the list. The list begins with the record that was created next after the record with this payout method. Use this filter to get the next page of results. Relevant when ending_before is not used.
         * @param {string} [endingBefore] The name of a payout method in the list. The list ends with the last record that was created before the record with this payout method. Use this filter to get the previous page of results.
         * @param {string} [limit] The maximum number of payout methods to return. Range: 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutMethodTypes: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, senderEntityType?: string, beneficiaryCountry?: string, payoutCurrency?: string, senderCurrency?: string, senderCountry?: string, beneficiaryEntityType?: string, category?: string, isCancelable?: boolean, isLocationSpecific?: boolean, isExpirable?: boolean, startingAfter?: string, endingBefore?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getPayoutMethodTypes', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPayoutMethodTypes', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getPayoutMethodTypes', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getPayoutMethodTypes', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPayoutMethodTypes', 'timestamp', timestamp)
            const localVarPath = `/v1/payout_methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (senderEntityType !== undefined) {
                localVarQueryParameter['sender_entity_type'] = senderEntityType;
            }

            if (beneficiaryCountry !== undefined) {
                localVarQueryParameter['beneficiary_country'] = beneficiaryCountry;
            }

            if (payoutCurrency !== undefined) {
                localVarQueryParameter['payout_currency'] = payoutCurrency;
            }

            if (senderCurrency !== undefined) {
                localVarQueryParameter['sender_currency'] = senderCurrency;
            }

            if (senderCountry !== undefined) {
                localVarQueryParameter['sender_country'] = senderCountry;
            }

            if (beneficiaryEntityType !== undefined) {
                localVarQueryParameter['beneficiary_entity_type'] = beneficiaryEntityType;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isCancelable !== undefined) {
                localVarQueryParameter['is_cancelable'] = isCancelable;
            }

            if (isLocationSpecific !== undefined) {
                localVarQueryParameter['is_location_specific'] = isLocationSpecific;
            }

            if (isExpirable !== undefined) {
                localVarQueryParameter['is_expirable'] = isExpirable;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the fields required to use a payout method type. The fields are returned as an array of objects. The name of each field appears in the name field of each object. Use this information for Create Payout, Create Beneficiary and Create Sender.  Note: The fields returned by this method are required when you create a payout. If you create a payout with a sender or beneficiary that was created previously, you are responsible for choosing a sender and beneficiary that have all the fields required by the payout method.
         * @summary Get Payout Required Fields
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} pomt The type of the payout method. Set to the name of a payout method listed in the response to List Payout Method Types. The two-letter prefix must match the beneficiary country code.
         * @param {string} beneficiaryCountry Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
         * @param {string} beneficiaryEntityType Type of entity for the beneficiary. One of the following, **individual** | **company**
         * @param {number} payoutAmount Amount of the payout, in units of the currency that the beneficiary is receiving. Decimal.
         * @param {string} payoutCurrency Currency received by the beneficiary. Three-letter ISO 4217 code. Uppercase.
         * @param {string} senderCountry Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
         * @param {string} senderCurrency Currency that the sender is paying with. Three-letter ISO 4217 code. Uppercase.
         * @param {string} senderEntityType Type of entity for the sender. One of the following: **individual** | **company**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutMethodTypesDetails: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pomt: string, beneficiaryCountry: string, beneficiaryEntityType: string, payoutAmount: number, payoutCurrency: string, senderCountry: string, senderCurrency: string, senderEntityType: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'timestamp', timestamp)
            // verify required parameter 'pomt' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'pomt', pomt)
            // verify required parameter 'beneficiaryCountry' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'beneficiaryCountry', beneficiaryCountry)
            // verify required parameter 'beneficiaryEntityType' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'beneficiaryEntityType', beneficiaryEntityType)
            // verify required parameter 'payoutAmount' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'payoutAmount', payoutAmount)
            // verify required parameter 'payoutCurrency' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'payoutCurrency', payoutCurrency)
            // verify required parameter 'senderCountry' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'senderCountry', senderCountry)
            // verify required parameter 'senderCurrency' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'senderCurrency', senderCurrency)
            // verify required parameter 'senderEntityType' is not null or undefined
            assertParamExists('getPayoutMethodTypesDetails', 'senderEntityType', senderEntityType)
            const localVarPath = `/v1/payout_methods/{pomt}/required_fields`
                .replace(`{${"pomt"}}`, encodeURIComponent(String(pomt)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (beneficiaryCountry !== undefined) {
                localVarQueryParameter['beneficiary_country'] = beneficiaryCountry;
            }

            if (beneficiaryEntityType !== undefined) {
                localVarQueryParameter['beneficiary_entity_type'] = beneficiaryEntityType;
            }

            if (payoutAmount !== undefined) {
                localVarQueryParameter['payout_amount'] = payoutAmount;
            }

            if (payoutCurrency !== undefined) {
                localVarQueryParameter['payout_currency'] = payoutCurrency;
            }

            if (senderCountry !== undefined) {
                localVarQueryParameter['sender_country'] = senderCountry;
            }

            if (senderCurrency !== undefined) {
                localVarQueryParameter['sender_currency'] = senderCurrency;
            }

            if (senderEntityType !== undefined) {
                localVarQueryParameter['sender_entity_type'] = senderEntityType;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of payouts that you created.
         * @summary List Payouts
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [beneficiary] Filters according to the beneficiary ID. String starting with **beneficiary_**.
         * @param {string} [createdAfter] The ID of the payout created before the first payout you want to retrieve. String starting with **payout_**.
         * @param {string} [createdBefore] The ID of the payout created after the last payout you want to retrieve. String starting with **payout_**.
         * @param {string} [endingBefore] The ID of a payout in the list. The list ends with the payout that was created before the payout with this ID. Use this filter to get the previous page of results. String starting with **payout_**. Deprecated.
         * @param {string} [ewallet] Filters according to the wallet ID. String starting with **ewallet_**.
         * @param {string} [limit] The maximum number of payouts to return. Range: 1-100. Default is 10.
         * @param {string} [merchantReferenceId] Filters according to the merchant reference ID.
         * @param {string} [payoutMethodType] Filters according to the type of payout method. The two-letter prefix must match the beneficiary country code.
         * @param {string} [sender] Filters according to the sender ID. String starting with **sender_**.
         * @param {string} [senderCountry] Filters according to the country of the sender. Two-letter ISO 3166-1 ALPHA-2 code.
         * @param {string} [senderCurrency] Filters according to the currency that the sender is paying with. Three-letter ISO 4217 code.
         * @param {string} [startingAfter] The ID of a payout in the list. The list begins with the payout that was created next after the payout with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting **payout_**. Deprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, beneficiary?: string, createdAfter?: string, createdBefore?: string, endingBefore?: string, ewallet?: string, limit?: string, merchantReferenceId?: string, payoutMethodType?: string, sender?: string, senderCountry?: string, senderCurrency?: string, startingAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listPayouts', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listPayouts', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listPayouts', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listPayouts', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listPayouts', 'timestamp', timestamp)
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (beneficiary !== undefined) {
                localVarQueryParameter['beneficiary'] = beneficiary;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (ewallet !== undefined) {
                localVarQueryParameter['ewallet'] = ewallet;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (merchantReferenceId !== undefined) {
                localVarQueryParameter['merchant_reference_id'] = merchantReferenceId;
            }

            if (payoutMethodType !== undefined) {
                localVarQueryParameter['payout_method_type'] = payoutMethodType;
            }

            if (sender !== undefined) {
                localVarQueryParameter['sender'] = sender;
            }

            if (senderCountry !== undefined) {
                localVarQueryParameter['sender_country'] = senderCountry;
            }

            if (senderCurrency !== undefined) {
                localVarQueryParameter['sender_currency'] = senderCurrency;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutToken ID of the payout. String starting with **payout_**.
         * @param {string} amount The payout amount. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCompletePayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, amount: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCompletePayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCompletePayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCompletePayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCompletePayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCompletePayout', 'timestamp', timestamp)
            // verify required parameter 'payoutToken' is not null or undefined
            assertParamExists('simulateCompletePayout', 'payoutToken', payoutToken)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('simulateCompletePayout', 'amount', amount)
            const localVarPath = `/v1/payouts/complete/{payoutToken}/{amount}`
                .replace(`{${"payoutToken"}}`, encodeURIComponent(String(payoutToken)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method in the sandbox to simulate the action of a third party that is required for returning the payout.<BR>Relevant when the status of the payout is Completed.<BR>Prerequisites:<BR>* Create Wallet<BR>* Add Funds to Wallet Account<BR>* Create Payout<BR>* Complete Payout<BR>This method triggers the \'Payout Returned\' Webhook. This webhook contains the same information as the response.
         * @summary Simulating a Payout Returned Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulatePayoutReturnedStatus: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulatePayoutReturnedStatus', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulatePayoutReturnedStatus', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulatePayoutReturnedStatus', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulatePayoutReturnedStatus', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulatePayoutReturnedStatus', 'timestamp', timestamp)
            // verify required parameter 'payout' is not null or undefined
            assertParamExists('simulatePayoutReturnedStatus', 'payout', payout)
            const localVarPath = `/v1/payouts/return/{payout}`
                .replace(`{${"payout"}}`, encodeURIComponent(String(payout)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a beneficiary with additional fields. <BR>Note: You cannot update the values of the beneficiary fields which were defined when it was created.
         * @summary Update Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {BeneficiaryBeneficiaryIdBody} beneficiaryBeneficiaryIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBeneficiary: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, beneficiaryBeneficiaryIdBody: BeneficiaryBeneficiaryIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateBeneficiary', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateBeneficiary', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateBeneficiary', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateBeneficiary', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateBeneficiary', 'timestamp', timestamp)
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('updateBeneficiary', 'beneficiaryId', beneficiaryId)
            // verify required parameter 'beneficiaryBeneficiaryIdBody' is not null or undefined
            assertParamExists('updateBeneficiary', 'beneficiaryBeneficiaryIdBody', beneficiaryBeneficiaryIdBody)
            const localVarPath = `/v1/payouts/beneficiary/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(beneficiaryBeneficiaryIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a payout. This method triggers the Payout Updated webhook. This webhook contains the same information as the response.
         * @summary Update Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {PayoutsPayoutIdBody} payoutsPayoutIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, payoutsPayoutIdBody: PayoutsPayoutIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updatePayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updatePayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updatePayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updatePayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updatePayout', 'timestamp', timestamp)
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('updatePayout', 'payoutId', payoutId)
            // verify required parameter 'payoutsPayoutIdBody' is not null or undefined
            assertParamExists('updatePayout', 'payoutsPayoutIdBody', payoutsPayoutIdBody)
            const localVarPath = `/v1/payouts/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutsPayoutIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the format of the details for a payout beneficiary. You can validate a beneficiary multiple times for different payout methods. You can enter a Beneficiary object or a previously created beneficiary ID.   Note: In addition to the required fields for Create Beneficiary, the Beneficiary object must include all required fields for the beneficiary listed in the response to Get Payout Required Fields. The examples include additional fields for the \'us_ach_bank\' payout method.
         * @summary Validate Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BeneficiaryValidateBody} beneficiaryValidateBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateBeneficiary: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryValidateBody: BeneficiaryValidateBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('validateBeneficiary', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('validateBeneficiary', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('validateBeneficiary', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('validateBeneficiary', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('validateBeneficiary', 'timestamp', timestamp)
            // verify required parameter 'beneficiaryValidateBody' is not null or undefined
            assertParamExists('validateBeneficiary', 'beneficiaryValidateBody', beneficiaryValidateBody)
            const localVarPath = `/v1/payouts/beneficiary/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(beneficiaryValidateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisburseApi - functional programming interface
 * @export
 */
export const DisburseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisburseApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a customer-facing page for creating a beneficiary token.<BR> This method creates a URL for a page where the customer enters details required for payouts to the beneficiary’s bank account. All available payout methods for the beneficiary’s country are listed.
         * @summary Create Beneficiary Tokenization Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {DisburseBeneficiaryBody} disburseBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async beneficiaryTokenizationPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disburseBeneficiaryBody: DisburseBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20060>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.beneficiaryTokenizationPage(accessKey, contentType, salt, signature, timestamp, disburseBeneficiaryBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.beneficiaryTokenizationPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The payout can be canceled unless its status is confirmation or completed. This method triggers the Payout Canceled webhook. This webhook contains the same information as the response.
         * @summary Cancel Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayout(accessKey, contentType, salt, signature, timestamp, payoutId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.cancelPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Confirm Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutToken ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPayout(accessKey, contentType, salt, signature, timestamp, payoutToken, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.confirmPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a beneficiary for use in payouts. The response provides a unique beneficiary ID, which you can use in place of the Beneficiary object for Create Payout. This method triggers the Beneficiary Created webhook. This webhook contains the same information as the response. Note: In addition to the required fields documented below, you must include all other beneficiary fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a beneficiary that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
         * @summary Create Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsBeneficiaryBody} payoutsBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsBeneficiaryBody: PayoutsBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBeneficiary(accessKey, contentType, salt, signature, timestamp, payoutsBeneficiaryBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.createBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a beneficiary that includes all compliance related data for payouts. The response provides a unique beneficiary ID, which you can use in place of the beneficiary object for Create Payout
         * @summary Create Extended Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsExtendedBeneficiaryBody} payoutsExtendedBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExtendedBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsExtendedBeneficiaryBody: PayoutsExtendedBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExtendedBeneficiary(accessKey, contentType, salt, signature, timestamp, payoutsExtendedBeneficiaryBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.createExtendedBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a batch of payouts (disbursements) from a file. To enable the use of this method, contact Rapyd support. A request input file must be added after the header parameters in the following format: <BR> `-F \'file=@/your-file-location/mass-payout-file.csv\'`
         * @summary Create Mass Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMassPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20056>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMassPayout(accessKey, contentType, salt, signature, timestamp, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.createMassPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a payout (disbursement). This method triggers the Payout Created webhook. This webhook contains the same information as the response. If the action of a third party is not required, the Payout Completed webhook is also triggered.
         * @summary Create Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PayoutsBody} v1PayoutsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PayoutsBody: V1PayoutsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayout(accessKey, contentType, salt, signature, timestamp, v1PayoutsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.createPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a sender for use in payouts. The response provides a unique sender ID, which you can use in place of the sender object for Create Payout. Note: In addition to the required fields documented below, you must include all other sender fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a sender that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
         * @summary Create Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsSenderBody} payoutsSenderBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSender(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsSenderBody: PayoutsSenderBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSender(accessKey, contentType, salt, signature, timestamp, payoutsSenderBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.createSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a payout beneficiary from the Rapyd platform.
         * @summary Delete Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20059>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.deleteBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a payout sender from the Rapyd platform.
         * @summary Delete Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} senderId ID of the &#x60;sender&#x60; object. String starting with **sender_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePayer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20062>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePayer(accessKey, contentType, salt, signature, timestamp, senderId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.deletePayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a payout beneficiary.   Note: The \'Retrieve Beneficiary - individual\' response includes additional fields for the \'ca_general_bank\' payout method. The \'Retrieve Beneficiary - company\' response includes additional fields for the \'us_ach_bank\' payout method.
         * @summary Retrieve Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.getBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Note: The Retrieve Sender - individual response includes additional fields for the **ca_general_bank** payout method. The Retrieve Sender - company response includes an additional field for the **us_ach_bank** payout method.
         * @summary Retrieve Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} senderId ID of the Sender object. String starting with **sender_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayer(accessKey, contentType, salt, signature, timestamp, senderId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.getPayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a payout.
         * @summary Retrieve Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayout(accessKey, contentType, salt, signature, timestamp, payoutId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.getPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of payout method types that you can use when creating a payout. The response contains a list of objects. Each object includes a payout method type and its attributes.
         * @summary List Payout Method Types
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [senderEntityType] Filters the type of entity for the payer. One of the following: **individual** | **company**
         * @param {string} [beneficiaryCountry] Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code.
         * @param {string} [payoutCurrency] Currency received by the beneficiary. Three-letter ISO 4217 code.
         * @param {string} [senderCurrency] Currency that the sender is paying with. Three-letter ISO 4217 code.
         * @param {string} [senderCountry] Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Note: This field does not appear in the response.
         * @param {string} [beneficiaryEntityType] Filters the type of entity for the beneficiary. One of the following: **individual** | **company**
         * @param {string} [category] The category of payout method. One of the following: bank, card, cash, rapyd_ewallet, ewallet
         * @param {boolean} [isCancelable] Indicates whether the payout can be canceled. Relevant when category is cash.
         * @param {boolean} [isLocationSpecific] Indicates whether the payout must be made at a specific physical location. Relevant when category is cash.
         * @param {boolean} [isExpirable] Indicates whether the payout expires if not completed. Relevant when category is cash.
         * @param {string} [startingAfter] The name of a payout method in the list. The list begins with the record that was created next after the record with this payout method. Use this filter to get the next page of results. Relevant when ending_before is not used.
         * @param {string} [endingBefore] The name of a payout method in the list. The list ends with the last record that was created before the record with this payout method. Use this filter to get the previous page of results.
         * @param {string} [limit] The maximum number of payout methods to return. Range: 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutMethodTypes(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, senderEntityType?: string, beneficiaryCountry?: string, payoutCurrency?: string, senderCurrency?: string, senderCountry?: string, beneficiaryEntityType?: string, category?: string, isCancelable?: boolean, isLocationSpecific?: boolean, isExpirable?: boolean, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20063>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutMethodTypes(accessKey, contentType, salt, signature, timestamp, idempotency, senderEntityType, beneficiaryCountry, payoutCurrency, senderCurrency, senderCountry, beneficiaryEntityType, category, isCancelable, isLocationSpecific, isExpirable, startingAfter, endingBefore, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.getPayoutMethodTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the fields required to use a payout method type. The fields are returned as an array of objects. The name of each field appears in the name field of each object. Use this information for Create Payout, Create Beneficiary and Create Sender.  Note: The fields returned by this method are required when you create a payout. If you create a payout with a sender or beneficiary that was created previously, you are responsible for choosing a sender and beneficiary that have all the fields required by the payout method.
         * @summary Get Payout Required Fields
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} pomt The type of the payout method. Set to the name of a payout method listed in the response to List Payout Method Types. The two-letter prefix must match the beneficiary country code.
         * @param {string} beneficiaryCountry Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
         * @param {string} beneficiaryEntityType Type of entity for the beneficiary. One of the following, **individual** | **company**
         * @param {number} payoutAmount Amount of the payout, in units of the currency that the beneficiary is receiving. Decimal.
         * @param {string} payoutCurrency Currency received by the beneficiary. Three-letter ISO 4217 code. Uppercase.
         * @param {string} senderCountry Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
         * @param {string} senderCurrency Currency that the sender is paying with. Three-letter ISO 4217 code. Uppercase.
         * @param {string} senderEntityType Type of entity for the sender. One of the following: **individual** | **company**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutMethodTypesDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pomt: string, beneficiaryCountry: string, beneficiaryEntityType: string, payoutAmount: number, payoutCurrency: string, senderCountry: string, senderCurrency: string, senderEntityType: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutMethodTypesDetails(accessKey, contentType, salt, signature, timestamp, pomt, beneficiaryCountry, beneficiaryEntityType, payoutAmount, payoutCurrency, senderCountry, senderCurrency, senderEntityType, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.getPayoutMethodTypesDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of payouts that you created.
         * @summary List Payouts
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [beneficiary] Filters according to the beneficiary ID. String starting with **beneficiary_**.
         * @param {string} [createdAfter] The ID of the payout created before the first payout you want to retrieve. String starting with **payout_**.
         * @param {string} [createdBefore] The ID of the payout created after the last payout you want to retrieve. String starting with **payout_**.
         * @param {string} [endingBefore] The ID of a payout in the list. The list ends with the payout that was created before the payout with this ID. Use this filter to get the previous page of results. String starting with **payout_**. Deprecated.
         * @param {string} [ewallet] Filters according to the wallet ID. String starting with **ewallet_**.
         * @param {string} [limit] The maximum number of payouts to return. Range: 1-100. Default is 10.
         * @param {string} [merchantReferenceId] Filters according to the merchant reference ID.
         * @param {string} [payoutMethodType] Filters according to the type of payout method. The two-letter prefix must match the beneficiary country code.
         * @param {string} [sender] Filters according to the sender ID. String starting with **sender_**.
         * @param {string} [senderCountry] Filters according to the country of the sender. Two-letter ISO 3166-1 ALPHA-2 code.
         * @param {string} [senderCurrency] Filters according to the currency that the sender is paying with. Three-letter ISO 4217 code.
         * @param {string} [startingAfter] The ID of a payout in the list. The list begins with the payout that was created next after the payout with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting **payout_**. Deprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayouts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, beneficiary?: string, createdAfter?: string, createdBefore?: string, endingBefore?: string, ewallet?: string, limit?: string, merchantReferenceId?: string, payoutMethodType?: string, sender?: string, senderCountry?: string, senderCurrency?: string, startingAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayouts(accessKey, contentType, salt, signature, timestamp, idempotency, beneficiary, createdAfter, createdBefore, endingBefore, ewallet, limit, merchantReferenceId, payoutMethodType, sender, senderCountry, senderCurrency, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.listPayouts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Complete Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutToken ID of the payout. String starting with **payout_**.
         * @param {string} amount The payout amount. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCompletePayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, amount: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCompletePayout(accessKey, contentType, salt, signature, timestamp, payoutToken, amount, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.simulateCompletePayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method in the sandbox to simulate the action of a third party that is required for returning the payout.<BR>Relevant when the status of the payout is Completed.<BR>Prerequisites:<BR>* Create Wallet<BR>* Add Funds to Wallet Account<BR>* Create Payout<BR>* Complete Payout<BR>This method triggers the \'Payout Returned\' Webhook. This webhook contains the same information as the response.
         * @summary Simulating a Payout Returned Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulatePayoutReturnedStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20064>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulatePayoutReturnedStatus(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.simulatePayoutReturnedStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a beneficiary with additional fields. <BR>Note: You cannot update the values of the beneficiary fields which were defined when it was created.
         * @summary Update Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {BeneficiaryBeneficiaryIdBody} beneficiaryBeneficiaryIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, beneficiaryBeneficiaryIdBody: BeneficiaryBeneficiaryIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, beneficiaryBeneficiaryIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.updateBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a payout. This method triggers the Payout Updated webhook. This webhook contains the same information as the response.
         * @summary Update Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {PayoutsPayoutIdBody} payoutsPayoutIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, payoutsPayoutIdBody: PayoutsPayoutIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayout(accessKey, contentType, salt, signature, timestamp, payoutId, payoutsPayoutIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.updatePayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate the format of the details for a payout beneficiary. You can validate a beneficiary multiple times for different payout methods. You can enter a Beneficiary object or a previously created beneficiary ID.   Note: In addition to the required fields for Create Beneficiary, the Beneficiary object must include all required fields for the beneficiary listed in the response to Get Payout Required Fields. The examples include additional fields for the \'us_ach_bank\' payout method.
         * @summary Validate Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BeneficiaryValidateBody} beneficiaryValidateBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryValidateBody: BeneficiaryValidateBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20058>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryValidateBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseApi.validateBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DisburseApi - factory interface
 * @export
 */
export const DisburseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisburseApiFp(configuration)
    return {
        /**
         * Create a customer-facing page for creating a beneficiary token.<BR> This method creates a URL for a page where the customer enters details required for payouts to the beneficiary’s bank account. All available payout methods for the beneficiary’s country are listed.
         * @summary Create Beneficiary Tokenization Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {DisburseBeneficiaryBody} disburseBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beneficiaryTokenizationPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disburseBeneficiaryBody: DisburseBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20060> {
            return localVarFp.beneficiaryTokenizationPage(accessKey, contentType, salt, signature, timestamp, disburseBeneficiaryBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * The payout can be canceled unless its status is confirmation or completed. This method triggers the Payout Canceled webhook. This webhook contains the same information as the response.
         * @summary Cancel Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20055> {
            return localVarFp.cancelPayout(accessKey, contentType, salt, signature, timestamp, payoutId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutToken ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20055> {
            return localVarFp.confirmPayout(accessKey, contentType, salt, signature, timestamp, payoutToken, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a beneficiary for use in payouts. The response provides a unique beneficiary ID, which you can use in place of the Beneficiary object for Create Payout. This method triggers the Beneficiary Created webhook. This webhook contains the same information as the response. Note: In addition to the required fields documented below, you must include all other beneficiary fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a beneficiary that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
         * @summary Create Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsBeneficiaryBody} payoutsBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsBeneficiaryBody: PayoutsBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20057> {
            return localVarFp.createBeneficiary(accessKey, contentType, salt, signature, timestamp, payoutsBeneficiaryBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a beneficiary that includes all compliance related data for payouts. The response provides a unique beneficiary ID, which you can use in place of the beneficiary object for Create Payout
         * @summary Create Extended Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsExtendedBeneficiaryBody} payoutsExtendedBeneficiaryBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExtendedBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsExtendedBeneficiaryBody: PayoutsExtendedBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20057> {
            return localVarFp.createExtendedBeneficiary(accessKey, contentType, salt, signature, timestamp, payoutsExtendedBeneficiaryBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch of payouts (disbursements) from a file. To enable the use of this method, contact Rapyd support. A request input file must be added after the header parameters in the following format: <BR> `-F \'file=@/your-file-location/mass-payout-file.csv\'`
         * @summary Create Mass Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMassPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20056> {
            return localVarFp.createMassPayout(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a payout (disbursement). This method triggers the Payout Created webhook. This webhook contains the same information as the response. If the action of a third party is not required, the Payout Completed webhook is also triggered.
         * @summary Create Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PayoutsBody} v1PayoutsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PayoutsBody: V1PayoutsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20055> {
            return localVarFp.createPayout(accessKey, contentType, salt, signature, timestamp, v1PayoutsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a sender for use in payouts. The response provides a unique sender ID, which you can use in place of the sender object for Create Payout. Note: In addition to the required fields documented below, you must include all other sender fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a sender that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
         * @summary Create Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PayoutsSenderBody} payoutsSenderBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSender(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsSenderBody: PayoutsSenderBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20061> {
            return localVarFp.createSender(accessKey, contentType, salt, signature, timestamp, payoutsSenderBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a payout beneficiary from the Rapyd platform.
         * @summary Delete Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20059> {
            return localVarFp.deleteBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a payout sender from the Rapyd platform.
         * @summary Delete Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} senderId ID of the &#x60;sender&#x60; object. String starting with **sender_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20062> {
            return localVarFp.deletePayer(accessKey, contentType, salt, signature, timestamp, senderId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a payout beneficiary.   Note: The \'Retrieve Beneficiary - individual\' response includes additional fields for the \'ca_general_bank\' payout method. The \'Retrieve Beneficiary - company\' response includes additional fields for the \'us_ach_bank\' payout method.
         * @summary Retrieve Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20057> {
            return localVarFp.getBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: The Retrieve Sender - individual response includes additional fields for the **ca_general_bank** payout method. The Retrieve Sender - company response includes an additional field for the **us_ach_bank** payout method.
         * @summary Retrieve Sender
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} senderId ID of the Sender object. String starting with **sender_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20061> {
            return localVarFp.getPayer(accessKey, contentType, salt, signature, timestamp, senderId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a payout.
         * @summary Retrieve Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20055> {
            return localVarFp.getPayout(accessKey, contentType, salt, signature, timestamp, payoutId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of payout method types that you can use when creating a payout. The response contains a list of objects. Each object includes a payout method type and its attributes.
         * @summary List Payout Method Types
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [senderEntityType] Filters the type of entity for the payer. One of the following: **individual** | **company**
         * @param {string} [beneficiaryCountry] Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code.
         * @param {string} [payoutCurrency] Currency received by the beneficiary. Three-letter ISO 4217 code.
         * @param {string} [senderCurrency] Currency that the sender is paying with. Three-letter ISO 4217 code.
         * @param {string} [senderCountry] Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Note: This field does not appear in the response.
         * @param {string} [beneficiaryEntityType] Filters the type of entity for the beneficiary. One of the following: **individual** | **company**
         * @param {string} [category] The category of payout method. One of the following: bank, card, cash, rapyd_ewallet, ewallet
         * @param {boolean} [isCancelable] Indicates whether the payout can be canceled. Relevant when category is cash.
         * @param {boolean} [isLocationSpecific] Indicates whether the payout must be made at a specific physical location. Relevant when category is cash.
         * @param {boolean} [isExpirable] Indicates whether the payout expires if not completed. Relevant when category is cash.
         * @param {string} [startingAfter] The name of a payout method in the list. The list begins with the record that was created next after the record with this payout method. Use this filter to get the next page of results. Relevant when ending_before is not used.
         * @param {string} [endingBefore] The name of a payout method in the list. The list ends with the last record that was created before the record with this payout method. Use this filter to get the previous page of results.
         * @param {string} [limit] The maximum number of payout methods to return. Range: 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutMethodTypes(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, senderEntityType?: string, beneficiaryCountry?: string, payoutCurrency?: string, senderCurrency?: string, senderCountry?: string, beneficiaryEntityType?: string, category?: string, isCancelable?: boolean, isLocationSpecific?: boolean, isExpirable?: boolean, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20063> {
            return localVarFp.getPayoutMethodTypes(accessKey, contentType, salt, signature, timestamp, idempotency, senderEntityType, beneficiaryCountry, payoutCurrency, senderCurrency, senderCountry, beneficiaryEntityType, category, isCancelable, isLocationSpecific, isExpirable, startingAfter, endingBefore, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the fields required to use a payout method type. The fields are returned as an array of objects. The name of each field appears in the name field of each object. Use this information for Create Payout, Create Beneficiary and Create Sender.  Note: The fields returned by this method are required when you create a payout. If you create a payout with a sender or beneficiary that was created previously, you are responsible for choosing a sender and beneficiary that have all the fields required by the payout method.
         * @summary Get Payout Required Fields
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} pomt The type of the payout method. Set to the name of a payout method listed in the response to List Payout Method Types. The two-letter prefix must match the beneficiary country code.
         * @param {string} beneficiaryCountry Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
         * @param {string} beneficiaryEntityType Type of entity for the beneficiary. One of the following, **individual** | **company**
         * @param {number} payoutAmount Amount of the payout, in units of the currency that the beneficiary is receiving. Decimal.
         * @param {string} payoutCurrency Currency received by the beneficiary. Three-letter ISO 4217 code. Uppercase.
         * @param {string} senderCountry Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
         * @param {string} senderCurrency Currency that the sender is paying with. Three-letter ISO 4217 code. Uppercase.
         * @param {string} senderEntityType Type of entity for the sender. One of the following: **individual** | **company**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutMethodTypesDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pomt: string, beneficiaryCountry: string, beneficiaryEntityType: string, payoutAmount: number, payoutCurrency: string, senderCountry: string, senderCurrency: string, senderEntityType: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20053> {
            return localVarFp.getPayoutMethodTypesDetails(accessKey, contentType, salt, signature, timestamp, pomt, beneficiaryCountry, beneficiaryEntityType, payoutAmount, payoutCurrency, senderCountry, senderCurrency, senderEntityType, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of payouts that you created.
         * @summary List Payouts
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [beneficiary] Filters according to the beneficiary ID. String starting with **beneficiary_**.
         * @param {string} [createdAfter] The ID of the payout created before the first payout you want to retrieve. String starting with **payout_**.
         * @param {string} [createdBefore] The ID of the payout created after the last payout you want to retrieve. String starting with **payout_**.
         * @param {string} [endingBefore] The ID of a payout in the list. The list ends with the payout that was created before the payout with this ID. Use this filter to get the previous page of results. String starting with **payout_**. Deprecated.
         * @param {string} [ewallet] Filters according to the wallet ID. String starting with **ewallet_**.
         * @param {string} [limit] The maximum number of payouts to return. Range: 1-100. Default is 10.
         * @param {string} [merchantReferenceId] Filters according to the merchant reference ID.
         * @param {string} [payoutMethodType] Filters according to the type of payout method. The two-letter prefix must match the beneficiary country code.
         * @param {string} [sender] Filters according to the sender ID. String starting with **sender_**.
         * @param {string} [senderCountry] Filters according to the country of the sender. Two-letter ISO 3166-1 ALPHA-2 code.
         * @param {string} [senderCurrency] Filters according to the currency that the sender is paying with. Three-letter ISO 4217 code.
         * @param {string} [startingAfter] The ID of a payout in the list. The list begins with the payout that was created next after the payout with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting **payout_**. Deprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, beneficiary?: string, createdAfter?: string, createdBefore?: string, endingBefore?: string, ewallet?: string, limit?: string, merchantReferenceId?: string, payoutMethodType?: string, sender?: string, senderCountry?: string, senderCurrency?: string, startingAfter?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20054> {
            return localVarFp.listPayouts(accessKey, contentType, salt, signature, timestamp, idempotency, beneficiary, createdAfter, createdBefore, endingBefore, ewallet, limit, merchantReferenceId, payoutMethodType, sender, senderCountry, senderCurrency, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutToken ID of the payout. String starting with **payout_**.
         * @param {string} amount The payout amount. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCompletePayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, amount: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20055> {
            return localVarFp.simulateCompletePayout(accessKey, contentType, salt, signature, timestamp, payoutToken, amount, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method in the sandbox to simulate the action of a third party that is required for returning the payout.<BR>Relevant when the status of the payout is Completed.<BR>Prerequisites:<BR>* Create Wallet<BR>* Add Funds to Wallet Account<BR>* Create Payout<BR>* Complete Payout<BR>This method triggers the \'Payout Returned\' Webhook. This webhook contains the same information as the response.
         * @summary Simulating a Payout Returned Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulatePayoutReturnedStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20064> {
            return localVarFp.simulatePayoutReturnedStatus(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a beneficiary with additional fields. <BR>Note: You cannot update the values of the beneficiary fields which were defined when it was created.
         * @summary Update Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
         * @param {BeneficiaryBeneficiaryIdBody} beneficiaryBeneficiaryIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, beneficiaryBeneficiaryIdBody: BeneficiaryBeneficiaryIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20057> {
            return localVarFp.updateBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, beneficiaryBeneficiaryIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a payout. This method triggers the Payout Updated webhook. This webhook contains the same information as the response.
         * @summary Update Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payoutId ID of the payout. String starting with **payout_**.
         * @param {PayoutsPayoutIdBody} payoutsPayoutIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, payoutsPayoutIdBody: PayoutsPayoutIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20055> {
            return localVarFp.updatePayout(accessKey, contentType, salt, signature, timestamp, payoutId, payoutsPayoutIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the format of the details for a payout beneficiary. You can validate a beneficiary multiple times for different payout methods. You can enter a Beneficiary object or a previously created beneficiary ID.   Note: In addition to the required fields for Create Beneficiary, the Beneficiary object must include all required fields for the beneficiary listed in the response to Get Payout Required Fields. The examples include additional fields for the \'us_ach_bank\' payout method.
         * @summary Validate Beneficiary
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BeneficiaryValidateBody} beneficiaryValidateBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryValidateBody: BeneficiaryValidateBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20058> {
            return localVarFp.validateBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryValidateBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisburseApi - object-oriented interface
 * @export
 * @class DisburseApi
 * @extends {BaseAPI}
 */
export class DisburseApi extends BaseAPI {
    /**
     * Create a customer-facing page for creating a beneficiary token.<BR> This method creates a URL for a page where the customer enters details required for payouts to the beneficiary’s bank account. All available payout methods for the beneficiary’s country are listed.
     * @summary Create Beneficiary Tokenization Page
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {DisburseBeneficiaryBody} disburseBeneficiaryBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public beneficiaryTokenizationPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disburseBeneficiaryBody: DisburseBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).beneficiaryTokenizationPage(accessKey, contentType, salt, signature, timestamp, disburseBeneficiaryBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The payout can be canceled unless its status is confirmation or completed. This method triggers the Payout Canceled webhook. This webhook contains the same information as the response.
     * @summary Cancel Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payoutId ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public cancelPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).cancelPayout(accessKey, contentType, salt, signature, timestamp, payoutId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payoutToken ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public confirmPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).confirmPayout(accessKey, contentType, salt, signature, timestamp, payoutToken, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a beneficiary for use in payouts. The response provides a unique beneficiary ID, which you can use in place of the Beneficiary object for Create Payout. This method triggers the Beneficiary Created webhook. This webhook contains the same information as the response. Note: In addition to the required fields documented below, you must include all other beneficiary fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a beneficiary that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
     * @summary Create Beneficiary
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {PayoutsBeneficiaryBody} payoutsBeneficiaryBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public createBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsBeneficiaryBody: PayoutsBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).createBeneficiary(accessKey, contentType, salt, signature, timestamp, payoutsBeneficiaryBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a beneficiary that includes all compliance related data for payouts. The response provides a unique beneficiary ID, which you can use in place of the beneficiary object for Create Payout
     * @summary Create Extended Beneficiary
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {PayoutsExtendedBeneficiaryBody} payoutsExtendedBeneficiaryBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public createExtendedBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsExtendedBeneficiaryBody: PayoutsExtendedBeneficiaryBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).createExtendedBeneficiary(accessKey, contentType, salt, signature, timestamp, payoutsExtendedBeneficiaryBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a batch of payouts (disbursements) from a file. To enable the use of this method, contact Rapyd support. A request input file must be added after the header parameters in the following format: <BR> `-F \'file=@/your-file-location/mass-payout-file.csv\'`
     * @summary Create Mass Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public createMassPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).createMassPayout(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a payout (disbursement). This method triggers the Payout Created webhook. This webhook contains the same information as the response. If the action of a third party is not required, the Payout Completed webhook is also triggered.
     * @summary Create Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1PayoutsBody} v1PayoutsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public createPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PayoutsBody: V1PayoutsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).createPayout(accessKey, contentType, salt, signature, timestamp, v1PayoutsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a sender for use in payouts. The response provides a unique sender ID, which you can use in place of the sender object for Create Payout. Note: In addition to the required fields documented below, you must include all other sender fields listed in the response to Get Payout Required Fields, and you must conform to the regex provided. To create a sender that you can use with multiple payout methods, include all fields that are required by each payout method. The client is responsible for including all required fields.
     * @summary Create Sender
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {PayoutsSenderBody} payoutsSenderBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public createSender(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutsSenderBody: PayoutsSenderBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).createSender(accessKey, contentType, salt, signature, timestamp, payoutsSenderBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a payout beneficiary from the Rapyd platform.
     * @summary Delete Beneficiary
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public deleteBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).deleteBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a payout sender from the Rapyd platform.
     * @summary Delete Sender
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} senderId ID of the &#x60;sender&#x60; object. String starting with **sender_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public deletePayer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).deletePayer(accessKey, contentType, salt, signature, timestamp, senderId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a payout beneficiary.   Note: The \'Retrieve Beneficiary - individual\' response includes additional fields for the \'ca_general_bank\' payout method. The \'Retrieve Beneficiary - company\' response includes additional fields for the \'us_ach_bank\' payout method.
     * @summary Retrieve Beneficiary
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public getBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).getBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: The Retrieve Sender - individual response includes additional fields for the **ca_general_bank** payout method. The Retrieve Sender - company response includes an additional field for the **us_ach_bank** payout method.
     * @summary Retrieve Sender
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} senderId ID of the Sender object. String starting with **sender_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public getPayer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, senderId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).getPayer(accessKey, contentType, salt, signature, timestamp, senderId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a payout.
     * @summary Retrieve Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payoutId ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public getPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).getPayout(accessKey, contentType, salt, signature, timestamp, payoutId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of payout method types that you can use when creating a payout. The response contains a list of objects. Each object includes a payout method type and its attributes.
     * @summary List Payout Method Types
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [senderEntityType] Filters the type of entity for the payer. One of the following: **individual** | **company**
     * @param {string} [beneficiaryCountry] Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code.
     * @param {string} [payoutCurrency] Currency received by the beneficiary. Three-letter ISO 4217 code.
     * @param {string} [senderCurrency] Currency that the sender is paying with. Three-letter ISO 4217 code.
     * @param {string} [senderCountry] Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Note: This field does not appear in the response.
     * @param {string} [beneficiaryEntityType] Filters the type of entity for the beneficiary. One of the following: **individual** | **company**
     * @param {string} [category] The category of payout method. One of the following: bank, card, cash, rapyd_ewallet, ewallet
     * @param {boolean} [isCancelable] Indicates whether the payout can be canceled. Relevant when category is cash.
     * @param {boolean} [isLocationSpecific] Indicates whether the payout must be made at a specific physical location. Relevant when category is cash.
     * @param {boolean} [isExpirable] Indicates whether the payout expires if not completed. Relevant when category is cash.
     * @param {string} [startingAfter] The name of a payout method in the list. The list begins with the record that was created next after the record with this payout method. Use this filter to get the next page of results. Relevant when ending_before is not used.
     * @param {string} [endingBefore] The name of a payout method in the list. The list ends with the last record that was created before the record with this payout method. Use this filter to get the previous page of results.
     * @param {string} [limit] The maximum number of payout methods to return. Range: 1-100. Default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public getPayoutMethodTypes(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, senderEntityType?: string, beneficiaryCountry?: string, payoutCurrency?: string, senderCurrency?: string, senderCountry?: string, beneficiaryEntityType?: string, category?: string, isCancelable?: boolean, isLocationSpecific?: boolean, isExpirable?: boolean, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).getPayoutMethodTypes(accessKey, contentType, salt, signature, timestamp, idempotency, senderEntityType, beneficiaryCountry, payoutCurrency, senderCurrency, senderCountry, beneficiaryEntityType, category, isCancelable, isLocationSpecific, isExpirable, startingAfter, endingBefore, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the fields required to use a payout method type. The fields are returned as an array of objects. The name of each field appears in the name field of each object. Use this information for Create Payout, Create Beneficiary and Create Sender.  Note: The fields returned by this method are required when you create a payout. If you create a payout with a sender or beneficiary that was created previously, you are responsible for choosing a sender and beneficiary that have all the fields required by the payout method.
     * @summary Get Payout Required Fields
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} pomt The type of the payout method. Set to the name of a payout method listed in the response to List Payout Method Types. The two-letter prefix must match the beneficiary country code.
     * @param {string} beneficiaryCountry Country of the beneficiary. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @param {string} beneficiaryEntityType Type of entity for the beneficiary. One of the following, **individual** | **company**
     * @param {number} payoutAmount Amount of the payout, in units of the currency that the beneficiary is receiving. Decimal.
     * @param {string} payoutCurrency Currency received by the beneficiary. Three-letter ISO 4217 code. Uppercase.
     * @param {string} senderCountry Country of the sender. Two-letter ISO 3166-1 ALPHA-2 code. Uppercase.
     * @param {string} senderCurrency Currency that the sender is paying with. Three-letter ISO 4217 code. Uppercase.
     * @param {string} senderEntityType Type of entity for the sender. One of the following: **individual** | **company**
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public getPayoutMethodTypesDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pomt: string, beneficiaryCountry: string, beneficiaryEntityType: string, payoutAmount: number, payoutCurrency: string, senderCountry: string, senderCurrency: string, senderEntityType: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).getPayoutMethodTypesDetails(accessKey, contentType, salt, signature, timestamp, pomt, beneficiaryCountry, beneficiaryEntityType, payoutAmount, payoutCurrency, senderCountry, senderCurrency, senderEntityType, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of payouts that you created.
     * @summary List Payouts
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [beneficiary] Filters according to the beneficiary ID. String starting with **beneficiary_**.
     * @param {string} [createdAfter] The ID of the payout created before the first payout you want to retrieve. String starting with **payout_**.
     * @param {string} [createdBefore] The ID of the payout created after the last payout you want to retrieve. String starting with **payout_**.
     * @param {string} [endingBefore] The ID of a payout in the list. The list ends with the payout that was created before the payout with this ID. Use this filter to get the previous page of results. String starting with **payout_**. Deprecated.
     * @param {string} [ewallet] Filters according to the wallet ID. String starting with **ewallet_**.
     * @param {string} [limit] The maximum number of payouts to return. Range: 1-100. Default is 10.
     * @param {string} [merchantReferenceId] Filters according to the merchant reference ID.
     * @param {string} [payoutMethodType] Filters according to the type of payout method. The two-letter prefix must match the beneficiary country code.
     * @param {string} [sender] Filters according to the sender ID. String starting with **sender_**.
     * @param {string} [senderCountry] Filters according to the country of the sender. Two-letter ISO 3166-1 ALPHA-2 code.
     * @param {string} [senderCurrency] Filters according to the currency that the sender is paying with. Three-letter ISO 4217 code.
     * @param {string} [startingAfter] The ID of a payout in the list. The list begins with the payout that was created next after the payout with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting **payout_**. Deprecated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public listPayouts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, beneficiary?: string, createdAfter?: string, createdBefore?: string, endingBefore?: string, ewallet?: string, limit?: string, merchantReferenceId?: string, payoutMethodType?: string, sender?: string, senderCountry?: string, senderCurrency?: string, startingAfter?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).listPayouts(accessKey, contentType, salt, signature, timestamp, idempotency, beneficiary, createdAfter, createdBefore, endingBefore, ewallet, limit, merchantReferenceId, payoutMethodType, sender, senderCountry, senderCurrency, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payoutToken ID of the payout. String starting with **payout_**.
     * @param {string} amount The payout amount. Decimal, including the correct number of decimal places for the currency exponent, as defined in ISO 2417:2015.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public simulateCompletePayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutToken: string, amount: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).simulateCompletePayout(accessKey, contentType, salt, signature, timestamp, payoutToken, amount, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method in the sandbox to simulate the action of a third party that is required for returning the payout.<BR>Relevant when the status of the payout is Completed.<BR>Prerequisites:<BR>* Create Wallet<BR>* Add Funds to Wallet Account<BR>* Create Payout<BR>* Complete Payout<BR>This method triggers the \'Payout Returned\' Webhook. This webhook contains the same information as the response.
     * @summary Simulating a Payout Returned Status
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payout ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public simulatePayoutReturnedStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).simulatePayoutReturnedStatus(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a beneficiary with additional fields. <BR>Note: You cannot update the values of the beneficiary fields which were defined when it was created.
     * @summary Update Beneficiary
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} beneficiaryId ID of the \&#39;beneficiary\&#39; object. String starting with **beneficiary_**.
     * @param {BeneficiaryBeneficiaryIdBody} beneficiaryBeneficiaryIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public updateBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryId: string, beneficiaryBeneficiaryIdBody: BeneficiaryBeneficiaryIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).updateBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryId, beneficiaryBeneficiaryIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a payout. This method triggers the Payout Updated webhook. This webhook contains the same information as the response.
     * @summary Update Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payoutId ID of the payout. String starting with **payout_**.
     * @param {PayoutsPayoutIdBody} payoutsPayoutIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public updatePayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payoutId: string, payoutsPayoutIdBody: PayoutsPayoutIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).updatePayout(accessKey, contentType, salt, signature, timestamp, payoutId, payoutsPayoutIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the format of the details for a payout beneficiary. You can validate a beneficiary multiple times for different payout methods. You can enter a Beneficiary object or a previously created beneficiary ID.   Note: In addition to the required fields for Create Beneficiary, the Beneficiary object must include all required fields for the beneficiary listed in the response to Get Payout Required Fields. The examples include additional fields for the \'us_ach_bank\' payout method.
     * @summary Validate Beneficiary
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {BeneficiaryValidateBody} beneficiaryValidateBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseApi
     */
    public validateBeneficiary(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, beneficiaryValidateBody: BeneficiaryValidateBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseApiFp(this.configuration).validateBeneficiary(accessKey, contentType, salt, signature, timestamp, beneficiaryValidateBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DisburseUploadDocumentsApi - axios parameter creator
 * @export
 */
export const DisburseUploadDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a document file that was previously uploaded to a specific payout.
         * @summary Delete Document of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} fileId ID of the specific document file. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentOfPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'timestamp', timestamp)
            // verify required parameter 'payout' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'payout', payout)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteDocumentOfPayout', 'fileId', fileId)
            const localVarPath = `/v1/payouts/{payout}/documents/{file_id}`
                .replace(`{${"payout"}}`, encodeURIComponent(String(payout)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all document files that were previously uploaded to a specific payout.
         * @summary Delete All Documents of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsOfPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteDocumentsOfPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteDocumentsOfPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteDocumentsOfPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteDocumentsOfPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteDocumentsOfPayout', 'timestamp', timestamp)
            // verify required parameter 'payout' is not null or undefined
            assertParamExists('deleteDocumentsOfPayout', 'payout', payout)
            const localVarPath = `/v1/payouts/{payout}/documents/`
                .replace(`{${"payout"}}`, encodeURIComponent(String(payout)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
         * @summary Retrieve Document of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} fileId ID of the specific document file. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentOfPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'timestamp', timestamp)
            // verify required parameter 'payout' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'payout', payout)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getDocumentOfPayout', 'fileId', fileId)
            const localVarPath = `/v1/payouts/{payout}/documents/{file_id}`
                .replace(`{${"payout"}}`, encodeURIComponent(String(payout)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
         * @summary List Documents of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentsOfPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listDocumentsOfPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listDocumentsOfPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listDocumentsOfPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listDocumentsOfPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listDocumentsOfPayout', 'timestamp', timestamp)
            // verify required parameter 'payout' is not null or undefined
            assertParamExists('listDocumentsOfPayout', 'payout', payout)
            const localVarPath = `/v1/payouts/{payout}/documents/`
                .replace(`{${"payout"}}`, encodeURIComponent(String(payout)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload one supporting document file or multiple document files to a specific payout. These documents include ID scans, company registrations, and all other documents that support the validity of the payout. A file can be uploaded only when the payout is in a **Created**, **Hold**, or **Pending** status.
         * @summary Upload Documents to Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **multipart/form-data**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} file Use the &#x60;-F&#x60; or &#x60;--form&#x60; parameter to define the path to the document file on your local machine. Supported file types include \&#39;*.pdf\&#39;, \&#39;*.doc\&#39;, \&#39;*.docx\&#39;, \&#39;.*csv\&#39;, \&#39;*.jpeg\&#39;, \&#39;*.jpg\&#39;, \&#39;*.gif\&#39;, \&#39;*.png\&#39;. Format of input must follow the &#x60;multipart/form-data&#x60; protocol. Use the &#x60;files&#x60; parameter to upload multiple files.&lt;BR&gt;**Note**&lt;BR&gt; * Maximum number of files that can be uploaded in one request is 10.&lt;BR&gt;* Maximum size of files that can be uploaded in one request is 20 MB.&lt;BR&gt;* Document file name should be up to 200 characters long.
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentsToPayout: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, file: string, payout: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'timestamp', timestamp)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'file', file)
            // verify required parameter 'payout' is not null or undefined
            assertParamExists('uploadDocumentsToPayout', 'payout', payout)
            const localVarPath = `/v1/files/documents/payout/{payout}`
                .replace(`{${"payout"}}`, encodeURIComponent(String(payout)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            if (file != null) {
                localVarHeaderParameter['file'] = String(file);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisburseUploadDocumentsApi - functional programming interface
 * @export
 */
export const DisburseUploadDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisburseUploadDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a document file that was previously uploaded to a specific payout.
         * @summary Delete Document of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} fileId ID of the specific document file. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentOfPayout(accessKey, contentType, salt, signature, timestamp, payout, fileId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseUploadDocumentsApi.deleteDocumentOfPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete all document files that were previously uploaded to a specific payout.
         * @summary Delete All Documents of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentsOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentsOfPayout(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseUploadDocumentsApi.deleteDocumentsOfPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
         * @summary Retrieve Document of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} fileId ID of the specific document file. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20065>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentOfPayout(accessKey, contentType, salt, signature, timestamp, payout, fileId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseUploadDocumentsApi.getDocumentOfPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
         * @summary List Documents of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocumentsOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20065>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocumentsOfPayout(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseUploadDocumentsApi.listDocumentsOfPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload one supporting document file or multiple document files to a specific payout. These documents include ID scans, company registrations, and all other documents that support the validity of the payout. A file can be uploaded only when the payout is in a **Created**, **Hold**, or **Pending** status.
         * @summary Upload Documents to Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **multipart/form-data**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} file Use the &#x60;-F&#x60; or &#x60;--form&#x60; parameter to define the path to the document file on your local machine. Supported file types include \&#39;*.pdf\&#39;, \&#39;*.doc\&#39;, \&#39;*.docx\&#39;, \&#39;.*csv\&#39;, \&#39;*.jpeg\&#39;, \&#39;*.jpg\&#39;, \&#39;*.gif\&#39;, \&#39;*.png\&#39;. Format of input must follow the &#x60;multipart/form-data&#x60; protocol. Use the &#x60;files&#x60; parameter to upload multiple files.&lt;BR&gt;**Note**&lt;BR&gt; * Maximum number of files that can be uploaded in one request is 10.&lt;BR&gt;* Maximum size of files that can be uploaded in one request is 20 MB.&lt;BR&gt;* Document file name should be up to 200 characters long.
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocumentsToPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, file: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20065>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocumentsToPayout(accessKey, contentType, salt, signature, timestamp, file, payout, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisburseUploadDocumentsApi.uploadDocumentsToPayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DisburseUploadDocumentsApi - factory interface
 * @export
 */
export const DisburseUploadDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisburseUploadDocumentsApiFp(configuration)
    return {
        /**
         * Delete a document file that was previously uploaded to a specific payout.
         * @summary Delete Document of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} fileId ID of the specific document file. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20066> {
            return localVarFp.deleteDocumentOfPayout(accessKey, contentType, salt, signature, timestamp, payout, fileId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all document files that were previously uploaded to a specific payout.
         * @summary Delete All Documents of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20066> {
            return localVarFp.deleteDocumentsOfPayout(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
         * @summary Retrieve Document of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} fileId ID of the specific document file. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20065> {
            return localVarFp.getDocumentOfPayout(accessKey, contentType, salt, signature, timestamp, payout, fileId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
         * @summary List Documents of Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentsOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20065> {
            return localVarFp.listDocumentsOfPayout(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload one supporting document file or multiple document files to a specific payout. These documents include ID scans, company registrations, and all other documents that support the validity of the payout. A file can be uploaded only when the payout is in a **Created**, **Hold**, or **Pending** status.
         * @summary Upload Documents to Payout
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **multipart/form-data**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} file Use the &#x60;-F&#x60; or &#x60;--form&#x60; parameter to define the path to the document file on your local machine. Supported file types include \&#39;*.pdf\&#39;, \&#39;*.doc\&#39;, \&#39;*.docx\&#39;, \&#39;.*csv\&#39;, \&#39;*.jpeg\&#39;, \&#39;*.jpg\&#39;, \&#39;*.gif\&#39;, \&#39;*.png\&#39;. Format of input must follow the &#x60;multipart/form-data&#x60; protocol. Use the &#x60;files&#x60; parameter to upload multiple files.&lt;BR&gt;**Note**&lt;BR&gt; * Maximum number of files that can be uploaded in one request is 10.&lt;BR&gt;* Maximum size of files that can be uploaded in one request is 20 MB.&lt;BR&gt;* Document file name should be up to 200 characters long.
         * @param {string} payout ID of the payout. String starting with **payout_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentsToPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, file: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20065> {
            return localVarFp.uploadDocumentsToPayout(accessKey, contentType, salt, signature, timestamp, file, payout, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisburseUploadDocumentsApi - object-oriented interface
 * @export
 * @class DisburseUploadDocumentsApi
 * @extends {BaseAPI}
 */
export class DisburseUploadDocumentsApi extends BaseAPI {
    /**
     * Delete a document file that was previously uploaded to a specific payout.
     * @summary Delete Document of Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payout ID of the payout. String starting with **payout_**.
     * @param {string} fileId ID of the specific document file. UUID.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseUploadDocumentsApi
     */
    public deleteDocumentOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseUploadDocumentsApiFp(this.configuration).deleteDocumentOfPayout(accessKey, contentType, salt, signature, timestamp, payout, fileId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all document files that were previously uploaded to a specific payout.
     * @summary Delete All Documents of Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payout ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseUploadDocumentsApi
     */
    public deleteDocumentsOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseUploadDocumentsApiFp(this.configuration).deleteDocumentsOfPayout(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
     * @summary Retrieve Document of Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payout ID of the payout. String starting with **payout_**.
     * @param {string} fileId ID of the specific document file. UUID.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseUploadDocumentsApi
     */
    public getDocumentOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, fileId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseUploadDocumentsApiFp(this.configuration).getDocumentOfPayout(accessKey, contentType, salt, signature, timestamp, payout, fileId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of all supporting document files that were previously uploaded to a specific payout.
     * @summary List Documents of Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payout ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseUploadDocumentsApi
     */
    public listDocumentsOfPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseUploadDocumentsApiFp(this.configuration).listDocumentsOfPayout(accessKey, contentType, salt, signature, timestamp, payout, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload one supporting document file or multiple document files to a specific payout. These documents include ID scans, company registrations, and all other documents that support the validity of the payout. A file can be uploaded only when the payout is in a **Created**, **Hold**, or **Pending** status.
     * @summary Upload Documents to Payout
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **multipart/form-data**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} file Use the &#x60;-F&#x60; or &#x60;--form&#x60; parameter to define the path to the document file on your local machine. Supported file types include \&#39;*.pdf\&#39;, \&#39;*.doc\&#39;, \&#39;*.docx\&#39;, \&#39;.*csv\&#39;, \&#39;*.jpeg\&#39;, \&#39;*.jpg\&#39;, \&#39;*.gif\&#39;, \&#39;*.png\&#39;. Format of input must follow the &#x60;multipart/form-data&#x60; protocol. Use the &#x60;files&#x60; parameter to upload multiple files.&lt;BR&gt;**Note**&lt;BR&gt; * Maximum number of files that can be uploaded in one request is 10.&lt;BR&gt;* Maximum size of files that can be uploaded in one request is 20 MB.&lt;BR&gt;* Document file name should be up to 200 characters long.
     * @param {string} payout ID of the payout. String starting with **payout_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisburseUploadDocumentsApi
     */
    public uploadDocumentsToPayout(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, file: string, payout: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisburseUploadDocumentsApiFp(this.configuration).uploadDocumentsToPayout(accessKey, contentType, salt, signature, timestamp, file, payout, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DisputeApi - axios parameter creator
 * @export
 */
export const DisputeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the details of a dispute.
         * @summary Retrieve a dispute
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} disputeId ID of the dispute you want to retrieve. String starting with dispute_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispute: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disputeId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getDispute', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getDispute', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getDispute', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getDispute', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getDispute', 'timestamp', timestamp)
            // verify required parameter 'disputeId' is not null or undefined
            assertParamExists('getDispute', 'disputeId', disputeId)
            const localVarPath = `/v1/disputes/{disputeId}`
                .replace(`{${"disputeId"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a detailed list of \'dispute\' objects.
         * @summary Retrieve list of disputes
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the dispute created before the first dispute you want to retrieve. String starting with dispute_.
         * @param {string} [endingBefore] The ID of the dispute created after the last dispute you want to retrieve. String starting with dispute_.
         * @param {string} [limit] The maximum number of disputes to return. Range is 1-100. Default is 10.
         * @param {GetDisputesListByOrgIdStatusEnum} [status] Filters the list for disputes with the specified dispute status.
         * @param {string} [payment] The ID of the payment that is linked to the dispute. String starting with payment_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisputesListByOrgId: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, status?: GetDisputesListByOrgIdStatusEnum, payment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getDisputesListByOrgId', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getDisputesListByOrgId', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getDisputesListByOrgId', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getDisputesListByOrgId', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getDisputesListByOrgId', 'timestamp', timestamp)
            const localVarPath = `/v1/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (payment !== undefined) {
                localVarQueryParameter['payment'] = payment;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisputeApi - functional programming interface
 * @export
 */
export const DisputeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisputeApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the details of a dispute.
         * @summary Retrieve a dispute
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} disputeId ID of the dispute you want to retrieve. String starting with dispute_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDispute(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disputeId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDispute(accessKey, contentType, salt, signature, timestamp, disputeId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisputeApi.getDispute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a detailed list of \'dispute\' objects.
         * @summary Retrieve list of disputes
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the dispute created before the first dispute you want to retrieve. String starting with dispute_.
         * @param {string} [endingBefore] The ID of the dispute created after the last dispute you want to retrieve. String starting with dispute_.
         * @param {string} [limit] The maximum number of disputes to return. Range is 1-100. Default is 10.
         * @param {GetDisputesListByOrgIdStatusEnum} [status] Filters the list for disputes with the specified dispute status.
         * @param {string} [payment] The ID of the payment that is linked to the dispute. String starting with payment_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisputesListByOrgId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, status?: GetDisputesListByOrgIdStatusEnum, payment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisputesListByOrgId(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, status, payment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisputeApi.getDisputesListByOrgId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DisputeApi - factory interface
 * @export
 */
export const DisputeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisputeApiFp(configuration)
    return {
        /**
         * Retrieve the details of a dispute.
         * @summary Retrieve a dispute
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} disputeId ID of the dispute you want to retrieve. String starting with dispute_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispute(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disputeId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20035> {
            return localVarFp.getDispute(accessKey, contentType, salt, signature, timestamp, disputeId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a detailed list of \'dispute\' objects.
         * @summary Retrieve list of disputes
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [startingAfter] The ID of the dispute created before the first dispute you want to retrieve. String starting with dispute_.
         * @param {string} [endingBefore] The ID of the dispute created after the last dispute you want to retrieve. String starting with dispute_.
         * @param {string} [limit] The maximum number of disputes to return. Range is 1-100. Default is 10.
         * @param {GetDisputesListByOrgIdStatusEnum} [status] Filters the list for disputes with the specified dispute status.
         * @param {string} [payment] The ID of the payment that is linked to the dispute. String starting with payment_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisputesListByOrgId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, status?: GetDisputesListByOrgIdStatusEnum, payment?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20034> {
            return localVarFp.getDisputesListByOrgId(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, status, payment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisputeApi - object-oriented interface
 * @export
 * @class DisputeApi
 * @extends {BaseAPI}
 */
export class DisputeApi extends BaseAPI {
    /**
     * Retrieve the details of a dispute.
     * @summary Retrieve a dispute
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} disputeId ID of the dispute you want to retrieve. String starting with dispute_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public getDispute(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, disputeId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return DisputeApiFp(this.configuration).getDispute(accessKey, contentType, salt, signature, timestamp, disputeId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a detailed list of \'dispute\' objects.
     * @summary Retrieve list of disputes
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [startingAfter] The ID of the dispute created before the first dispute you want to retrieve. String starting with dispute_.
     * @param {string} [endingBefore] The ID of the dispute created after the last dispute you want to retrieve. String starting with dispute_.
     * @param {string} [limit] The maximum number of disputes to return. Range is 1-100. Default is 10.
     * @param {GetDisputesListByOrgIdStatusEnum} [status] Filters the list for disputes with the specified dispute status.
     * @param {string} [payment] The ID of the payment that is linked to the dispute. String starting with payment_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public getDisputesListByOrgId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, startingAfter?: string, endingBefore?: string, limit?: string, status?: GetDisputesListByOrgIdStatusEnum, payment?: string, options?: RawAxiosRequestConfig) {
        return DisputeApiFp(this.configuration).getDisputesListByOrgId(accessKey, contentType, salt, signature, timestamp, idempotency, startingAfter, endingBefore, limit, status, payment, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetDisputesListByOrgIdStatusEnum = {
    Act: 'ACT',
    Rvw: 'RVW',
    Pra: 'PRA',
    Arb: 'ARB',
    Los: 'LOS',
    Win: 'WIN',
    Rev: 'REV'
} as const;
export type GetDisputesListByOrgIdStatusEnum = typeof GetDisputesListByOrgIdStatusEnum[keyof typeof GetDisputesListByOrgIdStatusEnum];


/**
 * EWalletsApi - axios parameter creator
 * @export
 */
export const EWalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transfer virtual currency to a Rapyd Wallet account.<BR>If the account does not already exist for the indicated currency, it is created.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Added Webhook\'.
         * @summary Add Funds to Wallet Account
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountDepositBody} accountDepositBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToWalletAccount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountDepositBody: AccountDepositBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('addFundsToWalletAccount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('addFundsToWalletAccount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('addFundsToWalletAccount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('addFundsToWalletAccount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('addFundsToWalletAccount', 'timestamp', timestamp)
            // verify required parameter 'accountDepositBody' is not null or undefined
            assertParamExists('addFundsToWalletAccount', 'accountDepositBody', accountDepositBody)
            const localVarPath = `/v1/account/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountDepositBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a personal contact to a company wallet or client wallet.
         * @summary Add Contact to Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {EwalletIdContactsBody} ewalletIdContactsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEwalletContact: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, ewalletIdContactsBody: EwalletIdContactsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createEwalletContact', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createEwalletContact', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createEwalletContact', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createEwalletContact', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createEwalletContact', 'timestamp', timestamp)
            // verify required parameter 'ewalletId' is not null or undefined
            assertParamExists('createEwalletContact', 'ewalletId', ewalletId)
            // verify required parameter 'ewalletIdContactsBody' is not null or undefined
            assertParamExists('createEwalletContact', 'ewalletIdContactsBody', ewalletIdContactsBody)
            const localVarPath = `/v1/ewallets/{ewalletId}/contacts`
                .replace(`{${"ewalletId"}}`, encodeURIComponent(String(ewalletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ewalletIdContactsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Rapyd Wallet.
         * @summary Create Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1EwalletsBody} v1EwalletsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1EwalletsBody: V1EwalletsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createUser', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createUser', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createUser', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createUser', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createUser', 'timestamp', timestamp)
            // verify required parameter 'v1EwalletsBody' is not null or undefined
            assertParamExists('createUser', 'v1EwalletsBody', v1EwalletsBody)
            const localVarPath = `/v1/ewallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1EwalletsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a personal contact from a company wallet or client wallet.
         * @summary Delete Wallet Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEwalletContact: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteEwalletContact', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteEwalletContact', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteEwalletContact', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteEwalletContact', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteEwalletContact', 'timestamp', timestamp)
            // verify required parameter 'ewalletId' is not null or undefined
            assertParamExists('deleteEwalletContact', 'ewalletId', ewalletId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteEwalletContact', 'contactId', contactId)
            const localVarPath = `/v1/ewallets/{ewalletId}/contacts/{contactId}`
                .replace(`{${"ewalletId"}}`, encodeURIComponent(String(ewalletId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Rapyd Wallet. Use this method when the wallet has never been used. This method triggers the Wallet Deleted webhook. This webhook contains the same information as the response.
         * @summary Delete Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteUser', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteUser', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteUser', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteUser', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteUser', 'timestamp', timestamp)
            // verify required parameter 'ewalletToken' is not null or undefined
            assertParamExists('deleteUser', 'ewalletToken', ewalletToken)
            const localVarPath = `/v1/ewallets/{ewalletToken}`
                .replace(`{${"ewalletToken"}}`, encodeURIComponent(String(ewalletToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific \'Add Funds to Wallet Account\' request.<BR> Use this method in the sandbox for testing purposes.
         * @summary Get Details of Add Funds Request
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} id ID of the \&#39;Add Funds to Wallet Account\&#39; request, from the &#x60;id&#x60; field in the data object of the response. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailsOfAddFundstoWalletAccount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('detailsOfAddFundstoWalletAccount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('detailsOfAddFundstoWalletAccount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('detailsOfAddFundstoWalletAccount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('detailsOfAddFundstoWalletAccount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('detailsOfAddFundstoWalletAccount', 'timestamp', timestamp)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detailsOfAddFundstoWalletAccount', 'id', id)
            const localVarPath = `/v1/account/deposit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer funds between Rapyd Wallets.
         * @summary Transfer Funds Between Wallets
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountTransferBody} accountTransferBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundsTransfer: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountTransferBody: AccountTransferBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('fundsTransfer', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('fundsTransfer', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('fundsTransfer', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('fundsTransfer', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('fundsTransfer', 'timestamp', timestamp)
            // verify required parameter 'accountTransferBody' is not null or undefined
            assertParamExists('fundsTransfer', 'accountTransferBody', accountTransferBody)
            const localVarPath = `/v1/account/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountTransferBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific \'Remove Funds From Wallet Account\' request.<BR>Use this method in the sandbox for testing purposes.
         * @summary Get Details of Remove Funds Request
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} id ID of the \&#39;Remove Funds From Wallet Account\&#39; request, from the &#x60;id&#x60; field in the &#x60;data&#x60; object of the response. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsOfRemoveFundsRequest: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getDetailsOfRemoveFundsRequest', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getDetailsOfRemoveFundsRequest', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getDetailsOfRemoveFundsRequest', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getDetailsOfRemoveFundsRequest', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getDetailsOfRemoveFundsRequest', 'timestamp', timestamp)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDetailsOfRemoveFundsRequest', 'id', id)
            const localVarPath = `/v1/account/withdraw{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a contact for an existing Rapyd Wallet.
         * @summary Retrieve Wallet Contact.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId One of two values. either ID of the contact - String starting with the prefix **cont_** or Contact reference ID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEwalletContact: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getEwalletContact', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getEwalletContact', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getEwalletContact', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getEwalletContact', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getEwalletContact', 'timestamp', timestamp)
            // verify required parameter 'ewalletId' is not null or undefined
            assertParamExists('getEwalletContact', 'ewalletId', ewalletId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getEwalletContact', 'contactId', contactId)
            const localVarPath = `/v1/ewallets/{ewalletId}/contacts/{contactId}`
                .replace(`{${"ewalletId"}}`, encodeURIComponent(String(ewalletId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify the compliance status of a personal contact.
         * @summary Get Compliance Status of Personal Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with **cont_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEwalletContactComplianceLevels: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'timestamp', timestamp)
            // verify required parameter 'ewalletId' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'ewalletId', ewalletId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getEwalletContactComplianceLevels', 'contactId', contactId)
            const localVarPath = `/v1/ewallets/{ewalletId}/contacts/{contactId}/compliance_levels`
                .replace(`{${"ewalletId"}}`, encodeURIComponent(String(ewalletId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all contacts for a wallet.
         * @summary List Contacts of Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEwalletContacts: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getEwalletContacts', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getEwalletContacts', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getEwalletContacts', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getEwalletContacts', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getEwalletContacts', 'timestamp', timestamp)
            // verify required parameter 'ewalletId' is not null or undefined
            assertParamExists('getEwalletContacts', 'ewalletId', ewalletId)
            const localVarPath = `/v1/ewallets/{ewalletId}/contacts`
                .replace(`{${"ewalletId"}}`, encodeURIComponent(String(ewalletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a Rapyd Wallet.
         * @summary Retrieve Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getUser', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getUser', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getUser', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getUser', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUser', 'timestamp', timestamp)
            // verify required parameter 'ewalletToken' is not null or undefined
            assertParamExists('getUser', 'ewalletToken', ewalletToken)
            const localVarPath = `/v1/ewallets/{ewalletToken}`
                .replace(`{${"ewalletToken"}}`, encodeURIComponent(String(ewalletToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of the balances in a Rapyd Wallet.
         * @summary Retrieve Wallet Balances
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getUserAccounts', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getUserAccounts', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getUserAccounts', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getUserAccounts', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserAccounts', 'timestamp', timestamp)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getUserAccounts', 'walletId', walletId)
            const localVarPath = `/v1/ewallets/{walletId}/accounts`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a wallet transaction.
         * @summary Get Details of Wallet Transaction
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
         * @param {number} transactionId ID of the transaction, from the response to List Wallet Transactions. String starting with wt_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionDetails: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, transactionId: number, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'timestamp', timestamp)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'walletId', walletId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getUserTransactionDetails', 'transactionId', transactionId)
            const localVarPath = `/v1/ewallets/{walletId}/transactions/{transactionId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all transactions related to a wallet.
         * @summary List Wallet Transactions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
         * @param {number} balance The updated wallet balance after successful completion of the transaction.
         * @param {string} pageSize Number of results per page.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency of the transactions. Uppercase.
         * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
         * @param {string} [endingBefore] The ID of the wallet transaction created after the last wallet transaction you want to retrieve. String starting with **wt_**.
         * @param {string} [pageNumber] Page number to retrieve.
         * @param {string} [startDate] Timestamp of the first transaction or earlier, in Unix time.
         * @param {string} [startingAfter] The ID of the wallet transaction created before the first wallet transaction you want to retrieve. String starting with **wt_**.
         * @param {string} [type] Type of transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactions: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, balance: number, pageSize: string, idempotency?: string, currency?: string, endDate?: string, endingBefore?: string, pageNumber?: string, startDate?: string, startingAfter?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getUserTransactions', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getUserTransactions', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getUserTransactions', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getUserTransactions', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTransactions', 'timestamp', timestamp)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getUserTransactions', 'walletId', walletId)
            // verify required parameter 'balance' is not null or undefined
            assertParamExists('getUserTransactions', 'balance', balance)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getUserTransactions', 'pageSize', pageSize)
            const localVarPath = `/v1/ewallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (balance !== undefined) {
                localVarQueryParameter['balance'] = balance;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of Rapyd Wallets. You can filter the list with query parameters.
         * @summary List eWallets
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [phoneNumber] Phone number of the Rapyd Wallet in E.164 format.
         * @param {string} [email] Email address of the wallet owner.
         * @param {string} [ewalletReferenceId] Wallet ID defined by the customer or end user.
         * @param {number} [pageNumber] Page number to retrieve. If &#x60;page_number&#x60; is not specified, page 1 is retrieved.
         * @param {number} [pageSize] Number of results per page.
         * @param {string} [type] Type of wallet - company, person, client.
         * @param {number} [minBalance] 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, phoneNumber?: string, email?: string, ewalletReferenceId?: string, pageNumber?: number, pageSize?: number, type?: string, minBalance?: number, currency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getUsers', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getUsers', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getUsers', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getUsers', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUsers', 'timestamp', timestamp)
            const localVarPath = `/v1/ewallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phone_number'] = phoneNumber;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (ewalletReferenceId !== undefined) {
                localVarQueryParameter['ewallet_reference_id'] = ewalletReferenceId;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (minBalance !== undefined) {
                localVarQueryParameter['min_balance'] = minBalance;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Put a hold on funds in the wallet. Sandbox only.<BR> This action transfers funds from the available balance to the on-hold balance. If the wallet does not have enough funds in the available balance in the specified currency, the transfer fails.<BR>This method triggers the **Transfer Funds Between Balances** webhook. This webhook contains the same information as the response.<BR>The customer cannot move funds that are on hold until the client releases the hold.<BR>This method is relevant for **person** and **company** wallets.
         * @summary Put Funds on Hold
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BalanceHoldBody} balanceHoldBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundsOnHold: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, balanceHoldBody: BalanceHoldBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('putFundsOnHold', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('putFundsOnHold', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('putFundsOnHold', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('putFundsOnHold', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('putFundsOnHold', 'timestamp', timestamp)
            // verify required parameter 'balanceHoldBody' is not null or undefined
            assertParamExists('putFundsOnHold', 'balanceHoldBody', balanceHoldBody)
            const localVarPath = `/v1/ewallets/accounts/balance/hold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(balanceHoldBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a limit on a wallet account.
         * @summary Delete Wallet Account Limit
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountLimit: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('removeAccountLimit', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('removeAccountLimit', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('removeAccountLimit', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('removeAccountLimit', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('removeAccountLimit', 'timestamp', timestamp)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('removeAccountLimit', 'walletId', walletId)
            const localVarPath = `/v1/ewallets/{walletId}/account/limits`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the maximum balance limit or the minimum balance threshold for an existing wallet account.
         * @summary Set Wallet Account Limit
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {AccountLimitsBody} [accountLimitsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountLimit: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, accountLimitsBody?: AccountLimitsBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('setAccountLimit', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('setAccountLimit', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('setAccountLimit', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('setAccountLimit', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('setAccountLimit', 'timestamp', timestamp)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('setAccountLimit', 'walletId', walletId)
            const localVarPath = `/v1/ewallets/{walletId}/account/limits`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountLimitsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Respond to a funds transfer between wallets. The transferee uses this method to accept or decline the transfer.
         * @summary Set Transfer Response
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {TransferResponseBody} transferResponseBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFundsTransferResponse: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, transferResponseBody: TransferResponseBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('setFundsTransferResponse', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('setFundsTransferResponse', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('setFundsTransferResponse', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('setFundsTransferResponse', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('setFundsTransferResponse', 'timestamp', timestamp)
            // verify required parameter 'transferResponseBody' is not null or undefined
            assertParamExists('setFundsTransferResponse', 'transferResponseBody', transferResponseBody)
            const localVarPath = `/v1/account/transfer/response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferResponseBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a contact for a Rapyd Wallet.
         * @summary Update Wallet Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
         * @param {Contact} contact 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEwalletContact: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, contact: Contact, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateEwalletContact', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateEwalletContact', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateEwalletContact', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateEwalletContact', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateEwalletContact', 'timestamp', timestamp)
            // verify required parameter 'ewalletId' is not null or undefined
            assertParamExists('updateEwalletContact', 'ewalletId', ewalletId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('updateEwalletContact', 'contactId', contactId)
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('updateEwalletContact', 'contact', contact)
            const localVarPath = `/v1/ewallets/{ewalletId}/contacts/{contactId}`
                .replace(`{${"ewalletId"}}`, encodeURIComponent(String(ewalletId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Wallet Status
         * @summary Change Wallet Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the Rapyd Wallet. String starting with **ewallet_**. Required when phone number is not used.
         * @param {UpdateEwalletStatusStatusEnum} status Status of the wallet. One of the following: ACT - Active, DIS - Disabled, CLO - Close.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEwalletStatus: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, status: UpdateEwalletStatusStatusEnum, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateEwalletStatus', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateEwalletStatus', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateEwalletStatus', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateEwalletStatus', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateEwalletStatus', 'timestamp', timestamp)
            // verify required parameter 'ewalletToken' is not null or undefined
            assertParamExists('updateEwalletStatus', 'ewalletToken', ewalletToken)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateEwalletStatus', 'status', status)
            const localVarPath = `/v1/ewallets/{ewalletToken}/statuses/{status}`
                .replace(`{${"ewalletToken"}}`, encodeURIComponent(String(ewalletToken)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a Rapyd Wallet.
         * @summary Update Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {EwalletsEwalletTokenBody} ewalletsEwalletTokenBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatedUser: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, ewalletsEwalletTokenBody: EwalletsEwalletTokenBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updatedUser', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updatedUser', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updatedUser', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updatedUser', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updatedUser', 'timestamp', timestamp)
            // verify required parameter 'ewalletToken' is not null or undefined
            assertParamExists('updatedUser', 'ewalletToken', ewalletToken)
            // verify required parameter 'ewalletsEwalletTokenBody' is not null or undefined
            assertParamExists('updatedUser', 'ewalletsEwalletTokenBody', ewalletsEwalletTokenBody)
            const localVarPath = `/v1/ewallets/{ewalletToken}`
                .replace(`{${"ewalletToken"}}`, encodeURIComponent(String(ewalletToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ewalletsEwalletTokenBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the virtual accounts that are attached to a Rapyd Wallet.
         * @summary List Virtual Accounts by Rapyd Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewallet ID of the Rapyd Wallet that the virtual accounts were issued to. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualAccountsByRapydWallet: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewallet: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('virtualAccountsByRapydWallet', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('virtualAccountsByRapydWallet', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('virtualAccountsByRapydWallet', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('virtualAccountsByRapydWallet', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('virtualAccountsByRapydWallet', 'timestamp', timestamp)
            // verify required parameter 'ewallet' is not null or undefined
            assertParamExists('virtualAccountsByRapydWallet', 'ewallet', ewallet)
            const localVarPath = `/v1/ewallets/{ewallet}/virtual_accounts`
                .replace(`{${"ewallet"}}`, encodeURIComponent(String(ewallet)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove virtual currency from a Rapyd Wallet account.<BR>If the account does not have sufficient funds in the indicated currency, the funds transfer fails.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Removed\' Webhook
         * @summary Remove Funds From Wallet Account
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountWithdrawBody} accountWithdrawBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawFundsFromWalletAccount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountWithdrawBody: AccountWithdrawBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('withdrawFundsFromWalletAccount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('withdrawFundsFromWalletAccount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('withdrawFundsFromWalletAccount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('withdrawFundsFromWalletAccount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('withdrawFundsFromWalletAccount', 'timestamp', timestamp)
            // verify required parameter 'accountWithdrawBody' is not null or undefined
            assertParamExists('withdrawFundsFromWalletAccount', 'accountWithdrawBody', accountWithdrawBody)
            const localVarPath = `/v1/account/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountWithdrawBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EWalletsApi - functional programming interface
 * @export
 */
export const EWalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EWalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * Transfer virtual currency to a Rapyd Wallet account.<BR>If the account does not already exist for the indicated currency, it is created.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Added Webhook\'.
         * @summary Add Funds to Wallet Account
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountDepositBody} accountDepositBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFundsToWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountDepositBody: AccountDepositBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20068>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFundsToWalletAccount(accessKey, contentType, salt, signature, timestamp, accountDepositBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.addFundsToWalletAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a personal contact to a company wallet or client wallet.
         * @summary Add Contact to Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {EwalletIdContactsBody} ewalletIdContactsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, ewalletIdContactsBody: EwalletIdContactsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20071>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, ewalletIdContactsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.createEwalletContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Rapyd Wallet.
         * @summary Create Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1EwalletsBody} v1EwalletsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1EwalletsBody: V1EwalletsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20098>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(accessKey, contentType, salt, signature, timestamp, v1EwalletsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a personal contact from a company wallet or client wallet.
         * @summary Delete Wallet Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20072>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.deleteEwalletContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Rapyd Wallet. Use this method when the wallet has never been used. This method triggers the Wallet Deleted webhook. This webhook contains the same information as the response.
         * @summary Delete Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific \'Add Funds to Wallet Account\' request.<BR> Use this method in the sandbox for testing purposes.
         * @summary Get Details of Add Funds Request
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} id ID of the \&#39;Add Funds to Wallet Account\&#39; request, from the &#x60;id&#x60; field in the data object of the response. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailsOfAddFundstoWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20068>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailsOfAddFundstoWalletAccount(accessKey, contentType, salt, signature, timestamp, id, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.detailsOfAddFundstoWalletAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfer funds between Rapyd Wallets.
         * @summary Transfer Funds Between Wallets
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountTransferBody} accountTransferBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fundsTransfer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountTransferBody: AccountTransferBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20067>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fundsTransfer(accessKey, contentType, salt, signature, timestamp, accountTransferBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.fundsTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific \'Remove Funds From Wallet Account\' request.<BR>Use this method in the sandbox for testing purposes.
         * @summary Get Details of Remove Funds Request
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} id ID of the \&#39;Remove Funds From Wallet Account\&#39; request, from the &#x60;id&#x60; field in the &#x60;data&#x60; object of the response. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailsOfRemoveFundsRequest(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20068>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailsOfRemoveFundsRequest(accessKey, contentType, salt, signature, timestamp, id, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getDetailsOfRemoveFundsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a contact for an existing Rapyd Wallet.
         * @summary Retrieve Wallet Contact.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId One of two values. either ID of the contact - String starting with the prefix **cont_** or Contact reference ID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20071>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getEwalletContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify the compliance status of a personal contact.
         * @summary Get Compliance Status of Personal Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with **cont_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEwalletContactComplianceLevels(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20073>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEwalletContactComplianceLevels(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getEwalletContactComplianceLevels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all contacts for a wallet.
         * @summary List Contacts of Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEwalletContacts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20070>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEwalletContacts(accessKey, contentType, salt, signature, timestamp, ewalletId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getEwalletContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a Rapyd Wallet.
         * @summary Retrieve Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20098>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of the balances in a Rapyd Wallet.
         * @summary Retrieve Wallet Balances
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccounts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20099>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccounts(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getUserAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a wallet transaction.
         * @summary Get Details of Wallet Transaction
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
         * @param {number} transactionId ID of the transaction, from the response to List Wallet Transactions. String starting with wt_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactionDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, transactionId: number, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200102>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransactionDetails(accessKey, contentType, salt, signature, timestamp, walletId, transactionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getUserTransactionDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all transactions related to a wallet.
         * @summary List Wallet Transactions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
         * @param {number} balance The updated wallet balance after successful completion of the transaction.
         * @param {string} pageSize Number of results per page.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency of the transactions. Uppercase.
         * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
         * @param {string} [endingBefore] The ID of the wallet transaction created after the last wallet transaction you want to retrieve. String starting with **wt_**.
         * @param {string} [pageNumber] Page number to retrieve.
         * @param {string} [startDate] Timestamp of the first transaction or earlier, in Unix time.
         * @param {string} [startingAfter] The ID of the wallet transaction created before the first wallet transaction you want to retrieve. String starting with **wt_**.
         * @param {string} [type] Type of transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactions(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, balance: number, pageSize: string, idempotency?: string, currency?: string, endDate?: string, endingBefore?: string, pageNumber?: string, startDate?: string, startingAfter?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200101>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransactions(accessKey, contentType, salt, signature, timestamp, walletId, balance, pageSize, idempotency, currency, endDate, endingBefore, pageNumber, startDate, startingAfter, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getUserTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of Rapyd Wallets. You can filter the list with query parameters.
         * @summary List eWallets
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [phoneNumber] Phone number of the Rapyd Wallet in E.164 format.
         * @param {string} [email] Email address of the wallet owner.
         * @param {string} [ewalletReferenceId] Wallet ID defined by the customer or end user.
         * @param {number} [pageNumber] Page number to retrieve. If &#x60;page_number&#x60; is not specified, page 1 is retrieved.
         * @param {number} [pageSize] Number of results per page.
         * @param {string} [type] Type of wallet - company, person, client.
         * @param {number} [minBalance] 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, phoneNumber?: string, email?: string, ewalletReferenceId?: string, pageNumber?: number, pageSize?: number, type?: string, minBalance?: number, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20097>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(accessKey, contentType, salt, signature, timestamp, idempotency, phoneNumber, email, ewalletReferenceId, pageNumber, pageSize, type, minBalance, currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Put a hold on funds in the wallet. Sandbox only.<BR> This action transfers funds from the available balance to the on-hold balance. If the wallet does not have enough funds in the available balance in the specified currency, the transfer fails.<BR>This method triggers the **Transfer Funds Between Balances** webhook. This webhook contains the same information as the response.<BR>The customer cannot move funds that are on hold until the client releases the hold.<BR>This method is relevant for **person** and **company** wallets.
         * @summary Put Funds on Hold
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BalanceHoldBody} balanceHoldBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundsOnHold(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, balanceHoldBody: BalanceHoldBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20069>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundsOnHold(accessKey, contentType, salt, signature, timestamp, balanceHoldBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.putFundsOnHold']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a limit on a wallet account.
         * @summary Delete Wallet Account Limit
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAccountLimit(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200100>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccountLimit(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.removeAccountLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the maximum balance limit or the minimum balance threshold for an existing wallet account.
         * @summary Set Wallet Account Limit
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {AccountLimitsBody} [accountLimitsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAccountLimit(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, accountLimitsBody?: AccountLimitsBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20099>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAccountLimit(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, accountLimitsBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.setAccountLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Respond to a funds transfer between wallets. The transferee uses this method to accept or decline the transfer.
         * @summary Set Transfer Response
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {TransferResponseBody} transferResponseBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFundsTransferResponse(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, transferResponseBody: TransferResponseBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20067>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFundsTransferResponse(accessKey, contentType, salt, signature, timestamp, transferResponseBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.setFundsTransferResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a contact for a Rapyd Wallet.
         * @summary Update Wallet Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
         * @param {Contact} contact 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, contact: Contact, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20071>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, contact, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.updateEwalletContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change Wallet Status
         * @summary Change Wallet Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the Rapyd Wallet. String starting with **ewallet_**. Required when phone number is not used.
         * @param {UpdateEwalletStatusStatusEnum} status Status of the wallet. One of the following: ACT - Active, DIS - Disabled, CLO - Close.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEwalletStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, status: UpdateEwalletStatusStatusEnum, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEwalletStatus(accessKey, contentType, salt, signature, timestamp, ewalletToken, status, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.updateEwalletStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a Rapyd Wallet.
         * @summary Update Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {EwalletsEwalletTokenBody} ewalletsEwalletTokenBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatedUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, ewalletsEwalletTokenBody: EwalletsEwalletTokenBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20098>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatedUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, ewalletsEwalletTokenBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.updatedUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the virtual accounts that are attached to a Rapyd Wallet.
         * @summary List Virtual Accounts by Rapyd Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewallet ID of the Rapyd Wallet that the virtual accounts were issued to. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualAccountsByRapydWallet(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewallet: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200103>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualAccountsByRapydWallet(accessKey, contentType, salt, signature, timestamp, ewallet, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.virtualAccountsByRapydWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove virtual currency from a Rapyd Wallet account.<BR>If the account does not have sufficient funds in the indicated currency, the funds transfer fails.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Removed\' Webhook
         * @summary Remove Funds From Wallet Account
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountWithdrawBody} accountWithdrawBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawFundsFromWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountWithdrawBody: AccountWithdrawBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20068>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawFundsFromWalletAccount(accessKey, contentType, salt, signature, timestamp, accountWithdrawBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EWalletsApi.withdrawFundsFromWalletAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EWalletsApi - factory interface
 * @export
 */
export const EWalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EWalletsApiFp(configuration)
    return {
        /**
         * Transfer virtual currency to a Rapyd Wallet account.<BR>If the account does not already exist for the indicated currency, it is created.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Added Webhook\'.
         * @summary Add Funds to Wallet Account
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountDepositBody} accountDepositBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountDepositBody: AccountDepositBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20068> {
            return localVarFp.addFundsToWalletAccount(accessKey, contentType, salt, signature, timestamp, accountDepositBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a personal contact to a company wallet or client wallet.
         * @summary Add Contact to Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {EwalletIdContactsBody} ewalletIdContactsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, ewalletIdContactsBody: EwalletIdContactsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20071> {
            return localVarFp.createEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, ewalletIdContactsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Rapyd Wallet.
         * @summary Create Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1EwalletsBody} v1EwalletsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1EwalletsBody: V1EwalletsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20098> {
            return localVarFp.createUser(accessKey, contentType, salt, signature, timestamp, v1EwalletsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a personal contact from a company wallet or client wallet.
         * @summary Delete Wallet Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20072> {
            return localVarFp.deleteEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Rapyd Wallet. Use this method when the wallet has never been used. This method triggers the Wallet Deleted webhook. This webhook contains the same information as the response.
         * @summary Delete Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20066> {
            return localVarFp.deleteUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific \'Add Funds to Wallet Account\' request.<BR> Use this method in the sandbox for testing purposes.
         * @summary Get Details of Add Funds Request
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} id ID of the \&#39;Add Funds to Wallet Account\&#39; request, from the &#x60;id&#x60; field in the data object of the response. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailsOfAddFundstoWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20068> {
            return localVarFp.detailsOfAddFundstoWalletAccount(accessKey, contentType, salt, signature, timestamp, id, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer funds between Rapyd Wallets.
         * @summary Transfer Funds Between Wallets
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountTransferBody} accountTransferBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundsTransfer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountTransferBody: AccountTransferBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20067> {
            return localVarFp.fundsTransfer(accessKey, contentType, salt, signature, timestamp, accountTransferBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific \'Remove Funds From Wallet Account\' request.<BR>Use this method in the sandbox for testing purposes.
         * @summary Get Details of Remove Funds Request
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} id ID of the \&#39;Remove Funds From Wallet Account\&#39; request, from the &#x60;id&#x60; field in the &#x60;data&#x60; object of the response. UUID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsOfRemoveFundsRequest(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20068> {
            return localVarFp.getDetailsOfRemoveFundsRequest(accessKey, contentType, salt, signature, timestamp, id, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a contact for an existing Rapyd Wallet.
         * @summary Retrieve Wallet Contact.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId One of two values. either ID of the contact - String starting with the prefix **cont_** or Contact reference ID.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20071> {
            return localVarFp.getEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify the compliance status of a personal contact.
         * @summary Get Compliance Status of Personal Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with **cont_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEwalletContactComplianceLevels(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20073> {
            return localVarFp.getEwalletContactComplianceLevels(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all contacts for a wallet.
         * @summary List Contacts of Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEwalletContacts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20070> {
            return localVarFp.getEwalletContacts(accessKey, contentType, salt, signature, timestamp, ewalletId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a Rapyd Wallet.
         * @summary Retrieve Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20098> {
            return localVarFp.getUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of the balances in a Rapyd Wallet.
         * @summary Retrieve Wallet Balances
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20099> {
            return localVarFp.getUserAccounts(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a wallet transaction.
         * @summary Get Details of Wallet Transaction
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
         * @param {number} transactionId ID of the transaction, from the response to List Wallet Transactions. String starting with wt_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, transactionId: number, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200102> {
            return localVarFp.getUserTransactionDetails(accessKey, contentType, salt, signature, timestamp, walletId, transactionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all transactions related to a wallet.
         * @summary List Wallet Transactions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
         * @param {number} balance The updated wallet balance after successful completion of the transaction.
         * @param {string} pageSize Number of results per page.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency of the transactions. Uppercase.
         * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
         * @param {string} [endingBefore] The ID of the wallet transaction created after the last wallet transaction you want to retrieve. String starting with **wt_**.
         * @param {string} [pageNumber] Page number to retrieve.
         * @param {string} [startDate] Timestamp of the first transaction or earlier, in Unix time.
         * @param {string} [startingAfter] The ID of the wallet transaction created before the first wallet transaction you want to retrieve. String starting with **wt_**.
         * @param {string} [type] Type of transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactions(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, balance: number, pageSize: string, idempotency?: string, currency?: string, endDate?: string, endingBefore?: string, pageNumber?: string, startDate?: string, startingAfter?: string, type?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200101> {
            return localVarFp.getUserTransactions(accessKey, contentType, salt, signature, timestamp, walletId, balance, pageSize, idempotency, currency, endDate, endingBefore, pageNumber, startDate, startingAfter, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of Rapyd Wallets. You can filter the list with query parameters.
         * @summary List eWallets
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [phoneNumber] Phone number of the Rapyd Wallet in E.164 format.
         * @param {string} [email] Email address of the wallet owner.
         * @param {string} [ewalletReferenceId] Wallet ID defined by the customer or end user.
         * @param {number} [pageNumber] Page number to retrieve. If &#x60;page_number&#x60; is not specified, page 1 is retrieved.
         * @param {number} [pageSize] Number of results per page.
         * @param {string} [type] Type of wallet - company, person, client.
         * @param {number} [minBalance] 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, phoneNumber?: string, email?: string, ewalletReferenceId?: string, pageNumber?: number, pageSize?: number, type?: string, minBalance?: number, currency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20097> {
            return localVarFp.getUsers(accessKey, contentType, salt, signature, timestamp, idempotency, phoneNumber, email, ewalletReferenceId, pageNumber, pageSize, type, minBalance, currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Put a hold on funds in the wallet. Sandbox only.<BR> This action transfers funds from the available balance to the on-hold balance. If the wallet does not have enough funds in the available balance in the specified currency, the transfer fails.<BR>This method triggers the **Transfer Funds Between Balances** webhook. This webhook contains the same information as the response.<BR>The customer cannot move funds that are on hold until the client releases the hold.<BR>This method is relevant for **person** and **company** wallets.
         * @summary Put Funds on Hold
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BalanceHoldBody} balanceHoldBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundsOnHold(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, balanceHoldBody: BalanceHoldBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20069> {
            return localVarFp.putFundsOnHold(accessKey, contentType, salt, signature, timestamp, balanceHoldBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a limit on a wallet account.
         * @summary Delete Wallet Account Limit
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountLimit(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200100> {
            return localVarFp.removeAccountLimit(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the maximum balance limit or the minimum balance threshold for an existing wallet account.
         * @summary Set Wallet Account Limit
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {AccountLimitsBody} [accountLimitsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountLimit(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, accountLimitsBody?: AccountLimitsBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20099> {
            return localVarFp.setAccountLimit(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, accountLimitsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Respond to a funds transfer between wallets. The transferee uses this method to accept or decline the transfer.
         * @summary Set Transfer Response
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {TransferResponseBody} transferResponseBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFundsTransferResponse(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, transferResponseBody: TransferResponseBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20067> {
            return localVarFp.setFundsTransferResponse(accessKey, contentType, salt, signature, timestamp, transferResponseBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a contact for a Rapyd Wallet.
         * @summary Update Wallet Contact
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
         * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
         * @param {Contact} contact 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, contact: Contact, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20071> {
            return localVarFp.updateEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, contact, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change Wallet Status
         * @summary Change Wallet Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the Rapyd Wallet. String starting with **ewallet_**. Required when phone number is not used.
         * @param {UpdateEwalletStatusStatusEnum} status Status of the wallet. One of the following: ACT - Active, DIS - Disabled, CLO - Close.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEwalletStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, status: UpdateEwalletStatusStatusEnum, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20066> {
            return localVarFp.updateEwalletStatus(accessKey, contentType, salt, signature, timestamp, ewalletToken, status, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a Rapyd Wallet.
         * @summary Update Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
         * @param {EwalletsEwalletTokenBody} ewalletsEwalletTokenBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatedUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, ewalletsEwalletTokenBody: EwalletsEwalletTokenBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20098> {
            return localVarFp.updatedUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, ewalletsEwalletTokenBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * List the virtual accounts that are attached to a Rapyd Wallet.
         * @summary List Virtual Accounts by Rapyd Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} ewallet ID of the Rapyd Wallet that the virtual accounts were issued to. String starting with **ewallet_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualAccountsByRapydWallet(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewallet: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200103> {
            return localVarFp.virtualAccountsByRapydWallet(accessKey, contentType, salt, signature, timestamp, ewallet, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove virtual currency from a Rapyd Wallet account.<BR>If the account does not have sufficient funds in the indicated currency, the funds transfer fails.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Removed\' Webhook
         * @summary Remove Funds From Wallet Account
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {AccountWithdrawBody} accountWithdrawBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawFundsFromWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountWithdrawBody: AccountWithdrawBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20068> {
            return localVarFp.withdrawFundsFromWalletAccount(accessKey, contentType, salt, signature, timestamp, accountWithdrawBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EWalletsApi - object-oriented interface
 * @export
 * @class EWalletsApi
 * @extends {BaseAPI}
 */
export class EWalletsApi extends BaseAPI {
    /**
     * Transfer virtual currency to a Rapyd Wallet account.<BR>If the account does not already exist for the indicated currency, it is created.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Added Webhook\'.
     * @summary Add Funds to Wallet Account
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {AccountDepositBody} accountDepositBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public addFundsToWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountDepositBody: AccountDepositBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).addFundsToWalletAccount(accessKey, contentType, salt, signature, timestamp, accountDepositBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a personal contact to a company wallet or client wallet.
     * @summary Add Contact to Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {EwalletIdContactsBody} ewalletIdContactsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public createEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, ewalletIdContactsBody: EwalletIdContactsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).createEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, ewalletIdContactsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Rapyd Wallet.
     * @summary Create Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1EwalletsBody} v1EwalletsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public createUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1EwalletsBody: V1EwalletsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).createUser(accessKey, contentType, salt, signature, timestamp, v1EwalletsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a personal contact from a company wallet or client wallet.
     * @summary Delete Wallet Contact
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public deleteEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).deleteEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Rapyd Wallet. Use this method when the wallet has never been used. This method triggers the Wallet Deleted webhook. This webhook contains the same information as the response.
     * @summary Delete Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public deleteUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).deleteUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific \'Add Funds to Wallet Account\' request.<BR> Use this method in the sandbox for testing purposes.
     * @summary Get Details of Add Funds Request
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} id ID of the \&#39;Add Funds to Wallet Account\&#39; request, from the &#x60;id&#x60; field in the data object of the response. UUID.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public detailsOfAddFundstoWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).detailsOfAddFundstoWalletAccount(accessKey, contentType, salt, signature, timestamp, id, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer funds between Rapyd Wallets.
     * @summary Transfer Funds Between Wallets
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {AccountTransferBody} accountTransferBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public fundsTransfer(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountTransferBody: AccountTransferBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).fundsTransfer(accessKey, contentType, salt, signature, timestamp, accountTransferBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific \'Remove Funds From Wallet Account\' request.<BR>Use this method in the sandbox for testing purposes.
     * @summary Get Details of Remove Funds Request
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} id ID of the \&#39;Remove Funds From Wallet Account\&#39; request, from the &#x60;id&#x60; field in the &#x60;data&#x60; object of the response. UUID.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getDetailsOfRemoveFundsRequest(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, id: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getDetailsOfRemoveFundsRequest(accessKey, contentType, salt, signature, timestamp, id, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a contact for an existing Rapyd Wallet.
     * @summary Retrieve Wallet Contact.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} contactId One of two values. either ID of the contact - String starting with the prefix **cont_** or Contact reference ID.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify the compliance status of a personal contact.
     * @summary Get Compliance Status of Personal Contact
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} contactId ID of the contact. String starting with **cont_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getEwalletContactComplianceLevels(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getEwalletContactComplianceLevels(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all contacts for a wallet.
     * @summary List Contacts of Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getEwalletContacts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getEwalletContacts(accessKey, contentType, salt, signature, timestamp, ewalletId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a Rapyd Wallet.
     * @summary Retrieve Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of the balances in a Rapyd Wallet.
     * @summary Retrieve Wallet Balances
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getUserAccounts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getUserAccounts(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a wallet transaction.
     * @summary Get Details of Wallet Transaction
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
     * @param {number} transactionId ID of the transaction, from the response to List Wallet Transactions. String starting with wt_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getUserTransactionDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, transactionId: number, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getUserTransactionDetails(accessKey, contentType, salt, signature, timestamp, walletId, transactionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all transactions related to a wallet.
     * @summary List Wallet Transactions
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} walletId ID of the wallet. String starting with **ewallet_**.
     * @param {number} balance The updated wallet balance after successful completion of the transaction.
     * @param {string} pageSize Number of results per page.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [currency] Three-letter ISO 4217 code for the currency of the transactions. Uppercase.
     * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
     * @param {string} [endingBefore] The ID of the wallet transaction created after the last wallet transaction you want to retrieve. String starting with **wt_**.
     * @param {string} [pageNumber] Page number to retrieve.
     * @param {string} [startDate] Timestamp of the first transaction or earlier, in Unix time.
     * @param {string} [startingAfter] The ID of the wallet transaction created before the first wallet transaction you want to retrieve. String starting with **wt_**.
     * @param {string} [type] Type of transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getUserTransactions(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, balance: number, pageSize: string, idempotency?: string, currency?: string, endDate?: string, endingBefore?: string, pageNumber?: string, startDate?: string, startingAfter?: string, type?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getUserTransactions(accessKey, contentType, salt, signature, timestamp, walletId, balance, pageSize, idempotency, currency, endDate, endingBefore, pageNumber, startDate, startingAfter, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of Rapyd Wallets. You can filter the list with query parameters.
     * @summary List eWallets
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [phoneNumber] Phone number of the Rapyd Wallet in E.164 format.
     * @param {string} [email] Email address of the wallet owner.
     * @param {string} [ewalletReferenceId] Wallet ID defined by the customer or end user.
     * @param {number} [pageNumber] Page number to retrieve. If &#x60;page_number&#x60; is not specified, page 1 is retrieved.
     * @param {number} [pageSize] Number of results per page.
     * @param {string} [type] Type of wallet - company, person, client.
     * @param {number} [minBalance] 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public getUsers(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, phoneNumber?: string, email?: string, ewalletReferenceId?: string, pageNumber?: number, pageSize?: number, type?: string, minBalance?: number, currency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).getUsers(accessKey, contentType, salt, signature, timestamp, idempotency, phoneNumber, email, ewalletReferenceId, pageNumber, pageSize, type, minBalance, currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Put a hold on funds in the wallet. Sandbox only.<BR> This action transfers funds from the available balance to the on-hold balance. If the wallet does not have enough funds in the available balance in the specified currency, the transfer fails.<BR>This method triggers the **Transfer Funds Between Balances** webhook. This webhook contains the same information as the response.<BR>The customer cannot move funds that are on hold until the client releases the hold.<BR>This method is relevant for **person** and **company** wallets.
     * @summary Put Funds on Hold
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {BalanceHoldBody} balanceHoldBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public putFundsOnHold(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, balanceHoldBody: BalanceHoldBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).putFundsOnHold(accessKey, contentType, salt, signature, timestamp, balanceHoldBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a limit on a wallet account.
     * @summary Delete Wallet Account Limit
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public removeAccountLimit(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).removeAccountLimit(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the maximum balance limit or the minimum balance threshold for an existing wallet account.
     * @summary Set Wallet Account Limit
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} walletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {AccountLimitsBody} [accountLimitsBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public setAccountLimit(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, walletId: string, idempotency?: string, accountLimitsBody?: AccountLimitsBody, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).setAccountLimit(accessKey, contentType, salt, signature, timestamp, walletId, idempotency, accountLimitsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Respond to a funds transfer between wallets. The transferee uses this method to accept or decline the transfer.
     * @summary Set Transfer Response
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {TransferResponseBody} transferResponseBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public setFundsTransferResponse(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, transferResponseBody: TransferResponseBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).setFundsTransferResponse(accessKey, contentType, salt, signature, timestamp, transferResponseBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a contact for a Rapyd Wallet.
     * @summary Update Wallet Contact
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletId ID of the Rapyd Wallet that this contact is associated with. String starting with **ewallet_**.
     * @param {string} contactId ID of the contact. String starting with the prefix **cont_**.
     * @param {Contact} contact 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public updateEwalletContact(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletId: string, contactId: string, contact: Contact, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).updateEwalletContact(accessKey, contentType, salt, signature, timestamp, ewalletId, contactId, contact, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change Wallet Status
     * @summary Change Wallet Status
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletToken ID of the Rapyd Wallet. String starting with **ewallet_**. Required when phone number is not used.
     * @param {UpdateEwalletStatusStatusEnum} status Status of the wallet. One of the following: ACT - Active, DIS - Disabled, CLO - Close.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public updateEwalletStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, status: UpdateEwalletStatusStatusEnum, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).updateEwalletStatus(accessKey, contentType, salt, signature, timestamp, ewalletToken, status, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a Rapyd Wallet.
     * @summary Update Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewalletToken ID of the wallet. String starting with **ewallet_**.
     * @param {EwalletsEwalletTokenBody} ewalletsEwalletTokenBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public updatedUser(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewalletToken: string, ewalletsEwalletTokenBody: EwalletsEwalletTokenBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).updatedUser(accessKey, contentType, salt, signature, timestamp, ewalletToken, ewalletsEwalletTokenBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the virtual accounts that are attached to a Rapyd Wallet.
     * @summary List Virtual Accounts by Rapyd Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} ewallet ID of the Rapyd Wallet that the virtual accounts were issued to. String starting with **ewallet_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public virtualAccountsByRapydWallet(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, ewallet: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).virtualAccountsByRapydWallet(accessKey, contentType, salt, signature, timestamp, ewallet, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove virtual currency from a Rapyd Wallet account.<BR>If the account does not have sufficient funds in the indicated currency, the funds transfer fails.<BR>Use this method in the sandbox for testing purposes.<BR>This method triggers the \'Funds Removed\' Webhook
     * @summary Remove Funds From Wallet Account
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {AccountWithdrawBody} accountWithdrawBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EWalletsApi
     */
    public withdrawFundsFromWalletAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, accountWithdrawBody: AccountWithdrawBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EWalletsApiFp(this.configuration).withdrawFundsFromWalletAccount(accessKey, contentType, salt, signature, timestamp, accountWithdrawBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UpdateEwalletStatusStatusEnum = {
    Act: 'ACT',
    Dis: 'DIS',
    Clo: 'CLO'
} as const;
export type UpdateEwalletStatusStatusEnum = typeof UpdateEwalletStatusStatusEnum[keyof typeof UpdateEwalletStatusStatusEnum];


/**
 * EscrowApi - axios parameter creator
 * @export
 */
export const EscrowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve details of the escrow for a payment.
         * @summary Retrieve details of escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEscrow: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getEscrow', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getEscrow', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getEscrow', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getEscrow', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getEscrow', 'timestamp', timestamp)
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('getEscrow', 'payment', payment)
            // verify required parameter 'escrow' is not null or undefined
            assertParamExists('getEscrow', 'escrow', escrow)
            const localVarPath = `/v1/payments/{payment}/escrows/{escrow}`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)))
                .replace(`{${"escrow"}}`, encodeURIComponent(String(escrow)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all releases of funds from a specified escrow.
         * @summary List releases of funds from escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEscrowReleases: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listEscrowReleases', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listEscrowReleases', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listEscrowReleases', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listEscrowReleases', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listEscrowReleases', 'timestamp', timestamp)
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('listEscrowReleases', 'payment', payment)
            // verify required parameter 'escrow' is not null or undefined
            assertParamExists('listEscrowReleases', 'escrow', escrow)
            const localVarPath = `/v1/payments/{payment}/escrows/{escrow}/escrow_releases`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)))
                .replace(`{${"escrow"}}`, encodeURIComponent(String(escrow)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all releases of funds from a specified escrow.
         * @summary Release funds from escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {EscrowEscrowReleasesBody} [escrowEscrowReleasesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFundsFromEscrow: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, escrowEscrowReleasesBody?: EscrowEscrowReleasesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'timestamp', timestamp)
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'payment', payment)
            // verify required parameter 'escrow' is not null or undefined
            assertParamExists('releaseFundsFromEscrow', 'escrow', escrow)
            const localVarPath = `/v1/payments/{payment}/escrows/{escrow}/escrow_releases`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)))
                .replace(`{${"escrow"}}`, encodeURIComponent(String(escrow)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(escrowEscrowReleasesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EscrowApi - functional programming interface
 * @export
 */
export const EscrowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EscrowApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve details of the escrow for a payment.
         * @summary Retrieve details of escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEscrow(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEscrow(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EscrowApi.getEscrow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all releases of funds from a specified escrow.
         * @summary List releases of funds from escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEscrowReleases(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEscrowReleases(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EscrowApi.listEscrowReleases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all releases of funds from a specified escrow.
         * @summary Release funds from escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {EscrowEscrowReleasesBody} [escrowEscrowReleasesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releaseFundsFromEscrow(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, escrowEscrowReleasesBody?: EscrowEscrowReleasesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.releaseFundsFromEscrow(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, escrowEscrowReleasesBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EscrowApi.releaseFundsFromEscrow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EscrowApi - factory interface
 * @export
 */
export const EscrowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EscrowApiFp(configuration)
    return {
        /**
         * Retrieve details of the escrow for a payment.
         * @summary Retrieve details of escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEscrow(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20028> {
            return localVarFp.getEscrow(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all releases of funds from a specified escrow.
         * @summary List releases of funds from escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEscrowReleases(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20028> {
            return localVarFp.listEscrowReleases(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all releases of funds from a specified escrow.
         * @summary Release funds from escrow
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} payment ID of the payment. String starting with **payment_**.
         * @param {string} escrow ID of the escrow. String starting with **escrow_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {EscrowEscrowReleasesBody} [escrowEscrowReleasesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFundsFromEscrow(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, escrowEscrowReleasesBody?: EscrowEscrowReleasesBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20029> {
            return localVarFp.releaseFundsFromEscrow(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, escrowEscrowReleasesBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EscrowApi - object-oriented interface
 * @export
 * @class EscrowApi
 * @extends {BaseAPI}
 */
export class EscrowApi extends BaseAPI {
    /**
     * Retrieve details of the escrow for a payment.
     * @summary Retrieve details of escrow
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payment ID of the payment. String starting with **payment_**.
     * @param {string} escrow ID of the escrow. String starting with **escrow_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EscrowApi
     */
    public getEscrow(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EscrowApiFp(this.configuration).getEscrow(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all releases of funds from a specified escrow.
     * @summary List releases of funds from escrow
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payment ID of the payment. String starting with **payment_**.
     * @param {string} escrow ID of the escrow. String starting with **escrow_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EscrowApi
     */
    public listEscrowReleases(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return EscrowApiFp(this.configuration).listEscrowReleases(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all releases of funds from a specified escrow.
     * @summary Release funds from escrow
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} payment ID of the payment. String starting with **payment_**.
     * @param {string} escrow ID of the escrow. String starting with **escrow_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {EscrowEscrowReleasesBody} [escrowEscrowReleasesBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EscrowApi
     */
    public releaseFundsFromEscrow(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, payment: string, escrow: string, idempotency?: string, escrowEscrowReleasesBody?: EscrowEscrowReleasesBody, options?: RawAxiosRequestConfig) {
        return EscrowApiFp(this.configuration).releaseFundsFromEscrow(accessKey, contentType, salt, signature, timestamp, payment, escrow, idempotency, escrowEscrowReleasesBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FXApi - axios parameter creator
 * @export
 */
export const FXApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
         * @summary Get FX Rate
         * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - payment, payout
         * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
         * @param {string} [date] The date when the rate is applicable. Today or earlier. Format YYYY-MM-DD
         * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - buy, sell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyRate: async (actionType: string, buyCurrency: string, sellCurrency: string, amount?: number, date?: string, fixedSide?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionType' is not null or undefined
            assertParamExists('getDailyRate', 'actionType', actionType)
            // verify required parameter 'buyCurrency' is not null or undefined
            assertParamExists('getDailyRate', 'buyCurrency', buyCurrency)
            // verify required parameter 'sellCurrency' is not null or undefined
            assertParamExists('getDailyRate', 'sellCurrency', sellCurrency)
            const localVarPath = `/v1/fx_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (buyCurrency !== undefined) {
                localVarQueryParameter['buy_currency'] = buyCurrency;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (fixedSide !== undefined) {
                localVarQueryParameter['fixed_side'] = fixedSide;
            }

            if (sellCurrency !== undefined) {
                localVarQueryParameter['sell_currency'] = sellCurrency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FXApi - functional programming interface
 * @export
 */
export const FXApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FXApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
         * @summary Get FX Rate
         * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - payment, payout
         * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
         * @param {string} [date] The date when the rate is applicable. Today or earlier. Format YYYY-MM-DD
         * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - buy, sell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyRate(actionType: string, buyCurrency: string, sellCurrency: string, amount?: number, date?: string, fixedSide?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20096>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyRate(actionType, buyCurrency, sellCurrency, amount, date, fixedSide, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FXApi.getDailyRate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FXApi - factory interface
 * @export
 */
export const FXApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FXApiFp(configuration)
    return {
        /**
         * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
         * @summary Get FX Rate
         * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - payment, payout
         * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
         * @param {string} [date] The date when the rate is applicable. Today or earlier. Format YYYY-MM-DD
         * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - buy, sell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyRate(actionType: string, buyCurrency: string, sellCurrency: string, amount?: number, date?: string, fixedSide?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20096> {
            return localVarFp.getDailyRate(actionType, buyCurrency, sellCurrency, amount, date, fixedSide, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FXApi - object-oriented interface
 * @export
 * @class FXApi
 * @extends {BaseAPI}
 */
export class FXApi extends BaseAPI {
    /**
     * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
     * @summary Get FX Rate
     * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - payment, payout
     * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
     * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
     * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
     * @param {string} [date] The date when the rate is applicable. Today or earlier. Format YYYY-MM-DD
     * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - buy, sell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FXApi
     */
    public getDailyRate(actionType: string, buyCurrency: string, sellCurrency: string, amount?: number, date?: string, fixedSide?: string, options?: RawAxiosRequestConfig) {
        return FXApiFp(this.configuration).getDailyRate(actionType, buyCurrency, sellCurrency, amount, date, fixedSide, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupPaymentApi - axios parameter creator
 * @export
 */
export const GroupPaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a group payment.
         * @summary Create group payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PaymentsGroupPaymentsBody} paymentsGroupPaymentsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsGroupPaymentsBody: PaymentsGroupPaymentsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createGroupPayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createGroupPayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createGroupPayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createGroupPayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createGroupPayment', 'timestamp', timestamp)
            // verify required parameter 'paymentsGroupPaymentsBody' is not null or undefined
            assertParamExists('createGroupPayment', 'paymentsGroupPaymentsBody', paymentsGroupPaymentsBody)
            const localVarPath = `/v1/payments/group_payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsGroupPaymentsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a group payment.
         * @summary Cancel group payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletegroupPaymentId: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deletegroupPaymentId', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deletegroupPaymentId', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deletegroupPaymentId', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deletegroupPaymentId', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deletegroupPaymentId', 'timestamp', timestamp)
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('deletegroupPaymentId', 'groupPaymentId', groupPaymentId)
            const localVarPath = `/v1/payments/group_payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a group payment.
         * @summary Retrieve group payment details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroupPaymentId: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveGroupPaymentId', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveGroupPaymentId', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveGroupPaymentId', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveGroupPaymentId', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveGroupPaymentId', 'timestamp', timestamp)
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('retrieveGroupPaymentId', 'groupPaymentId', groupPaymentId)
            const localVarPath = `/v1/payments/group_payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupPaymentApi - functional programming interface
 * @export
 */
export const GroupPaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupPaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a group payment.
         * @summary Create group payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PaymentsGroupPaymentsBody} paymentsGroupPaymentsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsGroupPaymentsBody: PaymentsGroupPaymentsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupPayment(accessKey, contentType, salt, signature, timestamp, paymentsGroupPaymentsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupPaymentApi.createGroupPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a group payment.
         * @summary Cancel group payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletegroupPaymentId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletegroupPaymentId(accessKey, contentType, salt, signature, timestamp, groupPaymentId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupPaymentApi.deletegroupPaymentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a group payment.
         * @summary Retrieve group payment details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGroupPaymentId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGroupPaymentId(accessKey, contentType, salt, signature, timestamp, groupPaymentId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupPaymentApi.retrieveGroupPaymentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupPaymentApi - factory interface
 * @export
 */
export const GroupPaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupPaymentApiFp(configuration)
    return {
        /**
         * Create a group payment.
         * @summary Create group payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PaymentsGroupPaymentsBody} paymentsGroupPaymentsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsGroupPaymentsBody: PaymentsGroupPaymentsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20027> {
            return localVarFp.createGroupPayment(accessKey, contentType, salt, signature, timestamp, paymentsGroupPaymentsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a group payment.
         * @summary Cancel group payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletegroupPaymentId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20027> {
            return localVarFp.deletegroupPaymentId(accessKey, contentType, salt, signature, timestamp, groupPaymentId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a group payment.
         * @summary Retrieve group payment details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroupPaymentId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20027> {
            return localVarFp.retrieveGroupPaymentId(accessKey, contentType, salt, signature, timestamp, groupPaymentId, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupPaymentApi - object-oriented interface
 * @export
 * @class GroupPaymentApi
 * @extends {BaseAPI}
 */
export class GroupPaymentApi extends BaseAPI {
    /**
     * Create a group payment.
     * @summary Create group payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {PaymentsGroupPaymentsBody} paymentsGroupPaymentsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentApi
     */
    public createGroupPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsGroupPaymentsBody: PaymentsGroupPaymentsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return GroupPaymentApiFp(this.configuration).createGroupPayment(accessKey, contentType, salt, signature, timestamp, paymentsGroupPaymentsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a group payment.
     * @summary Cancel group payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentApi
     */
    public deletegroupPaymentId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return GroupPaymentApiFp(this.configuration).deletegroupPaymentId(accessKey, contentType, salt, signature, timestamp, groupPaymentId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a group payment.
     * @summary Retrieve group payment details
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} groupPaymentId ID of the group payment. String starting with **gp_**
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentApi
     */
    public retrieveGroupPaymentId(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, groupPaymentId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return GroupPaymentApiFp(this.configuration).retrieveGroupPaymentId(accessKey, contentType, salt, signature, timestamp, groupPaymentId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IssuingApi - axios parameter creator
 * @export
 */
export const IssuingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a card that was issued via the Rapyd issuing platform.
         * @summary Activate Issued Card Using API
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsActivateBody} cardsActivateBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateCard: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsActivateBody: CardsActivateBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('activateCard', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('activateCard', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('activateCard', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('activateCard', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('activateCard', 'timestamp', timestamp)
            // verify required parameter 'cardsActivateBody' is not null or undefined
            assertParamExists('activateCard', 'cardsActivateBody', cardsActivateBody)
            const localVarPath = `/v1/issuing/cards/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsActivateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a card to a Google Pay wallet using Google Pay Push Provisioning.<BR>**Note:**<BR> * PCI certification is required for this method as it contains PCI data.<BR> * The response returns the `getEncryptedPaymentInstrument` string, which is used to add the card to the Google pay wallet by using the Google Pay `pushTokenizeRequest` method. For more information refer to the Google Pay Provisioning developer documentation
         * @summary Add Card to Google Pay - Google Pay Push Provisioning
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of the card. String starting with **card_**.
         * @param {CardTokensGooglePayBody} cardTokensGooglePayBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCardtoGooglePay: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, cardTokensGooglePayBody: CardTokensGooglePayBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'timestamp', timestamp)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'cardId', cardId)
            // verify required parameter 'cardTokensGooglePayBody' is not null or undefined
            assertParamExists('addCardtoGooglePay', 'cardTokensGooglePayBody', cardTokensGooglePayBody)
            const localVarPath = `/v1/issuing/cards/{card_id}/card_tokens/google_pay`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardTokensGooglePayBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue a virtual account number to an existing wallet.
         * @summary Issue Virtual Account Number
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingBankaccountsBody} issuingBankaccountsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssuing: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingBankaccountsBody: IssuingBankaccountsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createIssuing', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createIssuing', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createIssuing', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createIssuing', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createIssuing', 'timestamp', timestamp)
            // verify required parameter 'issuingBankaccountsBody' is not null or undefined
            assertParamExists('createIssuing', 'issuingBankaccountsBody', issuingBankaccountsBody)
            const localVarPath = `/v1/issuing/bankaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issuingBankaccountsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a card.
         * @summary Card details.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of a cardId. String starting with **ci_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingDetails: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCardIssuingDetails', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCardIssuingDetails', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCardIssuingDetails', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCardIssuingDetails', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCardIssuingDetails', 'timestamp', timestamp)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCardIssuingDetails', 'cardId', cardId)
            const localVarPath = `/v1/issuing/cards/{cardId}`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all issuing cards.
         * @summary List issuing cards.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [contact] ID of a wallet contact. String starting with **cont_**.
         * @param {number} [pageNumber] Page number to retrieve.
         * @param {number} [pageSize] Number of results per page.
         * @param {number} [creationStartDate] Start date of card creation.
         * @param {number} [creationEndDate] End date of card creation.
         * @param {number} [activationStartDate] Start date of card activation.
         * @param {number} [activationEndDate] End date of card activation.
         * @param {string} [cardProgram] Card program token.
         * @param {string} [status] Card status.
         * @param {boolean} [allowDeleted] Is card allow delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingList: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, contact?: string, pageNumber?: number, pageSize?: number, creationStartDate?: number, creationEndDate?: number, activationStartDate?: number, activationEndDate?: number, cardProgram?: string, status?: string, allowDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCardIssuingList', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCardIssuingList', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCardIssuingList', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCardIssuingList', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCardIssuingList', 'timestamp', timestamp)
            const localVarPath = `/v1/issuing/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contact !== undefined) {
                localVarQueryParameter['contact'] = contact;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (creationStartDate !== undefined) {
                localVarQueryParameter['creation_start_date'] = creationStartDate;
            }

            if (creationEndDate !== undefined) {
                localVarQueryParameter['creation_end_date'] = creationEndDate;
            }

            if (activationStartDate !== undefined) {
                localVarQueryParameter['activation_start_date'] = activationStartDate;
            }

            if (activationEndDate !== undefined) {
                localVarQueryParameter['activation_end_date'] = activationEndDate;
            }

            if (cardProgram !== undefined) {
                localVarQueryParameter['card_program'] = cardProgram;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (allowDeleted !== undefined) {
                localVarQueryParameter['allow_deleted'] = allowDeleted;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the GET method to retrieve details of a specific transaction from a specific issued card.
         * @summary Retrieve Issued Card Transaction Details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId Card id
         * @param {string} transactionId Card transaction id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingTransaction: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, transactionId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'timestamp', timestamp)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'cardId', cardId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getCardIssuingTransaction', 'transactionId', transactionId)
            const localVarPath = `/v1/issuing/cards/{cardId}/transactions/{transactionId}`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the GET method to retrieve a list of transactions for a specific issued card.
         * @summary List Issued Card Transactions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of the issued card. String starting with **card_**.
         * @param {string} pageSize ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} pageNumber Page number to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
         * @param {string} [minAmount] Transactions greater than a specific amount.
         * @param {string} [maxAmount] Transactions smaller than a specific amount.
         * @param {string} [merchantNameSearch] Filters the results to return only transactions that have this string as part of the name or location.
         * @param {string} [startDate] ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingTransactions: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, pageSize: string, pageNumber: string, idempotency?: string, endDate?: string, minAmount?: string, maxAmount?: string, merchantNameSearch?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'timestamp', timestamp)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'cardId', cardId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getCardIssuingTransactions', 'pageNumber', pageNumber)
            const localVarPath = `/v1/issuing/cards/{cardId}/transactions`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (minAmount !== undefined) {
                localVarQueryParameter['min_amount'] = minAmount;
            }

            if (maxAmount !== undefined) {
                localVarQueryParameter['max_amount'] = maxAmount;
            }

            if (merchantNameSearch !== undefined) {
                localVarQueryParameter['merchant_name_search'] = merchantNameSearch;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of the remitter of a transfer to a virtual bank account.
         * @summary Retrieve Remitter Details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemitterDetails: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getRemitterDetails', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getRemitterDetails', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getRemitterDetails', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getRemitterDetails', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getRemitterDetails', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('getRemitterDetails', 'virtualAccountId', virtualAccountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getRemitterDetails', 'transactionId', transactionId)
            const localVarPath = `/v1/issuing/bankaccounts/remitters/{virtualAccountId}/transactions/{transaction_id}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A contact can activate his or her physical issued card.<BR>Rapyd sends you webhooks for the following actions:<BR> * Personalize a card - See \'Bulk-Issued Card Personalized Webhook\' in online API reference.<BR> * Activate a card - See \'Issued Card Activated Webhook\' in online API reference.<BR>**Prerequisites**<BR> * Rapyd Wallet. See \'Rapyd Wallet\' in online API reference.<BR> * Wallet contact with a valid phone number. See \'Wallet Contact\' in online API reference.
         * @summary Activate Issued Card Using Hosted Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingActivateCardBody} issuingActivateCardBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostedActivateCard: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingActivateCardBody: IssuingActivateCardBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('hostedActivateCard', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('hostedActivateCard', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('hostedActivateCard', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('hostedActivateCard', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('hostedActivateCard', 'timestamp', timestamp)
            // verify required parameter 'issuingActivateCardBody' is not null or undefined
            assertParamExists('hostedActivateCard', 'issuingActivateCardBody', issuingActivateCardBody)
            const localVarPath = `/v1/hosted/issuing/activate_card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issuingActivateCardBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a hosted page for viewing and resetting a PIN.<BR>In the sandbox, you can set any number other than 1111.<BR>Rapyd sends you the \'Issued Card PIN Set\' Webhook when the customer sets a Personal Identification Number (PIN).<BR>**Note:**<BR> * PINs are relevant to physical cards.<BR>* Some card programs do not support resetting the PIN. Holders of those cards must reset the PIN at an ATM.<BR>**Prerequisites**<BR>* Rapyd Wallet.<BR>* Wallet contact with a valid phone number.<BR>* Issued card that is activated.
         * @summary Create Hosted Page for PIN Management
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingPinBody} issuingPinBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostedCardPIN: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingPinBody: IssuingPinBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('hostedCardPIN', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('hostedCardPIN', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('hostedCardPIN', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('hostedCardPIN', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('hostedCardPIN', 'timestamp', timestamp)
            // verify required parameter 'issuingPinBody' is not null or undefined
            assertParamExists('hostedCardPIN', 'issuingPinBody', issuingPinBody)
            const localVarPath = `/v1/hosted/issuing/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issuingPinBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue a card to a wallet contact.
         * @summary Issue Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingCardsBody} issuingCardsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCard: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingCardsBody: IssuingCardsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('issueCard', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('issueCard', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('issueCard', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('issueCard', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('issueCard', 'timestamp', timestamp)
            // verify required parameter 'issuingCardsBody' is not null or undefined
            assertParamExists('issueCard', 'issuingCardsBody', issuingCardsBody)
            const localVarPath = `/v1/issuing/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issuingCardsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a connection between an issued card and a wallet contact. Relevant to cards that are issued in bulk and not assigned to any specific person. This method can be used only once per card.
         * @summary Personalize Bulk-Issued Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsPersonalizeBody} cardsPersonalizeBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCard: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPersonalizeBody: CardsPersonalizeBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('modifyCard', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('modifyCard', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('modifyCard', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('modifyCard', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('modifyCard', 'timestamp', timestamp)
            // verify required parameter 'cardsPersonalizeBody' is not null or undefined
            assertParamExists('modifyCard', 'cardsPersonalizeBody', cardsPersonalizeBody)
            const localVarPath = `/v1/issuing/cards/personalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsPersonalizeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a Virtual Account Number object for a wallet.
         * @summary Retrieve Virtual Account History
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIssuingByRapydToken: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveIssuingByRapydToken', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveIssuingByRapydToken', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveIssuingByRapydToken', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveIssuingByRapydToken', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveIssuingByRapydToken', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('retrieveIssuingByRapydToken', 'virtualAccountId', virtualAccountId)
            const localVarPath = `/v1/issuing/bankaccounts/{virtualAccountId}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a virtual account transaction.
         * @summary Retrieve Virtual Account Transaction
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIssuingTransaction: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'virtualAccountId', virtualAccountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('retrieveIssuingTransaction', 'transactionId', transactionId)
            const localVarPath = `/v1/issuing/bankaccounts/{virtualAccountId}/transactions/{transactionId}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the PIN code for an issued card.<BR>This method triggers the \'Issued Card PIN Set\' Webhook.<BR> **Note:**<BR>* In the sandbox, you can set any number other than 1111.<BR>* Clients with PCI certification can handle personal identifying information for cards, such as card number.<BR> * PINs are relevant to physical cards.
         * @summary Set PIN Code
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsPinBody} cardsPinBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPINCode: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPinBody: CardsPinBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('setPINCode', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('setPINCode', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('setPINCode', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('setPINCode', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('setPINCode', 'timestamp', timestamp)
            // verify required parameter 'cardsPinBody' is not null or undefined
            assertParamExists('setPINCode', 'cardsPinBody', cardsPinBody)
            const localVarPath = `/v1/issuing/cards/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsPinBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
         * @summary Simulate Bank Transfer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BankaccountsBankaccounttransfertobankaccountBody} bankaccountsBankaccounttransfertobankaccountBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCompleteBankAccountIssuingTransaction: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, bankaccountsBankaccounttransfertobankaccountBody: BankaccountsBankaccounttransfertobankaccountBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCompleteBankAccountIssuingTransaction', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCompleteBankAccountIssuingTransaction', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCompleteBankAccountIssuingTransaction', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCompleteBankAccountIssuingTransaction', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCompleteBankAccountIssuingTransaction', 'timestamp', timestamp)
            // verify required parameter 'bankaccountsBankaccounttransfertobankaccountBody' is not null or undefined
            assertParamExists('simulateCompleteBankAccountIssuingTransaction', 'bankaccountsBankaccounttransfertobankaccountBody', bankaccountsBankaccounttransfertobankaccountBody)
            const localVarPath = `/v1/issuing/bankaccounts/bankaccounttransfertobankaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankaccountsBankaccounttransfertobankaccountBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Block or unblock a card that was issued via the Rapyd issuing platform.
         * @summary Update Card Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsStatusBody} cardsStatusBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardStatus: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsStatusBody: CardsStatusBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateCardStatus', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateCardStatus', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateCardStatus', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateCardStatus', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateCardStatus', 'timestamp', timestamp)
            // verify required parameter 'cardsStatusBody' is not null or undefined
            assertParamExists('updateCardStatus', 'cardsStatusBody', cardsStatusBody)
            const localVarPath = `/v1/issuing/cards/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsStatusBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
         * @summary Update Requested Currency
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {BankaccountsVirtualAccountIdBody} [bankaccountsVirtualAccountIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceivingCurrency: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, bankaccountsVirtualAccountIdBody?: BankaccountsVirtualAccountIdBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateReceivingCurrency', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateReceivingCurrency', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateReceivingCurrency', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateReceivingCurrency', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateReceivingCurrency', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('updateReceivingCurrency', 'virtualAccountId', virtualAccountId)
            const localVarPath = `/v1/issuing/bankaccounts/{virtualAccountId}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankaccountsVirtualAccountIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a hosted page that displays details of a virtual issued card directly to the customer. The URL is available for 24 hours after the response is sent, and then it expires.
         * @summary Generate hosted page with virtual issued card details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardToken ID of the Issued Card Details to Customer.
         * @param {CardDetailsCardTokenBody} cardDetailsCardTokenBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HostedIssuingCardDetailsCardTokenPost: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardToken: string, cardDetailsCardTokenBody: CardDetailsCardTokenBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'timestamp', timestamp)
            // verify required parameter 'cardToken' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'cardToken', cardToken)
            // verify required parameter 'cardDetailsCardTokenBody' is not null or undefined
            assertParamExists('v1HostedIssuingCardDetailsCardTokenPost', 'cardDetailsCardTokenBody', cardDetailsCardTokenBody)
            const localVarPath = `/v1/hosted/issuing/card_details/{cardToken}`
                .replace(`{${"cardToken"}}`, encodeURIComponent(String(cardToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardDetailsCardTokenBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuingApi - functional programming interface
 * @export
 */
export const IssuingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuingApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a card that was issued via the Rapyd issuing platform.
         * @summary Activate Issued Card Using API
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsActivateBody} cardsActivateBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsActivateBody: CardsActivateBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20078>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateCard(accessKey, contentType, salt, signature, timestamp, cardsActivateBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.activateCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a card to a Google Pay wallet using Google Pay Push Provisioning.<BR>**Note:**<BR> * PCI certification is required for this method as it contains PCI data.<BR> * The response returns the `getEncryptedPaymentInstrument` string, which is used to add the card to the Google pay wallet by using the Google Pay `pushTokenizeRequest` method. For more information refer to the Google Pay Provisioning developer documentation
         * @summary Add Card to Google Pay - Google Pay Push Provisioning
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of the card. String starting with **card_**.
         * @param {CardTokensGooglePayBody} cardTokensGooglePayBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCardtoGooglePay(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, cardTokensGooglePayBody: CardTokensGooglePayBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20084>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCardtoGooglePay(accessKey, contentType, salt, signature, timestamp, cardId, cardTokensGooglePayBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.addCardtoGooglePay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issue a virtual account number to an existing wallet.
         * @summary Issue Virtual Account Number
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingBankaccountsBody} issuingBankaccountsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIssuing(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingBankaccountsBody: IssuingBankaccountsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200107>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIssuing(accessKey, contentType, salt, signature, timestamp, issuingBankaccountsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.createIssuing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a card.
         * @summary Card details.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of a cardId. String starting with **ci_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardIssuingDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20077>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardIssuingDetails(accessKey, contentType, salt, signature, timestamp, cardId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.getCardIssuingDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all issuing cards.
         * @summary List issuing cards.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [contact] ID of a wallet contact. String starting with **cont_**.
         * @param {number} [pageNumber] Page number to retrieve.
         * @param {number} [pageSize] Number of results per page.
         * @param {number} [creationStartDate] Start date of card creation.
         * @param {number} [creationEndDate] End date of card creation.
         * @param {number} [activationStartDate] Start date of card activation.
         * @param {number} [activationEndDate] End date of card activation.
         * @param {string} [cardProgram] Card program token.
         * @param {string} [status] Card status.
         * @param {boolean} [allowDeleted] Is card allow delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardIssuingList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, contact?: string, pageNumber?: number, pageSize?: number, creationStartDate?: number, creationEndDate?: number, activationStartDate?: number, activationEndDate?: number, cardProgram?: string, status?: string, allowDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20075>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardIssuingList(accessKey, contentType, salt, signature, timestamp, idempotency, contact, pageNumber, pageSize, creationStartDate, creationEndDate, activationStartDate, activationEndDate, cardProgram, status, allowDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.getCardIssuingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use the GET method to retrieve details of a specific transaction from a specific issued card.
         * @summary Retrieve Issued Card Transaction Details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId Card id
         * @param {string} transactionId Card transaction id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20082>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardIssuingTransaction(accessKey, contentType, salt, signature, timestamp, cardId, transactionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.getCardIssuingTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use the GET method to retrieve a list of transactions for a specific issued card.
         * @summary List Issued Card Transactions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of the issued card. String starting with **card_**.
         * @param {string} pageSize ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} pageNumber Page number to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
         * @param {string} [minAmount] Transactions greater than a specific amount.
         * @param {string} [maxAmount] Transactions smaller than a specific amount.
         * @param {string} [merchantNameSearch] Filters the results to return only transactions that have this string as part of the name or location.
         * @param {string} [startDate] ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardIssuingTransactions(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, pageSize: string, pageNumber: string, idempotency?: string, endDate?: string, minAmount?: string, maxAmount?: string, merchantNameSearch?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20081>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardIssuingTransactions(accessKey, contentType, salt, signature, timestamp, cardId, pageSize, pageNumber, idempotency, endDate, minAmount, maxAmount, merchantNameSearch, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.getCardIssuingTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of the remitter of a transfer to a virtual bank account.
         * @summary Retrieve Remitter Details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemitterDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200109>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemitterDetails(accessKey, contentType, salt, signature, timestamp, virtualAccountId, transactionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.getRemitterDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A contact can activate his or her physical issued card.<BR>Rapyd sends you webhooks for the following actions:<BR> * Personalize a card - See \'Bulk-Issued Card Personalized Webhook\' in online API reference.<BR> * Activate a card - See \'Issued Card Activated Webhook\' in online API reference.<BR>**Prerequisites**<BR> * Rapyd Wallet. See \'Rapyd Wallet\' in online API reference.<BR> * Wallet contact with a valid phone number. See \'Wallet Contact\' in online API reference.
         * @summary Activate Issued Card Using Hosted Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingActivateCardBody} issuingActivateCardBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostedActivateCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingActivateCardBody: IssuingActivateCardBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20079>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostedActivateCard(accessKey, contentType, salt, signature, timestamp, issuingActivateCardBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.hostedActivateCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a hosted page for viewing and resetting a PIN.<BR>In the sandbox, you can set any number other than 1111.<BR>Rapyd sends you the \'Issued Card PIN Set\' Webhook when the customer sets a Personal Identification Number (PIN).<BR>**Note:**<BR> * PINs are relevant to physical cards.<BR>* Some card programs do not support resetting the PIN. Holders of those cards must reset the PIN at an ATM.<BR>**Prerequisites**<BR>* Rapyd Wallet.<BR>* Wallet contact with a valid phone number.<BR>* Issued card that is activated.
         * @summary Create Hosted Page for PIN Management
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingPinBody} issuingPinBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostedCardPIN(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingPinBody: IssuingPinBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20080>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostedCardPIN(accessKey, contentType, salt, signature, timestamp, issuingPinBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.hostedCardPIN']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issue a card to a wallet contact.
         * @summary Issue Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingCardsBody} issuingCardsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingCardsBody: IssuingCardsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20076>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCard(accessKey, contentType, salt, signature, timestamp, issuingCardsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.issueCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a connection between an issued card and a wallet contact. Relevant to cards that are issued in bulk and not assigned to any specific person. This method can be used only once per card.
         * @summary Personalize Bulk-Issued Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsPersonalizeBody} cardsPersonalizeBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPersonalizeBody: CardsPersonalizeBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20078>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyCard(accessKey, contentType, salt, signature, timestamp, cardsPersonalizeBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.modifyCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a Virtual Account Number object for a wallet.
         * @summary Retrieve Virtual Account History
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveIssuingByRapydToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200108>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveIssuingByRapydToken(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.retrieveIssuingByRapydToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a virtual account transaction.
         * @summary Retrieve Virtual Account Transaction
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200110>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveIssuingTransaction(accessKey, contentType, salt, signature, timestamp, virtualAccountId, transactionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.retrieveIssuingTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the PIN code for an issued card.<BR>This method triggers the \'Issued Card PIN Set\' Webhook.<BR> **Note:**<BR>* In the sandbox, you can set any number other than 1111.<BR>* Clients with PCI certification can handle personal identifying information for cards, such as card number.<BR> * PINs are relevant to physical cards.
         * @summary Set PIN Code
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsPinBody} cardsPinBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPINCode(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPinBody: CardsPinBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20083>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPINCode(accessKey, contentType, salt, signature, timestamp, cardsPinBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.setPINCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Imulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
         * @summary Simulate Bank Transfer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BankaccountsBankaccounttransfertobankaccountBody} bankaccountsBankaccounttransfertobankaccountBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCompleteBankAccountIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, bankaccountsBankaccounttransfertobankaccountBody: BankaccountsBankaccounttransfertobankaccountBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200108>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCompleteBankAccountIssuingTransaction(accessKey, contentType, salt, signature, timestamp, bankaccountsBankaccounttransfertobankaccountBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.simulateCompleteBankAccountIssuingTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Block or unblock a card that was issued via the Rapyd issuing platform.
         * @summary Update Card Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsStatusBody} cardsStatusBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCardStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsStatusBody: CardsStatusBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20078>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCardStatus(accessKey, contentType, salt, signature, timestamp, cardsStatusBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.updateCardStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
         * @summary Update Requested Currency
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {BankaccountsVirtualAccountIdBody} [bankaccountsVirtualAccountIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReceivingCurrency(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, bankaccountsVirtualAccountIdBody?: BankaccountsVirtualAccountIdBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20093>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReceivingCurrency(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, bankaccountsVirtualAccountIdBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.updateReceivingCurrency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a hosted page that displays details of a virtual issued card directly to the customer. The URL is available for 24 hours after the response is sent, and then it expires.
         * @summary Generate hosted page with virtual issued card details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardToken ID of the Issued Card Details to Customer.
         * @param {CardDetailsCardTokenBody} cardDetailsCardTokenBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1HostedIssuingCardDetailsCardTokenPost(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardToken: string, cardDetailsCardTokenBody: CardDetailsCardTokenBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20074>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1HostedIssuingCardDetailsCardTokenPost(accessKey, contentType, salt, signature, timestamp, cardToken, cardDetailsCardTokenBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingApi.v1HostedIssuingCardDetailsCardTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IssuingApi - factory interface
 * @export
 */
export const IssuingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuingApiFp(configuration)
    return {
        /**
         * Activate a card that was issued via the Rapyd issuing platform.
         * @summary Activate Issued Card Using API
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsActivateBody} cardsActivateBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsActivateBody: CardsActivateBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20078> {
            return localVarFp.activateCard(accessKey, contentType, salt, signature, timestamp, cardsActivateBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a card to a Google Pay wallet using Google Pay Push Provisioning.<BR>**Note:**<BR> * PCI certification is required for this method as it contains PCI data.<BR> * The response returns the `getEncryptedPaymentInstrument` string, which is used to add the card to the Google pay wallet by using the Google Pay `pushTokenizeRequest` method. For more information refer to the Google Pay Provisioning developer documentation
         * @summary Add Card to Google Pay - Google Pay Push Provisioning
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of the card. String starting with **card_**.
         * @param {CardTokensGooglePayBody} cardTokensGooglePayBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCardtoGooglePay(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, cardTokensGooglePayBody: CardTokensGooglePayBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20084> {
            return localVarFp.addCardtoGooglePay(accessKey, contentType, salt, signature, timestamp, cardId, cardTokensGooglePayBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Issue a virtual account number to an existing wallet.
         * @summary Issue Virtual Account Number
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingBankaccountsBody} issuingBankaccountsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssuing(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingBankaccountsBody: IssuingBankaccountsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200107> {
            return localVarFp.createIssuing(accessKey, contentType, salt, signature, timestamp, issuingBankaccountsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a card.
         * @summary Card details.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of a cardId. String starting with **ci_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20077> {
            return localVarFp.getCardIssuingDetails(accessKey, contentType, salt, signature, timestamp, cardId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all issuing cards.
         * @summary List issuing cards.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [contact] ID of a wallet contact. String starting with **cont_**.
         * @param {number} [pageNumber] Page number to retrieve.
         * @param {number} [pageSize] Number of results per page.
         * @param {number} [creationStartDate] Start date of card creation.
         * @param {number} [creationEndDate] End date of card creation.
         * @param {number} [activationStartDate] Start date of card activation.
         * @param {number} [activationEndDate] End date of card activation.
         * @param {string} [cardProgram] Card program token.
         * @param {string} [status] Card status.
         * @param {boolean} [allowDeleted] Is card allow delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, contact?: string, pageNumber?: number, pageSize?: number, creationStartDate?: number, creationEndDate?: number, activationStartDate?: number, activationEndDate?: number, cardProgram?: string, status?: string, allowDeleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20075> {
            return localVarFp.getCardIssuingList(accessKey, contentType, salt, signature, timestamp, idempotency, contact, pageNumber, pageSize, creationStartDate, creationEndDate, activationStartDate, activationEndDate, cardProgram, status, allowDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the GET method to retrieve details of a specific transaction from a specific issued card.
         * @summary Retrieve Issued Card Transaction Details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId Card id
         * @param {string} transactionId Card transaction id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20082> {
            return localVarFp.getCardIssuingTransaction(accessKey, contentType, salt, signature, timestamp, cardId, transactionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the GET method to retrieve a list of transactions for a specific issued card.
         * @summary List Issued Card Transactions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardId ID of the issued card. String starting with **card_**.
         * @param {string} pageSize ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} pageNumber Page number to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
         * @param {string} [minAmount] Transactions greater than a specific amount.
         * @param {string} [maxAmount] Transactions smaller than a specific amount.
         * @param {string} [merchantNameSearch] Filters the results to return only transactions that have this string as part of the name or location.
         * @param {string} [startDate] ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardIssuingTransactions(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, pageSize: string, pageNumber: string, idempotency?: string, endDate?: string, minAmount?: string, maxAmount?: string, merchantNameSearch?: string, startDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20081> {
            return localVarFp.getCardIssuingTransactions(accessKey, contentType, salt, signature, timestamp, cardId, pageSize, pageNumber, idempotency, endDate, minAmount, maxAmount, merchantNameSearch, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of the remitter of a transfer to a virtual bank account.
         * @summary Retrieve Remitter Details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemitterDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200109> {
            return localVarFp.getRemitterDetails(accessKey, contentType, salt, signature, timestamp, virtualAccountId, transactionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * A contact can activate his or her physical issued card.<BR>Rapyd sends you webhooks for the following actions:<BR> * Personalize a card - See \'Bulk-Issued Card Personalized Webhook\' in online API reference.<BR> * Activate a card - See \'Issued Card Activated Webhook\' in online API reference.<BR>**Prerequisites**<BR> * Rapyd Wallet. See \'Rapyd Wallet\' in online API reference.<BR> * Wallet contact with a valid phone number. See \'Wallet Contact\' in online API reference.
         * @summary Activate Issued Card Using Hosted Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingActivateCardBody} issuingActivateCardBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostedActivateCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingActivateCardBody: IssuingActivateCardBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20079> {
            return localVarFp.hostedActivateCard(accessKey, contentType, salt, signature, timestamp, issuingActivateCardBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a hosted page for viewing and resetting a PIN.<BR>In the sandbox, you can set any number other than 1111.<BR>Rapyd sends you the \'Issued Card PIN Set\' Webhook when the customer sets a Personal Identification Number (PIN).<BR>**Note:**<BR> * PINs are relevant to physical cards.<BR>* Some card programs do not support resetting the PIN. Holders of those cards must reset the PIN at an ATM.<BR>**Prerequisites**<BR>* Rapyd Wallet.<BR>* Wallet contact with a valid phone number.<BR>* Issued card that is activated.
         * @summary Create Hosted Page for PIN Management
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingPinBody} issuingPinBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostedCardPIN(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingPinBody: IssuingPinBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20080> {
            return localVarFp.hostedCardPIN(accessKey, contentType, salt, signature, timestamp, issuingPinBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Issue a card to a wallet contact.
         * @summary Issue Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {IssuingCardsBody} issuingCardsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingCardsBody: IssuingCardsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20076> {
            return localVarFp.issueCard(accessKey, contentType, salt, signature, timestamp, issuingCardsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a connection between an issued card and a wallet contact. Relevant to cards that are issued in bulk and not assigned to any specific person. This method can be used only once per card.
         * @summary Personalize Bulk-Issued Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsPersonalizeBody} cardsPersonalizeBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPersonalizeBody: CardsPersonalizeBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20078> {
            return localVarFp.modifyCard(accessKey, contentType, salt, signature, timestamp, cardsPersonalizeBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a Virtual Account Number object for a wallet.
         * @summary Retrieve Virtual Account History
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIssuingByRapydToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200108> {
            return localVarFp.retrieveIssuingByRapydToken(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a virtual account transaction.
         * @summary Retrieve Virtual Account Transaction
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200110> {
            return localVarFp.retrieveIssuingTransaction(accessKey, contentType, salt, signature, timestamp, virtualAccountId, transactionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the PIN code for an issued card.<BR>This method triggers the \'Issued Card PIN Set\' Webhook.<BR> **Note:**<BR>* In the sandbox, you can set any number other than 1111.<BR>* Clients with PCI certification can handle personal identifying information for cards, such as card number.<BR> * PINs are relevant to physical cards.
         * @summary Set PIN Code
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsPinBody} cardsPinBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPINCode(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPinBody: CardsPinBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20083> {
            return localVarFp.setPINCode(accessKey, contentType, salt, signature, timestamp, cardsPinBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Imulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
         * @summary Simulate Bank Transfer
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {BankaccountsBankaccounttransfertobankaccountBody} bankaccountsBankaccounttransfertobankaccountBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCompleteBankAccountIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, bankaccountsBankaccounttransfertobankaccountBody: BankaccountsBankaccounttransfertobankaccountBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200108> {
            return localVarFp.simulateCompleteBankAccountIssuingTransaction(accessKey, contentType, salt, signature, timestamp, bankaccountsBankaccounttransfertobankaccountBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Block or unblock a card that was issued via the Rapyd issuing platform.
         * @summary Update Card Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsStatusBody} cardsStatusBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsStatusBody: CardsStatusBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20078> {
            return localVarFp.updateCardStatus(accessKey, contentType, salt, signature, timestamp, cardsStatusBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
         * @summary Update Requested Currency
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {BankaccountsVirtualAccountIdBody} [bankaccountsVirtualAccountIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceivingCurrency(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, bankaccountsVirtualAccountIdBody?: BankaccountsVirtualAccountIdBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20093> {
            return localVarFp.updateReceivingCurrency(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, bankaccountsVirtualAccountIdBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a hosted page that displays details of a virtual issued card directly to the customer. The URL is available for 24 hours after the response is sent, and then it expires.
         * @summary Generate hosted page with virtual issued card details
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} cardToken ID of the Issued Card Details to Customer.
         * @param {CardDetailsCardTokenBody} cardDetailsCardTokenBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HostedIssuingCardDetailsCardTokenPost(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardToken: string, cardDetailsCardTokenBody: CardDetailsCardTokenBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20074> {
            return localVarFp.v1HostedIssuingCardDetailsCardTokenPost(accessKey, contentType, salt, signature, timestamp, cardToken, cardDetailsCardTokenBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssuingApi - object-oriented interface
 * @export
 * @class IssuingApi
 * @extends {BaseAPI}
 */
export class IssuingApi extends BaseAPI {
    /**
     * Activate a card that was issued via the Rapyd issuing platform.
     * @summary Activate Issued Card Using API
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsActivateBody} cardsActivateBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public activateCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsActivateBody: CardsActivateBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).activateCard(accessKey, contentType, salt, signature, timestamp, cardsActivateBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a card to a Google Pay wallet using Google Pay Push Provisioning.<BR>**Note:**<BR> * PCI certification is required for this method as it contains PCI data.<BR> * The response returns the `getEncryptedPaymentInstrument` string, which is used to add the card to the Google pay wallet by using the Google Pay `pushTokenizeRequest` method. For more information refer to the Google Pay Provisioning developer documentation
     * @summary Add Card to Google Pay - Google Pay Push Provisioning
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} cardId ID of the card. String starting with **card_**.
     * @param {CardTokensGooglePayBody} cardTokensGooglePayBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public addCardtoGooglePay(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, cardTokensGooglePayBody: CardTokensGooglePayBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).addCardtoGooglePay(accessKey, contentType, salt, signature, timestamp, cardId, cardTokensGooglePayBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issue a virtual account number to an existing wallet.
     * @summary Issue Virtual Account Number
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {IssuingBankaccountsBody} issuingBankaccountsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public createIssuing(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingBankaccountsBody: IssuingBankaccountsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).createIssuing(accessKey, contentType, salt, signature, timestamp, issuingBankaccountsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a card.
     * @summary Card details.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} cardId ID of a cardId. String starting with **ci_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public getCardIssuingDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).getCardIssuingDetails(accessKey, contentType, salt, signature, timestamp, cardId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all issuing cards.
     * @summary List issuing cards.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [contact] ID of a wallet contact. String starting with **cont_**.
     * @param {number} [pageNumber] Page number to retrieve.
     * @param {number} [pageSize] Number of results per page.
     * @param {number} [creationStartDate] Start date of card creation.
     * @param {number} [creationEndDate] End date of card creation.
     * @param {number} [activationStartDate] Start date of card activation.
     * @param {number} [activationEndDate] End date of card activation.
     * @param {string} [cardProgram] Card program token.
     * @param {string} [status] Card status.
     * @param {boolean} [allowDeleted] Is card allow delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public getCardIssuingList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, contact?: string, pageNumber?: number, pageSize?: number, creationStartDate?: number, creationEndDate?: number, activationStartDate?: number, activationEndDate?: number, cardProgram?: string, status?: string, allowDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).getCardIssuingList(accessKey, contentType, salt, signature, timestamp, idempotency, contact, pageNumber, pageSize, creationStartDate, creationEndDate, activationStartDate, activationEndDate, cardProgram, status, allowDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the GET method to retrieve details of a specific transaction from a specific issued card.
     * @summary Retrieve Issued Card Transaction Details
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} cardId Card id
     * @param {string} transactionId Card transaction id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public getCardIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).getCardIssuingTransaction(accessKey, contentType, salt, signature, timestamp, cardId, transactionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the GET method to retrieve a list of transactions for a specific issued card.
     * @summary List Issued Card Transactions
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} cardId ID of the issued card. String starting with **card_**.
     * @param {string} pageSize ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
     * @param {string} pageNumber Page number to retrieve.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [endDate] Timestamp of the last transaction or later, in Unix time.
     * @param {string} [minAmount] Transactions greater than a specific amount.
     * @param {string} [maxAmount] Transactions smaller than a specific amount.
     * @param {string} [merchantNameSearch] Filters the results to return only transactions that have this string as part of the name or location.
     * @param {string} [startDate] ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public getCardIssuingTransactions(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardId: string, pageSize: string, pageNumber: string, idempotency?: string, endDate?: string, minAmount?: string, maxAmount?: string, merchantNameSearch?: string, startDate?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).getCardIssuingTransactions(accessKey, contentType, salt, signature, timestamp, cardId, pageSize, pageNumber, idempotency, endDate, minAmount, maxAmount, merchantNameSearch, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of the remitter of a transfer to a virtual bank account.
     * @summary Retrieve Remitter Details
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
     * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public getRemitterDetails(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).getRemitterDetails(accessKey, contentType, salt, signature, timestamp, virtualAccountId, transactionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A contact can activate his or her physical issued card.<BR>Rapyd sends you webhooks for the following actions:<BR> * Personalize a card - See \'Bulk-Issued Card Personalized Webhook\' in online API reference.<BR> * Activate a card - See \'Issued Card Activated Webhook\' in online API reference.<BR>**Prerequisites**<BR> * Rapyd Wallet. See \'Rapyd Wallet\' in online API reference.<BR> * Wallet contact with a valid phone number. See \'Wallet Contact\' in online API reference.
     * @summary Activate Issued Card Using Hosted Page
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {IssuingActivateCardBody} issuingActivateCardBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public hostedActivateCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingActivateCardBody: IssuingActivateCardBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).hostedActivateCard(accessKey, contentType, salt, signature, timestamp, issuingActivateCardBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a hosted page for viewing and resetting a PIN.<BR>In the sandbox, you can set any number other than 1111.<BR>Rapyd sends you the \'Issued Card PIN Set\' Webhook when the customer sets a Personal Identification Number (PIN).<BR>**Note:**<BR> * PINs are relevant to physical cards.<BR>* Some card programs do not support resetting the PIN. Holders of those cards must reset the PIN at an ATM.<BR>**Prerequisites**<BR>* Rapyd Wallet.<BR>* Wallet contact with a valid phone number.<BR>* Issued card that is activated.
     * @summary Create Hosted Page for PIN Management
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {IssuingPinBody} issuingPinBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public hostedCardPIN(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingPinBody: IssuingPinBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).hostedCardPIN(accessKey, contentType, salt, signature, timestamp, issuingPinBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issue a card to a wallet contact.
     * @summary Issue Card
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {IssuingCardsBody} issuingCardsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public issueCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, issuingCardsBody: IssuingCardsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).issueCard(accessKey, contentType, salt, signature, timestamp, issuingCardsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a connection between an issued card and a wallet contact. Relevant to cards that are issued in bulk and not assigned to any specific person. This method can be used only once per card.
     * @summary Personalize Bulk-Issued Card
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsPersonalizeBody} cardsPersonalizeBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public modifyCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPersonalizeBody: CardsPersonalizeBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).modifyCard(accessKey, contentType, salt, signature, timestamp, cardsPersonalizeBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a Virtual Account Number object for a wallet.
     * @summary Retrieve Virtual Account History
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public retrieveIssuingByRapydToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).retrieveIssuingByRapydToken(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a virtual account transaction.
     * @summary Retrieve Virtual Account Transaction
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
     * @param {string} transactionId ID of the transaction, as appears in the array of transactions in the response to \&#39;Retrieve Virtual Account History\&#39;.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public retrieveIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, transactionId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).retrieveIssuingTransaction(accessKey, contentType, salt, signature, timestamp, virtualAccountId, transactionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the PIN code for an issued card.<BR>This method triggers the \'Issued Card PIN Set\' Webhook.<BR> **Note:**<BR>* In the sandbox, you can set any number other than 1111.<BR>* Clients with PCI certification can handle personal identifying information for cards, such as card number.<BR> * PINs are relevant to physical cards.
     * @summary Set PIN Code
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsPinBody} cardsPinBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public setPINCode(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsPinBody: CardsPinBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).setPINCode(accessKey, contentType, salt, signature, timestamp, cardsPinBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
     * @summary Simulate Bank Transfer
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {BankaccountsBankaccounttransfertobankaccountBody} bankaccountsBankaccounttransfertobankaccountBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public simulateCompleteBankAccountIssuingTransaction(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, bankaccountsBankaccounttransfertobankaccountBody: BankaccountsBankaccounttransfertobankaccountBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).simulateCompleteBankAccountIssuingTransaction(accessKey, contentType, salt, signature, timestamp, bankaccountsBankaccounttransfertobankaccountBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Block or unblock a card that was issued via the Rapyd issuing platform.
     * @summary Update Card Status
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsStatusBody} cardsStatusBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public updateCardStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsStatusBody: CardsStatusBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).updateCardStatus(accessKey, contentType, salt, signature, timestamp, cardsStatusBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
     * @summary Update Requested Currency
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {BankaccountsVirtualAccountIdBody} [bankaccountsVirtualAccountIdBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public updateReceivingCurrency(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, bankaccountsVirtualAccountIdBody?: BankaccountsVirtualAccountIdBody, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).updateReceivingCurrency(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, bankaccountsVirtualAccountIdBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a hosted page that displays details of a virtual issued card directly to the customer. The URL is available for 24 hours after the response is sent, and then it expires.
     * @summary Generate hosted page with virtual issued card details
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} cardToken ID of the Issued Card Details to Customer.
     * @param {CardDetailsCardTokenBody} cardDetailsCardTokenBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingApi
     */
    public v1HostedIssuingCardDetailsCardTokenPost(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardToken: string, cardDetailsCardTokenBody: CardDetailsCardTokenBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingApiFp(this.configuration).v1HostedIssuingCardDetailsCardTokenPost(accessKey, contentType, salt, signature, timestamp, cardToken, cardDetailsCardTokenBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IssuingSimulationsApi - axios parameter creator
 * @export
 */
export const IssuingSimulationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Simulate a third-party stop notice for an issued card.<BR>Relevant to the sandbox.<BR>Rapyd sets the card status to **BLO** (blocked) and sends you the Card Issuing Blocked Webhook.<BR> To unblock the card, see Update Card Status.<BR>**Prerequisites**:<BR> * Issue Card <BR> * Activate Issued Card Using API
         * @summary Simulate Blocking a Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsSimulateBlockBody} cardsSimulateBlockBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateBlockCard: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsSimulateBlockBody: CardsSimulateBlockBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateBlockCard', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateBlockCard', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateBlockCard', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateBlockCard', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateBlockCard', 'timestamp', timestamp)
            // verify required parameter 'cardsSimulateBlockBody' is not null or undefined
            assertParamExists('simulateBlockCard', 'cardsSimulateBlockBody', cardsSimulateBlockBody)
            const localVarPath = `/v1/issuing/cards/simulate_block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsSimulateBlockBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulate a retail location making a refund to an issued card.<BR> This method triggers Card Issuing Refund Webhook. This method credits the **available balance** of the wallet with the refunded amount. See \'Wallet Balance Types\' in online API reference. Use this method in the sandbox.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Refund - Non-EEA\'  in online API reference. <BR>**Prerequisites:**<BR>* An issued card. See \'Issue Card\'.<BR>* Activate the card via API or by using a Hosted Page.<BR>* Authorization of a card transaction. See \'Simulate a Card Transaction Authorization Request - EEA\'.
         * @summary Simulate a Card Refund-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsRefundBody} cardsRefundBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardRefundEEA: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsRefundBody: CardsRefundBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCardRefundEEA', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCardRefundEEA', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCardRefundEEA', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCardRefundEEA', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCardRefundEEA', 'timestamp', timestamp)
            // verify required parameter 'cardsRefundBody' is not null or undefined
            assertParamExists('simulateCardRefundEEA', 'cardsRefundBody', cardsRefundBody)
            const localVarPath = `/v1/issuing/cards/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsRefundBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method in the sandbox to simulate an adjustment to a card transaction. A retail location can adjust the amount of a transaction made by an issued card. The adjustment is either a credit or a debit. This method triggers Card Issuing Adjustment Webhook. This method updates the **available balance** of the wallet with the credit or deduction. See \'Wallet Balance Types\' in online API Reference. This method applies to cards issued in the European Economic Area (EEA). <BR>**Prerequisites:**<BR>* Issue card<BR>* Activate the card via API <BR>* Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate a Card adjustment-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsAdjustmentBody} cardsAdjustmentBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardTransactionAdjustmentEEA: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAdjustmentBody: CardsAdjustmentBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCardTransactionAdjustmentEEA', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCardTransactionAdjustmentEEA', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCardTransactionAdjustmentEEA', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCardTransactionAdjustmentEEA', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCardTransactionAdjustmentEEA', 'timestamp', timestamp)
            // verify required parameter 'cardsAdjustmentBody' is not null or undefined
            assertParamExists('simulateCardTransactionAdjustmentEEA', 'cardsAdjustmentBody', cardsAdjustmentBody)
            const localVarPath = `/v1/issuing/cards/adjustment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsAdjustmentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulate Rapyd’s request to your authorization server.<BR> If you have implemented Remote Authorization, Rapyd sends authorization requests to your remote authorization server when the card network requests approval of a transaction on a card issued to a Rapyd Wallet. Use this method in the sandbox.<BR>The response contains all the fields you must send to Rapyd when you receive an authorization request in production. See also Remote Authorization.<BR> When `financial_impact` is set to **credit**, this method triggers \'Card Issuing Credit Webhook\'.   When `financial_impact` is set to debit, this method triggers \'Card Issuing Authorization Approved\' Webhook. Funds in the wallet move from **available balance** to **on-hold balance**. <BR> To simulate deducting the funds from the wallet, run \'Simulate Clearing a Card Transaction - EEA\'.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see Simulate a Card Transaction Authorization Request - Non-EEA.<BR>**Prerequisites**<BR> * A **company** wallet with a **personal** contact. Run \'Create Wallet\' and then \'Add Contact to Wallet\'<BR>* Issue Card<BR> * Activate Issued Card Using API<BR> * Add Funds to Wallet Account
         * @summary imulate a Card Transaction Authorization Request-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsAuthorizationBody} cardsAuthorizationBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardTransactionAuthorizationRequestEEA: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAuthorizationBody: CardsAuthorizationBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationRequestEEA', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationRequestEEA', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationRequestEEA', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationRequestEEA', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationRequestEEA', 'timestamp', timestamp)
            // verify required parameter 'cardsAuthorizationBody' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationRequestEEA', 'cardsAuthorizationBody', cardsAuthorizationBody)
            const localVarPath = `/v1/issuing/cards/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsAuthorizationBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulate a retail location’s reversal of a card authorization.<BR>The retail location where a card was used for a purchase can send a reversal through the card network to cancel a previous authorization request. This can occur when the transaction is not completed within the time required by the card issuer. When Rapyd receives a request for reversal from the card network, it reverses the transaction and sends you a webhook. Use this method in the sandbox.<BR>This method triggers Card Issuing Reversal Webhook . This method moves the reversed funds in the wallet from **on-hold** balance to **available balance**. <BR>This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Transaction Authorization Reversal - Non-EEA\' in Rapyd\'s online API reference.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate a Card Transaction Authorization Reversal-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsReversalBody} cardsReversalBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardTransactionAuthorizationReversalEEA: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsReversalBody: CardsReversalBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationReversalEEA', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationReversalEEA', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationReversalEEA', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationReversalEEA', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationReversalEEA', 'timestamp', timestamp)
            // verify required parameter 'cardsReversalBody' is not null or undefined
            assertParamExists('simulateCardTransactionAuthorizationReversalEEA', 'cardsReversalBody', cardsReversalBody)
            const localVarPath = `/v1/issuing/cards/reversal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsReversalBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulate clearing a debit transaction.<BR>This method triggers Webhook - Card Issuing Sale. When a fee is charged for an ATM transaction, this method also triggers Webhook - Card Issuing ATM Fee. Use this method in the sandbox.<BR>This method deducts funds from the **on-hold** balance in the wallet.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate Clearing a Card Transaction-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsClearingBody} cardsClearingBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateClearingCardTransactionEEA: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsClearingBody: CardsClearingBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateClearingCardTransactionEEA', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateClearingCardTransactionEEA', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateClearingCardTransactionEEA', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateClearingCardTransactionEEA', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateClearingCardTransactionEEA', 'timestamp', timestamp)
            // verify required parameter 'cardsClearingBody' is not null or undefined
            assertParamExists('simulateClearingCardTransactionEEA', 'cardsClearingBody', cardsClearingBody)
            const localVarPath = `/v1/issuing/cards/clearing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardsClearingBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuingSimulationsApi - functional programming interface
 * @export
 */
export const IssuingSimulationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuingSimulationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Simulate a third-party stop notice for an issued card.<BR>Relevant to the sandbox.<BR>Rapyd sets the card status to **BLO** (blocked) and sends you the Card Issuing Blocked Webhook.<BR> To unblock the card, see Update Card Status.<BR>**Prerequisites**:<BR> * Issue Card <BR> * Activate Issued Card Using API
         * @summary Simulate Blocking a Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsSimulateBlockBody} cardsSimulateBlockBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateBlockCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsSimulateBlockBody: CardsSimulateBlockBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20086>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateBlockCard(accessKey, contentType, salt, signature, timestamp, cardsSimulateBlockBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingSimulationsApi.simulateBlockCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simulate a retail location making a refund to an issued card.<BR> This method triggers Card Issuing Refund Webhook. This method credits the **available balance** of the wallet with the refunded amount. See \'Wallet Balance Types\' in online API reference. Use this method in the sandbox.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Refund - Non-EEA\'  in online API reference. <BR>**Prerequisites:**<BR>* An issued card. See \'Issue Card\'.<BR>* Activate the card via API or by using a Hosted Page.<BR>* Authorization of a card transaction. See \'Simulate a Card Transaction Authorization Request - EEA\'.
         * @summary Simulate a Card Refund-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsRefundBody} cardsRefundBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCardRefundEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsRefundBody: CardsRefundBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20089>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCardRefundEEA(accessKey, contentType, salt, signature, timestamp, cardsRefundBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingSimulationsApi.simulateCardRefundEEA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method in the sandbox to simulate an adjustment to a card transaction. A retail location can adjust the amount of a transaction made by an issued card. The adjustment is either a credit or a debit. This method triggers Card Issuing Adjustment Webhook. This method updates the **available balance** of the wallet with the credit or deduction. See \'Wallet Balance Types\' in online API Reference. This method applies to cards issued in the European Economic Area (EEA). <BR>**Prerequisites:**<BR>* Issue card<BR>* Activate the card via API <BR>* Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate a Card adjustment-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsAdjustmentBody} cardsAdjustmentBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCardTransactionAdjustmentEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAdjustmentBody: CardsAdjustmentBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20089>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCardTransactionAdjustmentEEA(accessKey, contentType, salt, signature, timestamp, cardsAdjustmentBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingSimulationsApi.simulateCardTransactionAdjustmentEEA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simulate Rapyd’s request to your authorization server.<BR> If you have implemented Remote Authorization, Rapyd sends authorization requests to your remote authorization server when the card network requests approval of a transaction on a card issued to a Rapyd Wallet. Use this method in the sandbox.<BR>The response contains all the fields you must send to Rapyd when you receive an authorization request in production. See also Remote Authorization.<BR> When `financial_impact` is set to **credit**, this method triggers \'Card Issuing Credit Webhook\'.   When `financial_impact` is set to debit, this method triggers \'Card Issuing Authorization Approved\' Webhook. Funds in the wallet move from **available balance** to **on-hold balance**. <BR> To simulate deducting the funds from the wallet, run \'Simulate Clearing a Card Transaction - EEA\'.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see Simulate a Card Transaction Authorization Request - Non-EEA.<BR>**Prerequisites**<BR> * A **company** wallet with a **personal** contact. Run \'Create Wallet\' and then \'Add Contact to Wallet\'<BR>* Issue Card<BR> * Activate Issued Card Using API<BR> * Add Funds to Wallet Account
         * @summary imulate a Card Transaction Authorization Request-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsAuthorizationBody} cardsAuthorizationBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCardTransactionAuthorizationRequestEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAuthorizationBody: CardsAuthorizationBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20087>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCardTransactionAuthorizationRequestEEA(accessKey, contentType, salt, signature, timestamp, cardsAuthorizationBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingSimulationsApi.simulateCardTransactionAuthorizationRequestEEA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simulate a retail location’s reversal of a card authorization.<BR>The retail location where a card was used for a purchase can send a reversal through the card network to cancel a previous authorization request. This can occur when the transaction is not completed within the time required by the card issuer. When Rapyd receives a request for reversal from the card network, it reverses the transaction and sends you a webhook. Use this method in the sandbox.<BR>This method triggers Card Issuing Reversal Webhook . This method moves the reversed funds in the wallet from **on-hold** balance to **available balance**. <BR>This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Transaction Authorization Reversal - Non-EEA\' in Rapyd\'s online API reference.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate a Card Transaction Authorization Reversal-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsReversalBody} cardsReversalBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCardTransactionAuthorizationReversalEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsReversalBody: CardsReversalBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20088>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCardTransactionAuthorizationReversalEEA(accessKey, contentType, salt, signature, timestamp, cardsReversalBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingSimulationsApi.simulateCardTransactionAuthorizationReversalEEA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simulate clearing a debit transaction.<BR>This method triggers Webhook - Card Issuing Sale. When a fee is charged for an ATM transaction, this method also triggers Webhook - Card Issuing ATM Fee. Use this method in the sandbox.<BR>This method deducts funds from the **on-hold** balance in the wallet.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate Clearing a Card Transaction-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsClearingBody} cardsClearingBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateClearingCardTransactionEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsClearingBody: CardsClearingBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20089>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateClearingCardTransactionEEA(accessKey, contentType, salt, signature, timestamp, cardsClearingBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuingSimulationsApi.simulateClearingCardTransactionEEA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IssuingSimulationsApi - factory interface
 * @export
 */
export const IssuingSimulationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuingSimulationsApiFp(configuration)
    return {
        /**
         * Simulate a third-party stop notice for an issued card.<BR>Relevant to the sandbox.<BR>Rapyd sets the card status to **BLO** (blocked) and sends you the Card Issuing Blocked Webhook.<BR> To unblock the card, see Update Card Status.<BR>**Prerequisites**:<BR> * Issue Card <BR> * Activate Issued Card Using API
         * @summary Simulate Blocking a Card
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsSimulateBlockBody} cardsSimulateBlockBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateBlockCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsSimulateBlockBody: CardsSimulateBlockBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20086> {
            return localVarFp.simulateBlockCard(accessKey, contentType, salt, signature, timestamp, cardsSimulateBlockBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulate a retail location making a refund to an issued card.<BR> This method triggers Card Issuing Refund Webhook. This method credits the **available balance** of the wallet with the refunded amount. See \'Wallet Balance Types\' in online API reference. Use this method in the sandbox.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Refund - Non-EEA\'  in online API reference. <BR>**Prerequisites:**<BR>* An issued card. See \'Issue Card\'.<BR>* Activate the card via API or by using a Hosted Page.<BR>* Authorization of a card transaction. See \'Simulate a Card Transaction Authorization Request - EEA\'.
         * @summary Simulate a Card Refund-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsRefundBody} cardsRefundBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardRefundEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsRefundBody: CardsRefundBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20089> {
            return localVarFp.simulateCardRefundEEA(accessKey, contentType, salt, signature, timestamp, cardsRefundBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method in the sandbox to simulate an adjustment to a card transaction. A retail location can adjust the amount of a transaction made by an issued card. The adjustment is either a credit or a debit. This method triggers Card Issuing Adjustment Webhook. This method updates the **available balance** of the wallet with the credit or deduction. See \'Wallet Balance Types\' in online API Reference. This method applies to cards issued in the European Economic Area (EEA). <BR>**Prerequisites:**<BR>* Issue card<BR>* Activate the card via API <BR>* Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate a Card adjustment-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsAdjustmentBody} cardsAdjustmentBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardTransactionAdjustmentEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAdjustmentBody: CardsAdjustmentBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20089> {
            return localVarFp.simulateCardTransactionAdjustmentEEA(accessKey, contentType, salt, signature, timestamp, cardsAdjustmentBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulate Rapyd’s request to your authorization server.<BR> If you have implemented Remote Authorization, Rapyd sends authorization requests to your remote authorization server when the card network requests approval of a transaction on a card issued to a Rapyd Wallet. Use this method in the sandbox.<BR>The response contains all the fields you must send to Rapyd when you receive an authorization request in production. See also Remote Authorization.<BR> When `financial_impact` is set to **credit**, this method triggers \'Card Issuing Credit Webhook\'.   When `financial_impact` is set to debit, this method triggers \'Card Issuing Authorization Approved\' Webhook. Funds in the wallet move from **available balance** to **on-hold balance**. <BR> To simulate deducting the funds from the wallet, run \'Simulate Clearing a Card Transaction - EEA\'.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see Simulate a Card Transaction Authorization Request - Non-EEA.<BR>**Prerequisites**<BR> * A **company** wallet with a **personal** contact. Run \'Create Wallet\' and then \'Add Contact to Wallet\'<BR>* Issue Card<BR> * Activate Issued Card Using API<BR> * Add Funds to Wallet Account
         * @summary imulate a Card Transaction Authorization Request-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsAuthorizationBody} cardsAuthorizationBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardTransactionAuthorizationRequestEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAuthorizationBody: CardsAuthorizationBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20087> {
            return localVarFp.simulateCardTransactionAuthorizationRequestEEA(accessKey, contentType, salt, signature, timestamp, cardsAuthorizationBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulate a retail location’s reversal of a card authorization.<BR>The retail location where a card was used for a purchase can send a reversal through the card network to cancel a previous authorization request. This can occur when the transaction is not completed within the time required by the card issuer. When Rapyd receives a request for reversal from the card network, it reverses the transaction and sends you a webhook. Use this method in the sandbox.<BR>This method triggers Card Issuing Reversal Webhook . This method moves the reversed funds in the wallet from **on-hold** balance to **available balance**. <BR>This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Transaction Authorization Reversal - Non-EEA\' in Rapyd\'s online API reference.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate a Card Transaction Authorization Reversal-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsReversalBody} cardsReversalBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCardTransactionAuthorizationReversalEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsReversalBody: CardsReversalBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20088> {
            return localVarFp.simulateCardTransactionAuthorizationReversalEEA(accessKey, contentType, salt, signature, timestamp, cardsReversalBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulate clearing a debit transaction.<BR>This method triggers Webhook - Card Issuing Sale. When a fee is charged for an ATM transaction, this method also triggers Webhook - Card Issuing ATM Fee. Use this method in the sandbox.<BR>This method deducts funds from the **on-hold** balance in the wallet.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
         * @summary Simulate Clearing a Card Transaction-EEA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {CardsClearingBody} cardsClearingBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateClearingCardTransactionEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsClearingBody: CardsClearingBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20089> {
            return localVarFp.simulateClearingCardTransactionEEA(accessKey, contentType, salt, signature, timestamp, cardsClearingBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssuingSimulationsApi - object-oriented interface
 * @export
 * @class IssuingSimulationsApi
 * @extends {BaseAPI}
 */
export class IssuingSimulationsApi extends BaseAPI {
    /**
     * Simulate a third-party stop notice for an issued card.<BR>Relevant to the sandbox.<BR>Rapyd sets the card status to **BLO** (blocked) and sends you the Card Issuing Blocked Webhook.<BR> To unblock the card, see Update Card Status.<BR>**Prerequisites**:<BR> * Issue Card <BR> * Activate Issued Card Using API
     * @summary Simulate Blocking a Card
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsSimulateBlockBody} cardsSimulateBlockBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingSimulationsApi
     */
    public simulateBlockCard(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsSimulateBlockBody: CardsSimulateBlockBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingSimulationsApiFp(this.configuration).simulateBlockCard(accessKey, contentType, salt, signature, timestamp, cardsSimulateBlockBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulate a retail location making a refund to an issued card.<BR> This method triggers Card Issuing Refund Webhook. This method credits the **available balance** of the wallet with the refunded amount. See \'Wallet Balance Types\' in online API reference. Use this method in the sandbox.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Refund - Non-EEA\'  in online API reference. <BR>**Prerequisites:**<BR>* An issued card. See \'Issue Card\'.<BR>* Activate the card via API or by using a Hosted Page.<BR>* Authorization of a card transaction. See \'Simulate a Card Transaction Authorization Request - EEA\'.
     * @summary Simulate a Card Refund-EEA
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsRefundBody} cardsRefundBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingSimulationsApi
     */
    public simulateCardRefundEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsRefundBody: CardsRefundBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingSimulationsApiFp(this.configuration).simulateCardRefundEEA(accessKey, contentType, salt, signature, timestamp, cardsRefundBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method in the sandbox to simulate an adjustment to a card transaction. A retail location can adjust the amount of a transaction made by an issued card. The adjustment is either a credit or a debit. This method triggers Card Issuing Adjustment Webhook. This method updates the **available balance** of the wallet with the credit or deduction. See \'Wallet Balance Types\' in online API Reference. This method applies to cards issued in the European Economic Area (EEA). <BR>**Prerequisites:**<BR>* Issue card<BR>* Activate the card via API <BR>* Simulate a Card Transaction Authorization Request - EEA
     * @summary Simulate a Card adjustment-EEA
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsAdjustmentBody} cardsAdjustmentBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingSimulationsApi
     */
    public simulateCardTransactionAdjustmentEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAdjustmentBody: CardsAdjustmentBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingSimulationsApiFp(this.configuration).simulateCardTransactionAdjustmentEEA(accessKey, contentType, salt, signature, timestamp, cardsAdjustmentBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulate Rapyd’s request to your authorization server.<BR> If you have implemented Remote Authorization, Rapyd sends authorization requests to your remote authorization server when the card network requests approval of a transaction on a card issued to a Rapyd Wallet. Use this method in the sandbox.<BR>The response contains all the fields you must send to Rapyd when you receive an authorization request in production. See also Remote Authorization.<BR> When `financial_impact` is set to **credit**, this method triggers \'Card Issuing Credit Webhook\'.   When `financial_impact` is set to debit, this method triggers \'Card Issuing Authorization Approved\' Webhook. Funds in the wallet move from **available balance** to **on-hold balance**. <BR> To simulate deducting the funds from the wallet, run \'Simulate Clearing a Card Transaction - EEA\'.<BR> This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see Simulate a Card Transaction Authorization Request - Non-EEA.<BR>**Prerequisites**<BR> * A **company** wallet with a **personal** contact. Run \'Create Wallet\' and then \'Add Contact to Wallet\'<BR>* Issue Card<BR> * Activate Issued Card Using API<BR> * Add Funds to Wallet Account
     * @summary imulate a Card Transaction Authorization Request-EEA
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsAuthorizationBody} cardsAuthorizationBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingSimulationsApi
     */
    public simulateCardTransactionAuthorizationRequestEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsAuthorizationBody: CardsAuthorizationBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingSimulationsApiFp(this.configuration).simulateCardTransactionAuthorizationRequestEEA(accessKey, contentType, salt, signature, timestamp, cardsAuthorizationBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulate a retail location’s reversal of a card authorization.<BR>The retail location where a card was used for a purchase can send a reversal through the card network to cancel a previous authorization request. This can occur when the transaction is not completed within the time required by the card issuer. When Rapyd receives a request for reversal from the card network, it reverses the transaction and sends you a webhook. Use this method in the sandbox.<BR>This method triggers Card Issuing Reversal Webhook . This method moves the reversed funds in the wallet from **on-hold** balance to **available balance**. <BR>This method applies to cards issued in the European Economic Area (EEA). For cards issued outside the EEA, see \'Simulate a Card Transaction Authorization Reversal - Non-EEA\' in Rapyd\'s online API reference.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
     * @summary Simulate a Card Transaction Authorization Reversal-EEA
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsReversalBody} cardsReversalBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingSimulationsApi
     */
    public simulateCardTransactionAuthorizationReversalEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsReversalBody: CardsReversalBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingSimulationsApiFp(this.configuration).simulateCardTransactionAuthorizationReversalEEA(accessKey, contentType, salt, signature, timestamp, cardsReversalBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulate clearing a debit transaction.<BR>This method triggers Webhook - Card Issuing Sale. When a fee is charged for an ATM transaction, this method also triggers Webhook - Card Issuing ATM Fee. Use this method in the sandbox.<BR>This method deducts funds from the **on-hold** balance in the wallet.<BR>**Prerequisites:**<BR> * Issue Card<BR> * Activate Issued Card Using API<BR> * Simulate a Card Transaction Authorization Request - EEA
     * @summary Simulate Clearing a Card Transaction-EEA
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {CardsClearingBody} cardsClearingBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuingSimulationsApi
     */
    public simulateClearingCardTransactionEEA(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, cardsClearingBody: CardsClearingBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return IssuingSimulationsApiFp(this.configuration).simulateClearingCardTransactionEEA(accessKey, contentType, salt, signature, timestamp, cardsClearingBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocalizationMethodsApi - axios parameter creator
 * @export
 */
export const LocalizationMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
         * @summary Get FX Rate
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - **payment**, **payout**.
         * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
         * @param {string} [date] The date when the rate is applicable. Today or earlier. Format **YYYY-MM-DD**
         * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - **buy**, **sell**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFXRate: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, actionType: string, buyCurrency: string, sellCurrency: string, idempotency?: string, amount?: number, date?: string, fixedSide?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getFXRate', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getFXRate', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getFXRate', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getFXRate', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getFXRate', 'timestamp', timestamp)
            // verify required parameter 'actionType' is not null or undefined
            assertParamExists('getFXRate', 'actionType', actionType)
            // verify required parameter 'buyCurrency' is not null or undefined
            assertParamExists('getFXRate', 'buyCurrency', buyCurrency)
            // verify required parameter 'sellCurrency' is not null or undefined
            assertParamExists('getFXRate', 'sellCurrency', sellCurrency)
            const localVarPath = `/v1/fx_rates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (buyCurrency !== undefined) {
                localVarQueryParameter['buy_currency'] = buyCurrency;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (fixedSide !== undefined) {
                localVarQueryParameter['fixed_side'] = fixedSide;
            }

            if (sellCurrency !== undefined) {
                localVarQueryParameter['sell_currency'] = sellCurrency;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all countries.
         * @summary List Countries
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCountries: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listCountries', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listCountries', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listCountries', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listCountries', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listCountries', 'timestamp', timestamp)
            const localVarPath = `/v1/data/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all currencies.
         * @summary List Currencies
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrencies: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listCurrencies', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listCurrencies', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listCurrencies', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listCurrencies', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listCurrencies', 'timestamp', timestamp)
            const localVarPath = `/v1/data/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of the languages supported for hosted pages.<BR> A hosted page can appear in many foreign languages. The `language` (or `merchant_language`) field determines the default language of a hosted page. The field type is string. Use lower-case letters for the value.<BR> * If no value is specified, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English. <BR> Relevant to: <BR>* Display Issued Card Details to Customer <BR> * Create Subscription by Hosted Page <BR> * Create Checkout Page <BR> * Create Payment Link <BR> * Create Beneficiary Tokenization Page <BR> * Create Card Token <BR> * Create Identity Verification Page <BR> * Activate Issued Card Using Hosted Page <BR> * Create Hosted Page for PIN Management 
         * @summary List Supported Languages
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedLanguages: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listSupportedLanguages', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listSupportedLanguages', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listSupportedLanguages', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listSupportedLanguages', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listSupportedLanguages', 'timestamp', timestamp)
            const localVarPath = `/v1/hosted/config/supported_languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalizationMethodsApi - functional programming interface
 * @export
 */
export const LocalizationMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocalizationMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
         * @summary Get FX Rate
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - **payment**, **payout**.
         * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
         * @param {string} [date] The date when the rate is applicable. Today or earlier. Format **YYYY-MM-DD**
         * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - **buy**, **sell**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFXRate(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, actionType: string, buyCurrency: string, sellCurrency: string, idempotency?: string, amount?: number, date?: string, fixedSide?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200104>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFXRate(accessKey, contentType, salt, signature, timestamp, actionType, buyCurrency, sellCurrency, idempotency, amount, date, fixedSide, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalizationMethodsApi.getFXRate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all countries.
         * @summary List Countries
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCountries(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200121>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCountries(accessKey, contentType, salt, signature, timestamp, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalizationMethodsApi.listCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all currencies.
         * @summary List Currencies
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCurrencies(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200122>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCurrencies(accessKey, contentType, salt, signature, timestamp, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalizationMethodsApi.listCurrencies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of the languages supported for hosted pages.<BR> A hosted page can appear in many foreign languages. The `language` (or `merchant_language`) field determines the default language of a hosted page. The field type is string. Use lower-case letters for the value.<BR> * If no value is specified, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English. <BR> Relevant to: <BR>* Display Issued Card Details to Customer <BR> * Create Subscription by Hosted Page <BR> * Create Checkout Page <BR> * Create Payment Link <BR> * Create Beneficiary Tokenization Page <BR> * Create Card Token <BR> * Create Identity Verification Page <BR> * Activate Issued Card Using Hosted Page <BR> * Create Hosted Page for PIN Management 
         * @summary List Supported Languages
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupportedLanguages(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200120>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupportedLanguages(accessKey, contentType, salt, signature, timestamp, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalizationMethodsApi.listSupportedLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocalizationMethodsApi - factory interface
 * @export
 */
export const LocalizationMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocalizationMethodsApiFp(configuration)
    return {
        /**
         * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
         * @summary Get FX Rate
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - **payment**, **payout**.
         * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
         * @param {string} [date] The date when the rate is applicable. Today or earlier. Format **YYYY-MM-DD**
         * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - **buy**, **sell**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFXRate(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, actionType: string, buyCurrency: string, sellCurrency: string, idempotency?: string, amount?: number, date?: string, fixedSide?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200104> {
            return localVarFp.getFXRate(accessKey, contentType, salt, signature, timestamp, actionType, buyCurrency, sellCurrency, idempotency, amount, date, fixedSide, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all countries.
         * @summary List Countries
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCountries(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200121> {
            return localVarFp.listCountries(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all currencies.
         * @summary List Currencies
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrencies(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200122> {
            return localVarFp.listCurrencies(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of the languages supported for hosted pages.<BR> A hosted page can appear in many foreign languages. The `language` (or `merchant_language`) field determines the default language of a hosted page. The field type is string. Use lower-case letters for the value.<BR> * If no value is specified, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English. <BR> Relevant to: <BR>* Display Issued Card Details to Customer <BR> * Create Subscription by Hosted Page <BR> * Create Checkout Page <BR> * Create Payment Link <BR> * Create Beneficiary Tokenization Page <BR> * Create Card Token <BR> * Create Identity Verification Page <BR> * Activate Issued Card Using Hosted Page <BR> * Create Hosted Page for PIN Management 
         * @summary List Supported Languages
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedLanguages(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200120> {
            return localVarFp.listSupportedLanguages(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalizationMethodsApi - object-oriented interface
 * @export
 * @class LocalizationMethodsApi
 * @extends {BaseAPI}
 */
export class LocalizationMethodsApi extends BaseAPI {
    /**
     * Retrieve a daily rate for conversion of currencies in payments and payouts. Rapyd uses a snapshot of daily foreign exchange rates fetched at 9 PM UTC. The rate returned includes the FX markup fees.
     * @summary Get FX Rate
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} actionType Determines the type of transaction that the currency exchange applies to. One of the following - **payment**, **payout**.
     * @param {string} buyCurrency Defines the currency purchased in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
     * @param {string} sellCurrency Defines the currency sold in the currency exchange transaction. Three-letter ISO 4217 code in Uppercase.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {number} [amount] Amount of the currency exchange transaction, in units of the fixed-side currency in Decimal.
     * @param {string} [date] The date when the rate is applicable. Today or earlier. Format **YYYY-MM-DD**
     * @param {string} [fixedSide] Indicates whether the rate is fixed for the currency defined by buy_currency or sell_currency. One of the following - **buy**, **sell**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationMethodsApi
     */
    public getFXRate(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, actionType: string, buyCurrency: string, sellCurrency: string, idempotency?: string, amount?: number, date?: string, fixedSide?: string, options?: RawAxiosRequestConfig) {
        return LocalizationMethodsApiFp(this.configuration).getFXRate(accessKey, contentType, salt, signature, timestamp, actionType, buyCurrency, sellCurrency, idempotency, amount, date, fixedSide, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all countries.
     * @summary List Countries
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationMethodsApi
     */
    public listCountries(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return LocalizationMethodsApiFp(this.configuration).listCountries(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all currencies.
     * @summary List Currencies
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationMethodsApi
     */
    public listCurrencies(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return LocalizationMethodsApiFp(this.configuration).listCurrencies(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of the languages supported for hosted pages.<BR> A hosted page can appear in many foreign languages. The `language` (or `merchant_language`) field determines the default language of a hosted page. The field type is string. Use lower-case letters for the value.<BR> * If no value is specified, the language of the user\'s browser is used. <BR> * If the language of the user\'s browser cannot be determined, the default language is English. <BR> Relevant to: <BR>* Display Issued Card Details to Customer <BR> * Create Subscription by Hosted Page <BR> * Create Checkout Page <BR> * Create Payment Link <BR> * Create Beneficiary Tokenization Page <BR> * Create Card Token <BR> * Create Identity Verification Page <BR> * Activate Issued Card Using Hosted Page <BR> * Create Hosted Page for PIN Management 
     * @summary List Supported Languages
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationMethodsApi
     */
    public listSupportedLanguages(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return LocalizationMethodsApiFp(this.configuration).listSupportedLanguages(accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an order for goods. For services, see Create Subscription.
         * @summary Create an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1OrdersBody} [v1OrdersBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1OrdersBody?: V1OrdersBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createOrder', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createOrder', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createOrder', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createOrder', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrder', 'timestamp', timestamp)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1OrdersBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all orders.
         * @summary List Orders
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [limit] The maximum number of orders to return. Range - 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve.
         * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrder: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listOrder', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listOrder', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listOrder', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listOrder', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listOrder', 'timestamp', timestamp)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pay an order.
         * @summary Pay an order.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {OrderIdPayBody} orderIdPayBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payOrder: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdPayBody: OrderIdPayBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('payOrder', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('payOrder', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('payOrder', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('payOrder', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('payOrder', 'timestamp', timestamp)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('payOrder', 'orderId', orderId)
            // verify required parameter 'orderIdPayBody' is not null or undefined
            assertParamExists('payOrder', 'orderIdPayBody', orderIdPayBody)
            const localVarPath = `/v1/orders/{orderId}/pay`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderIdPayBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of an order.
         * @summary Retrieve an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrder: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveOrder', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveOrder', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveOrder', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveOrder', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveOrder', 'timestamp', timestamp)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('retrieveOrder', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify an order.
         * @summary Update an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {OrdersOrderIdBody} ordersOrderIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, ordersOrderIdBody: OrdersOrderIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateOrder', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateOrder', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateOrder', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateOrder', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateOrder', 'timestamp', timestamp)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            // verify required parameter 'ordersOrderIdBody' is not null or undefined
            assertParamExists('updateOrder', 'ordersOrderIdBody', ordersOrderIdBody)
            const localVarPath = `/v1/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ordersOrderIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an order for goods. For services, see Create Subscription.
         * @summary Create an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1OrdersBody} [v1OrdersBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1OrdersBody?: V1OrdersBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(accessKey, contentType, salt, signature, timestamp, idempotency, v1OrdersBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all orders.
         * @summary List Orders
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [limit] The maximum number of orders to return. Range - 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve.
         * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrder(accessKey, contentType, salt, signature, timestamp, idempotency, limit, endingBefore, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.listOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pay an order.
         * @summary Pay an order.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {OrderIdPayBody} orderIdPayBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdPayBody: OrderIdPayBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payOrder(accessKey, contentType, salt, signature, timestamp, orderId, orderIdPayBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.payOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of an order.
         * @summary Retrieve an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrder(accessKey, contentType, salt, signature, timestamp, orderId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.retrieveOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify an order.
         * @summary Update an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {OrdersOrderIdBody} ordersOrderIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, ordersOrderIdBody: OrdersOrderIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(accessKey, contentType, salt, signature, timestamp, orderId, ordersOrderIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.updateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Create an order for goods. For services, see Create Subscription.
         * @summary Create an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1OrdersBody} [v1OrdersBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1OrdersBody?: V1OrdersBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20047> {
            return localVarFp.createOrder(accessKey, contentType, salt, signature, timestamp, idempotency, v1OrdersBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all orders.
         * @summary List Orders
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [limit] The maximum number of orders to return. Range - 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve.
         * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20046> {
            return localVarFp.listOrder(accessKey, contentType, salt, signature, timestamp, idempotency, limit, endingBefore, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Pay an order.
         * @summary Pay an order.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {OrderIdPayBody} orderIdPayBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdPayBody: OrderIdPayBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20047> {
            return localVarFp.payOrder(accessKey, contentType, salt, signature, timestamp, orderId, orderIdPayBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of an order.
         * @summary Retrieve an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20047> {
            return localVarFp.retrieveOrder(accessKey, contentType, salt, signature, timestamp, orderId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify an order.
         * @summary Update an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with **order_**.
         * @param {OrdersOrderIdBody} ordersOrderIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, ordersOrderIdBody: OrdersOrderIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20047> {
            return localVarFp.updateOrder(accessKey, contentType, salt, signature, timestamp, orderId, ordersOrderIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Create an order for goods. For services, see Create Subscription.
     * @summary Create an Order
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {V1OrdersBody} [v1OrdersBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1OrdersBody?: V1OrdersBody, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).createOrder(accessKey, contentType, salt, signature, timestamp, idempotency, v1OrdersBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all orders.
     * @summary List Orders
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [limit] The maximum number of orders to return. Range - 1-100. Default is 10.
     * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve.
     * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).listOrder(accessKey, contentType, salt, signature, timestamp, idempotency, limit, endingBefore, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pay an order.
     * @summary Pay an order.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} orderId ID of the order. String starting with **order_**.
     * @param {OrderIdPayBody} orderIdPayBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public payOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdPayBody: OrderIdPayBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).payOrder(accessKey, contentType, salt, signature, timestamp, orderId, orderIdPayBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of an order.
     * @summary Retrieve an Order
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} orderId ID of the order. String starting with **order_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public retrieveOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).retrieveOrder(accessKey, contentType, salt, signature, timestamp, orderId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify an order.
     * @summary Update an Order
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} orderId ID of the order. String starting with **order_**.
     * @param {OrdersOrderIdBody} ordersOrderIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, ordersOrderIdBody: OrdersOrderIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).updateOrder(accessKey, contentType, salt, signature, timestamp, orderId, ordersOrderIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderReturnApi - axios parameter creator
 * @export
 */
export const OrderReturnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all order returns.
         * @summary List Returns
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [limit] The maximum number of returns to list. Range - 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve a return from.
         * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve a return from.
         * @param {Array<string>} [tokens] Filters the list for orders related to the specified order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderReturn: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, tokens?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listOrderReturn', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listOrderReturn', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listOrderReturn', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listOrderReturn', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listOrderReturn', 'timestamp', timestamp)
            const localVarPath = `/v1/order_returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (tokens) {
                localVarQueryParameter['tokens'] = tokens.join(COLLECTION_FORMATS.csv);
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a return.
         * @summary Retrieve a Return
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderReturnsId ID of the return. String starting with **orre_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrderReturn: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderReturnsId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveOrderReturn', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveOrderReturn', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveOrderReturn', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveOrderReturn', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveOrderReturn', 'timestamp', timestamp)
            // verify required parameter 'orderReturnsId' is not null or undefined
            assertParamExists('retrieveOrderReturn', 'orderReturnsId', orderReturnsId)
            const localVarPath = `/v1/order_returns/{orderReturnsId}`
                .replace(`{${"orderReturnsId"}}`, encodeURIComponent(String(orderReturnsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a return against an order. The maximum amount of the return is the amount of the order
         * @summary Create a Return Against an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with order_.
         * @param {OrderIdReturnsBody} orderIdReturnsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnsOrder: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdReturnsBody: OrderIdReturnsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('returnsOrder', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('returnsOrder', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('returnsOrder', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('returnsOrder', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('returnsOrder', 'timestamp', timestamp)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('returnsOrder', 'orderId', orderId)
            // verify required parameter 'orderIdReturnsBody' is not null or undefined
            assertParamExists('returnsOrder', 'orderIdReturnsBody', orderIdReturnsBody)
            const localVarPath = `/v1/orders/{orderId}/returns`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderIdReturnsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderReturnApi - functional programming interface
 * @export
 */
export const OrderReturnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderReturnApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all order returns.
         * @summary List Returns
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [limit] The maximum number of returns to list. Range - 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve a return from.
         * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve a return from.
         * @param {Array<string>} [tokens] Filters the list for orders related to the specified order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderReturn(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, tokens?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrderReturn(accessKey, contentType, salt, signature, timestamp, idempotency, limit, endingBefore, startingAfter, tokens, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderReturnApi.listOrderReturn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a return.
         * @summary Retrieve a Return
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderReturnsId ID of the return. String starting with **orre_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrderReturn(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderReturnsId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrderReturn(accessKey, contentType, salt, signature, timestamp, orderReturnsId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderReturnApi.retrieveOrderReturn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Make a return against an order. The maximum amount of the return is the amount of the order
         * @summary Create a Return Against an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with order_.
         * @param {OrderIdReturnsBody} orderIdReturnsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnsOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdReturnsBody: OrderIdReturnsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnsOrder(accessKey, contentType, salt, signature, timestamp, orderId, orderIdReturnsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderReturnApi.returnsOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderReturnApi - factory interface
 * @export
 */
export const OrderReturnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderReturnApiFp(configuration)
    return {
        /**
         * Retrieve a list of all order returns.
         * @summary List Returns
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [limit] The maximum number of returns to list. Range - 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve a return from.
         * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve a return from.
         * @param {Array<string>} [tokens] Filters the list for orders related to the specified order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderReturn(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, tokens?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20049> {
            return localVarFp.listOrderReturn(accessKey, contentType, salt, signature, timestamp, idempotency, limit, endingBefore, startingAfter, tokens, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a return.
         * @summary Retrieve a Return
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderReturnsId ID of the return. String starting with **orre_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrderReturn(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderReturnsId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20048> {
            return localVarFp.retrieveOrderReturn(accessKey, contentType, salt, signature, timestamp, orderReturnsId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a return against an order. The maximum amount of the return is the amount of the order
         * @summary Create a Return Against an Order
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} orderId ID of the order. String starting with order_.
         * @param {OrderIdReturnsBody} orderIdReturnsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnsOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdReturnsBody: OrderIdReturnsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20048> {
            return localVarFp.returnsOrder(accessKey, contentType, salt, signature, timestamp, orderId, orderIdReturnsBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderReturnApi - object-oriented interface
 * @export
 * @class OrderReturnApi
 * @extends {BaseAPI}
 */
export class OrderReturnApi extends BaseAPI {
    /**
     * Retrieve a list of all order returns.
     * @summary List Returns
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [limit] The maximum number of returns to list. Range - 1-100. Default is 10.
     * @param {string} [endingBefore] The ID of the order created after the last order you want to retrieve a return from.
     * @param {string} [startingAfter] The ID of the order created before the first order you want to retrieve a return from.
     * @param {Array<string>} [tokens] Filters the list for orders related to the specified order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderReturnApi
     */
    public listOrderReturn(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, limit?: string, endingBefore?: string, startingAfter?: string, tokens?: Array<string>, options?: RawAxiosRequestConfig) {
        return OrderReturnApiFp(this.configuration).listOrderReturn(accessKey, contentType, salt, signature, timestamp, idempotency, limit, endingBefore, startingAfter, tokens, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a return.
     * @summary Retrieve a Return
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} orderReturnsId ID of the return. String starting with **orre_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderReturnApi
     */
    public retrieveOrderReturn(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderReturnsId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return OrderReturnApiFp(this.configuration).retrieveOrderReturn(accessKey, contentType, salt, signature, timestamp, orderReturnsId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a return against an order. The maximum amount of the return is the amount of the order
     * @summary Create a Return Against an Order
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} orderId ID of the order. String starting with order_.
     * @param {OrderIdReturnsBody} orderIdReturnsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderReturnApi
     */
    public returnsOrder(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, orderId: string, orderIdReturnsBody: OrderIdReturnsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return OrderReturnApiFp(this.configuration).returnsOrder(accessKey, contentType, salt, signature, timestamp, orderId, orderIdReturnsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a payment where the status of the payment is ACT. Relevant to payment methods where is_cancelable = true in the response to List Payment Methods by Country. This method triggers the Payment Canceled webhook. This webhook contains the same information as the response. NOTE: If the status is CLO, use the Create Refund method.
         * @summary Cancel Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with payment_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('cancelPayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('cancelPayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('cancelPayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('cancelPayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cancelPayment', 'timestamp', timestamp)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('cancelPayment', 'paymentId', paymentId)
            const localVarPath = `/v1/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture some or all of a card payment that was previously authorized with `capture` set to **false**.<BR>This method changes the `payment` object status to **CLO** and triggers \'Payment Captured Webhook\'. This webhook contains the same information as the response. This method also triggers \'Payment Completed Webhook\'. The capture operation is also known as clearing or completion.<BR>The scope of the capture operation depends on the client\'s pre-authorization permissions. To change these permissions, contact Rapyd Client Support.
         * @summary Capture Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with **payment_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {PaymentIdCaptureBody} [paymentIdCaptureBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, paymentIdCaptureBody?: PaymentIdCaptureBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('capturePayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('capturePayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('capturePayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('capturePayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('capturePayment', 'timestamp', timestamp)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('capturePayment', 'paymentId', paymentId)
            const localVarPath = `/v1/payments/{paymentId}/capture`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIdCaptureBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To simulate the completion of a payment by the action of a third party, use this method in the sandbox.<BR> This method changes the payment status to **CLO** (closed), and applies to the **cash**, **bank_redirect**, **bank_transfer**, or **ewallet** payment method types.<BR> This method also returns the \'Payment Completed\' Webhook. This webhook contains the same information as the response.<BR> For a card payment:<BR> * Capture after authorization only - Use \'Capture Payment\'.<BR> * Simulate 3-D Secure (3DS) verification - See Simulating 3DS Authentication.<BR> **Prerequisites**:<BR> * Create Payment
         * @summary Complete Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {PaymentsCompletePaymentBody} [paymentsCompletePaymentBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, paymentsCompletePaymentBody?: PaymentsCompletePaymentBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('completePayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('completePayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('completePayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('completePayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('completePayment', 'timestamp', timestamp)
            const localVarPath = `/v1/payments/completePayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsCompletePaymentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a payment
         * @summary Create Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PaymentsBody} v1PaymentsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PaymentsBody: V1PaymentsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createPayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createPayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createPayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createPayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPayment', 'timestamp', timestamp)
            // verify required parameter 'v1PaymentsBody' is not null or undefined
            assertParamExists('createPayment', 'v1PaymentsBody', v1PaymentsBody)
            const localVarPath = `/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1PaymentsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all payments that you have created. Filter the list with query parameters.
         * @summary List Payments
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [createdAfter] The ID of the payment created before the first payment you want to retrieve. String starting with **payment_**.
         * @param {string} [createdBefore] The ID of the payment created after the last payment you want to retrieve. String starting with **payment_**.
         * @param {Customer} [customer] Filters the list for payments related to the specified customer.
         * @param {string} [destinationCard] Filters the list for payments related to the specified destination card.
         * @param {string} [endingBefore] The ID of the payment created after the last payment you want to retrieve. String starting with payment_. Deprecated.
         * @param {string} [ewallet] Filters the list for payments related to the specified wallet.
         * @param {boolean} [group] When true, includes only group payments in the response. When false, excludes group payments from the response. Default is false.
         * @param {string} [invoice] Filters according to the invoice. String starting with invoice_.
         * @param {string} [limit] The maximum number of payments to return. Range, 1-100. Default is 10.
         * @param {string} [paymentMethod] Filters the list for payments related to the specified payment method.
         * @param {string} [order] Filters the list for payments related to the specified order.
         * @param {string} [startingAfter] The ID of a payment in the list. The list begins with the payment that was created next after the payment with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting with payment_.
         * @param {string} [subscription] Filters the list for payments related to the specified subscription.
         * @param {string} [merchantReferenceId] Merchant-defined ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, createdAfter?: string, createdBefore?: string, customer?: Customer, destinationCard?: string, endingBefore?: string, ewallet?: string, group?: boolean, invoice?: string, limit?: string, paymentMethod?: string, order?: string, startingAfter?: string, subscription?: string, merchantReferenceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listPayments', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listPayments', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listPayments', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listPayments', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listPayments', 'timestamp', timestamp)
            const localVarPath = `/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (customer !== undefined) {
                for (const [key, value] of Object.entries(customer)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (destinationCard !== undefined) {
                localVarQueryParameter['destination_card'] = destinationCard;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (ewallet !== undefined) {
                localVarQueryParameter['ewallet'] = ewallet;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (invoice !== undefined) {
                localVarQueryParameter['invoice'] = invoice;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (paymentMethod !== undefined) {
                localVarQueryParameter['payment_method'] = paymentMethod;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (subscription !== undefined) {
                localVarQueryParameter['subscription'] = subscription;
            }

            if (merchantReferenceId !== undefined) {
                localVarQueryParameter['merchant_reference_id'] = merchantReferenceId;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a payment
         * @summary Retrieve Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with **payment_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrievePayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrievePayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrievePayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrievePayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrievePayment', 'timestamp', timestamp)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('retrievePayment', 'paymentId', paymentId)
            const localVarPath = `/v1/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a payment when the status of the payment is ACT (active). You can update additional fields if they are listed under payment_options in the response from Get Payment Method Required Fields and is_updateable is set to true
         * @summary Update Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with payment_.
         * @param {PaymentsPaymentIdBody} paymentsPaymentIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, paymentsPaymentIdBody: PaymentsPaymentIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updatePayment', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updatePayment', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updatePayment', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updatePayment', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updatePayment', 'timestamp', timestamp)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('updatePayment', 'paymentId', paymentId)
            // verify required parameter 'paymentsPaymentIdBody' is not null or undefined
            assertParamExists('updatePayment', 'paymentsPaymentIdBody', paymentsPaymentIdBody)
            const localVarPath = `/v1/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsPaymentIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a payment where the status of the payment is ACT. Relevant to payment methods where is_cancelable = true in the response to List Payment Methods by Country. This method triggers the Payment Canceled webhook. This webhook contains the same information as the response. NOTE: If the status is CLO, use the Create Refund method.
         * @summary Cancel Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with payment_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.cancelPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Capture some or all of a card payment that was previously authorized with `capture` set to **false**.<BR>This method changes the `payment` object status to **CLO** and triggers \'Payment Captured Webhook\'. This webhook contains the same information as the response. This method also triggers \'Payment Completed Webhook\'. The capture operation is also known as clearing or completion.<BR>The scope of the capture operation depends on the client\'s pre-authorization permissions. To change these permissions, contact Rapyd Client Support.
         * @summary Capture Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with **payment_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {PaymentIdCaptureBody} [paymentIdCaptureBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, paymentIdCaptureBody?: PaymentIdCaptureBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturePayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, paymentIdCaptureBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.capturePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To simulate the completion of a payment by the action of a third party, use this method in the sandbox.<BR> This method changes the payment status to **CLO** (closed), and applies to the **cash**, **bank_redirect**, **bank_transfer**, or **ewallet** payment method types.<BR> This method also returns the \'Payment Completed\' Webhook. This webhook contains the same information as the response.<BR> For a card payment:<BR> * Capture after authorization only - Use \'Capture Payment\'.<BR> * Simulate 3-D Secure (3DS) verification - See Simulating 3DS Authentication.<BR> **Prerequisites**:<BR> * Create Payment
         * @summary Complete Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {PaymentsCompletePaymentBody} [paymentsCompletePaymentBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, paymentsCompletePaymentBody?: PaymentsCompletePaymentBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completePayment(accessKey, contentType, salt, signature, timestamp, idempotency, paymentsCompletePaymentBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.completePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a payment
         * @summary Create Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PaymentsBody} v1PaymentsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PaymentsBody: V1PaymentsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(accessKey, contentType, salt, signature, timestamp, v1PaymentsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.createPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all payments that you have created. Filter the list with query parameters.
         * @summary List Payments
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [createdAfter] The ID of the payment created before the first payment you want to retrieve. String starting with **payment_**.
         * @param {string} [createdBefore] The ID of the payment created after the last payment you want to retrieve. String starting with **payment_**.
         * @param {Customer} [customer] Filters the list for payments related to the specified customer.
         * @param {string} [destinationCard] Filters the list for payments related to the specified destination card.
         * @param {string} [endingBefore] The ID of the payment created after the last payment you want to retrieve. String starting with payment_. Deprecated.
         * @param {string} [ewallet] Filters the list for payments related to the specified wallet.
         * @param {boolean} [group] When true, includes only group payments in the response. When false, excludes group payments from the response. Default is false.
         * @param {string} [invoice] Filters according to the invoice. String starting with invoice_.
         * @param {string} [limit] The maximum number of payments to return. Range, 1-100. Default is 10.
         * @param {string} [paymentMethod] Filters the list for payments related to the specified payment method.
         * @param {string} [order] Filters the list for payments related to the specified order.
         * @param {string} [startingAfter] The ID of a payment in the list. The list begins with the payment that was created next after the payment with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting with payment_.
         * @param {string} [subscription] Filters the list for payments related to the specified subscription.
         * @param {string} [merchantReferenceId] Merchant-defined ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayments(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, createdAfter?: string, createdBefore?: string, customer?: Customer, destinationCard?: string, endingBefore?: string, ewallet?: string, group?: boolean, invoice?: string, limit?: string, paymentMethod?: string, order?: string, startingAfter?: string, subscription?: string, merchantReferenceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(accessKey, contentType, salt, signature, timestamp, idempotency, createdAfter, createdBefore, customer, destinationCard, endingBefore, ewallet, group, invoice, limit, paymentMethod, order, startingAfter, subscription, merchantReferenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.listPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a payment
         * @summary Retrieve Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with **payment_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.retrievePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a payment when the status of the payment is ACT (active). You can update additional fields if they are listed under payment_options in the response from Get Payment Method Required Fields and is_updateable is set to true
         * @summary Update Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with payment_.
         * @param {PaymentsPaymentIdBody} paymentsPaymentIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, paymentsPaymentIdBody: PaymentsPaymentIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(accessKey, contentType, salt, signature, timestamp, paymentId, paymentsPaymentIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.updatePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * Cancel a payment where the status of the payment is ACT. Relevant to payment methods where is_cancelable = true in the response to List Payment Methods by Country. This method triggers the Payment Canceled webhook. This webhook contains the same information as the response. NOTE: If the status is CLO, use the Create Refund method.
         * @summary Cancel Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with payment_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2003> {
            return localVarFp.cancelPayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Capture some or all of a card payment that was previously authorized with `capture` set to **false**.<BR>This method changes the `payment` object status to **CLO** and triggers \'Payment Captured Webhook\'. This webhook contains the same information as the response. This method also triggers \'Payment Completed Webhook\'. The capture operation is also known as clearing or completion.<BR>The scope of the capture operation depends on the client\'s pre-authorization permissions. To change these permissions, contact Rapyd Client Support.
         * @summary Capture Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with **payment_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {PaymentIdCaptureBody} [paymentIdCaptureBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, paymentIdCaptureBody?: PaymentIdCaptureBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2003> {
            return localVarFp.capturePayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, paymentIdCaptureBody, options).then((request) => request(axios, basePath));
        },
        /**
         * To simulate the completion of a payment by the action of a third party, use this method in the sandbox.<BR> This method changes the payment status to **CLO** (closed), and applies to the **cash**, **bank_redirect**, **bank_transfer**, or **ewallet** payment method types.<BR> This method also returns the \'Payment Completed\' Webhook. This webhook contains the same information as the response.<BR> For a card payment:<BR> * Capture after authorization only - Use \'Capture Payment\'.<BR> * Simulate 3-D Secure (3DS) verification - See Simulating 3DS Authentication.<BR> **Prerequisites**:<BR> * Create Payment
         * @summary Complete Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {PaymentsCompletePaymentBody} [paymentsCompletePaymentBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, paymentsCompletePaymentBody?: PaymentsCompletePaymentBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2003> {
            return localVarFp.completePayment(accessKey, contentType, salt, signature, timestamp, idempotency, paymentsCompletePaymentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a payment
         * @summary Create Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PaymentsBody} v1PaymentsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PaymentsBody: V1PaymentsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2003> {
            return localVarFp.createPayment(accessKey, contentType, salt, signature, timestamp, v1PaymentsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all payments that you have created. Filter the list with query parameters.
         * @summary List Payments
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [createdAfter] The ID of the payment created before the first payment you want to retrieve. String starting with **payment_**.
         * @param {string} [createdBefore] The ID of the payment created after the last payment you want to retrieve. String starting with **payment_**.
         * @param {Customer} [customer] Filters the list for payments related to the specified customer.
         * @param {string} [destinationCard] Filters the list for payments related to the specified destination card.
         * @param {string} [endingBefore] The ID of the payment created after the last payment you want to retrieve. String starting with payment_. Deprecated.
         * @param {string} [ewallet] Filters the list for payments related to the specified wallet.
         * @param {boolean} [group] When true, includes only group payments in the response. When false, excludes group payments from the response. Default is false.
         * @param {string} [invoice] Filters according to the invoice. String starting with invoice_.
         * @param {string} [limit] The maximum number of payments to return. Range, 1-100. Default is 10.
         * @param {string} [paymentMethod] Filters the list for payments related to the specified payment method.
         * @param {string} [order] Filters the list for payments related to the specified order.
         * @param {string} [startingAfter] The ID of a payment in the list. The list begins with the payment that was created next after the payment with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting with payment_.
         * @param {string} [subscription] Filters the list for payments related to the specified subscription.
         * @param {string} [merchantReferenceId] Merchant-defined ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, createdAfter?: string, createdBefore?: string, customer?: Customer, destinationCard?: string, endingBefore?: string, ewallet?: string, group?: boolean, invoice?: string, limit?: string, paymentMethod?: string, order?: string, startingAfter?: string, subscription?: string, merchantReferenceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2002> {
            return localVarFp.listPayments(accessKey, contentType, salt, signature, timestamp, idempotency, createdAfter, createdBefore, customer, destinationCard, endingBefore, ewallet, group, invoice, limit, paymentMethod, order, startingAfter, subscription, merchantReferenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a payment
         * @summary Retrieve Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with **payment_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2003> {
            return localVarFp.retrievePayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a payment when the status of the payment is ACT (active). You can update additional fields if they are listed under payment_options in the response from Get Payment Method Required Fields and is_updateable is set to true
         * @summary Update Payment
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentId ID of the payment. String starting with payment_.
         * @param {PaymentsPaymentIdBody} paymentsPaymentIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, paymentsPaymentIdBody: PaymentsPaymentIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2003> {
            return localVarFp.updatePayment(accessKey, contentType, salt, signature, timestamp, paymentId, paymentsPaymentIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * Cancel a payment where the status of the payment is ACT. Relevant to payment methods where is_cancelable = true in the response to List Payment Methods by Country. This method triggers the Payment Canceled webhook. This webhook contains the same information as the response. NOTE: If the status is CLO, use the Create Refund method.
     * @summary Cancel Payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} paymentId ID of the payment. String starting with payment_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelPayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture some or all of a card payment that was previously authorized with `capture` set to **false**.<BR>This method changes the `payment` object status to **CLO** and triggers \'Payment Captured Webhook\'. This webhook contains the same information as the response. This method also triggers \'Payment Completed Webhook\'. The capture operation is also known as clearing or completion.<BR>The scope of the capture operation depends on the client\'s pre-authorization permissions. To change these permissions, contact Rapyd Client Support.
     * @summary Capture Payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} paymentId ID of the payment. String starting with **payment_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {PaymentIdCaptureBody} [paymentIdCaptureBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public capturePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, paymentIdCaptureBody?: PaymentIdCaptureBody, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).capturePayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, paymentIdCaptureBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To simulate the completion of a payment by the action of a third party, use this method in the sandbox.<BR> This method changes the payment status to **CLO** (closed), and applies to the **cash**, **bank_redirect**, **bank_transfer**, or **ewallet** payment method types.<BR> This method also returns the \'Payment Completed\' Webhook. This webhook contains the same information as the response.<BR> For a card payment:<BR> * Capture after authorization only - Use \'Capture Payment\'.<BR> * Simulate 3-D Secure (3DS) verification - See Simulating 3DS Authentication.<BR> **Prerequisites**:<BR> * Create Payment
     * @summary Complete Payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {PaymentsCompletePaymentBody} [paymentsCompletePaymentBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public completePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, paymentsCompletePaymentBody?: PaymentsCompletePaymentBody, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).completePayment(accessKey, contentType, salt, signature, timestamp, idempotency, paymentsCompletePaymentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a payment
     * @summary Create Payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1PaymentsBody} v1PaymentsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createPayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PaymentsBody: V1PaymentsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createPayment(accessKey, contentType, salt, signature, timestamp, v1PaymentsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all payments that you have created. Filter the list with query parameters.
     * @summary List Payments
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [createdAfter] The ID of the payment created before the first payment you want to retrieve. String starting with **payment_**.
     * @param {string} [createdBefore] The ID of the payment created after the last payment you want to retrieve. String starting with **payment_**.
     * @param {Customer} [customer] Filters the list for payments related to the specified customer.
     * @param {string} [destinationCard] Filters the list for payments related to the specified destination card.
     * @param {string} [endingBefore] The ID of the payment created after the last payment you want to retrieve. String starting with payment_. Deprecated.
     * @param {string} [ewallet] Filters the list for payments related to the specified wallet.
     * @param {boolean} [group] When true, includes only group payments in the response. When false, excludes group payments from the response. Default is false.
     * @param {string} [invoice] Filters according to the invoice. String starting with invoice_.
     * @param {string} [limit] The maximum number of payments to return. Range, 1-100. Default is 10.
     * @param {string} [paymentMethod] Filters the list for payments related to the specified payment method.
     * @param {string} [order] Filters the list for payments related to the specified order.
     * @param {string} [startingAfter] The ID of a payment in the list. The list begins with the payment that was created next after the payment with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used. String starting with payment_.
     * @param {string} [subscription] Filters the list for payments related to the specified subscription.
     * @param {string} [merchantReferenceId] Merchant-defined ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public listPayments(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, createdAfter?: string, createdBefore?: string, customer?: Customer, destinationCard?: string, endingBefore?: string, ewallet?: string, group?: boolean, invoice?: string, limit?: string, paymentMethod?: string, order?: string, startingAfter?: string, subscription?: string, merchantReferenceId?: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).listPayments(accessKey, contentType, salt, signature, timestamp, idempotency, createdAfter, createdBefore, customer, destinationCard, endingBefore, ewallet, group, invoice, limit, paymentMethod, order, startingAfter, subscription, merchantReferenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a payment
     * @summary Retrieve Payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} paymentId ID of the payment. String starting with **payment_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public retrievePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).retrievePayment(accessKey, contentType, salt, signature, timestamp, paymentId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a payment when the status of the payment is ACT (active). You can update additional fields if they are listed under payment_options in the response from Get Payment Method Required Fields and is_updateable is set to true
     * @summary Update Payment
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} paymentId ID of the payment. String starting with payment_.
     * @param {PaymentsPaymentIdBody} paymentsPaymentIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public updatePayment(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentId: string, paymentsPaymentIdBody: PaymentsPaymentIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).updatePayment(accessKey, contentType, salt, signature, timestamp, paymentId, paymentsPaymentIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentAddressApi - axios parameter creator
 * @export
 */
export const PaymentAddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an address.
         * @summary Create address.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1AddressesBody} [v1AddressesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1AddressesBody?: V1AddressesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createAddress', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createAddress', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createAddress', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createAddress', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createAddress', 'timestamp', timestamp)
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1AddressesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an address that is linked to a customer or is not linked to any object.
         * @summary Remove an address by its ID.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddress: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteAddress', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteAddress', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteAddress', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteAddress', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAddress', 'timestamp', timestamp)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('deleteAddress', 'addressId', addressId)
            const localVarPath = `/v1/addresses{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an address.
         * @summary Get an address by its ID.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getAddress', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getAddress', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getAddress', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getAddress', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAddress', 'timestamp', timestamp)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddress', 'addressId', addressId)
            const localVarPath = `/v1/addresses{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify an address. To clear a field, set it to an empty string.
         * @summary Updates address.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {Address} address 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddress: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, address: Address, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateAddress', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateAddress', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateAddress', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateAddress', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateAddress', 'timestamp', timestamp)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('updateAddress', 'addressId', addressId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateAddress', 'address', address)
            const localVarPath = `/v1/addresses{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(address, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentAddressApi - functional programming interface
 * @export
 */
export const PaymentAddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentAddressApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an address.
         * @summary Create address.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1AddressesBody} [v1AddressesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1AddressesBody?: V1AddressesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(accessKey, contentType, salt, signature, timestamp, idempotency, v1AddressesBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentAddressApi.createAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an address that is linked to a customer or is not linked to any object.
         * @summary Remove an address by its ID.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(accessKey, contentType, salt, signature, timestamp, addressId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentAddressApi.deleteAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an address.
         * @summary Get an address by its ID.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(accessKey, contentType, salt, signature, timestamp, addressId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentAddressApi.getAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify an address. To clear a field, set it to an empty string.
         * @summary Updates address.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {Address} address 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, address: Address, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddress(accessKey, contentType, salt, signature, timestamp, addressId, address, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentAddressApi.updateAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentAddressApi - factory interface
 * @export
 */
export const PaymentAddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentAddressApiFp(configuration)
    return {
        /**
         * Create an address.
         * @summary Create address.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1AddressesBody} [v1AddressesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1AddressesBody?: V1AddressesBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20040> {
            return localVarFp.createAddress(accessKey, contentType, salt, signature, timestamp, idempotency, v1AddressesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an address that is linked to a customer or is not linked to any object.
         * @summary Remove an address by its ID.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20040> {
            return localVarFp.deleteAddress(accessKey, contentType, salt, signature, timestamp, addressId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an address.
         * @summary Get an address by its ID.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20040> {
            return localVarFp.getAddress(accessKey, contentType, salt, signature, timestamp, addressId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify an address. To clear a field, set it to an empty string.
         * @summary Updates address.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} addressId ID of the address object. String starting with **address_**.
         * @param {Address} address 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, address: Address, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20040> {
            return localVarFp.updateAddress(accessKey, contentType, salt, signature, timestamp, addressId, address, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentAddressApi - object-oriented interface
 * @export
 * @class PaymentAddressApi
 * @extends {BaseAPI}
 */
export class PaymentAddressApi extends BaseAPI {
    /**
     * Create an address.
     * @summary Create address.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {V1AddressesBody} [v1AddressesBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentAddressApi
     */
    public createAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1AddressesBody?: V1AddressesBody, options?: RawAxiosRequestConfig) {
        return PaymentAddressApiFp(this.configuration).createAddress(accessKey, contentType, salt, signature, timestamp, idempotency, v1AddressesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an address that is linked to a customer or is not linked to any object.
     * @summary Remove an address by its ID.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} addressId ID of the address object. String starting with **address_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentAddressApi
     */
    public deleteAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentAddressApiFp(this.configuration).deleteAddress(accessKey, contentType, salt, signature, timestamp, addressId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an address.
     * @summary Get an address by its ID.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} addressId ID of the address object. String starting with **address_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentAddressApi
     */
    public getAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentAddressApiFp(this.configuration).getAddress(accessKey, contentType, salt, signature, timestamp, addressId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify an address. To clear a field, set it to an empty string.
     * @summary Updates address.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} addressId ID of the address object. String starting with **address_**.
     * @param {Address} address 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentAddressApi
     */
    public updateAddress(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, addressId: string, address: Address, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentAddressApiFp(this.configuration).updateAddress(accessKey, contentType, salt, signature, timestamp, addressId, address, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentCardTokenApi - axios parameter creator
 * @export
 */
export const PaymentCardTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a hosted page for a customer to save card details and manage cards. Prerequisite: [Create Customer](https://docs.rapyd.net/en/create-customer.html).
         * @summary Create Card Token
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CollectCardBody} [collectCardBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardToken: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectCardBody?: CollectCardBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createCardToken', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createCardToken', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createCardToken', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createCardToken', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCardToken', 'timestamp', timestamp)
            const localVarPath = `/v1/hosted/collect/card/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectCardBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentCardTokenApi - functional programming interface
 * @export
 */
export const PaymentCardTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentCardTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a hosted page for a customer to save card details and manage cards. Prerequisite: [Create Customer](https://docs.rapyd.net/en/create-customer.html).
         * @summary Create Card Token
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CollectCardBody} [collectCardBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCardToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectCardBody?: CollectCardBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20085>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCardToken(accessKey, contentType, salt, signature, timestamp, idempotency, collectCardBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCardTokenApi.createCardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentCardTokenApi - factory interface
 * @export
 */
export const PaymentCardTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentCardTokenApiFp(configuration)
    return {
        /**
         * Create a hosted page for a customer to save card details and manage cards. Prerequisite: [Create Customer](https://docs.rapyd.net/en/create-customer.html).
         * @summary Create Card Token
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CollectCardBody} [collectCardBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectCardBody?: CollectCardBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20085> {
            return localVarFp.createCardToken(accessKey, contentType, salt, signature, timestamp, idempotency, collectCardBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentCardTokenApi - object-oriented interface
 * @export
 * @class PaymentCardTokenApi
 * @extends {BaseAPI}
 */
export class PaymentCardTokenApi extends BaseAPI {
    /**
     * Create a hosted page for a customer to save card details and manage cards. Prerequisite: [Create Customer](https://docs.rapyd.net/en/create-customer.html).
     * @summary Create Card Token
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {CollectCardBody} [collectCardBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentCardTokenApi
     */
    public createCardToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectCardBody?: CollectCardBody, options?: RawAxiosRequestConfig) {
        return PaymentCardTokenApiFp(this.configuration).createCardToken(accessKey, contentType, salt, signature, timestamp, idempotency, collectCardBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentLinkApi - axios parameter creator
 * @export
 */
export const PaymentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a reusable link for a hosted payment page. <BR> A customer can use the link and the hosted payment page multiple times. After providing required information, the customer is redirected seamlessly to a Rapyd Checkout page to complete the payment.You can create the link for everyone or for a specific customer. You can make the payment amount fixed, editable, or open.
         * @summary Create Payment Link
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CollectPaymentsBody} [collectPaymentsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLink: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectPaymentsBody?: CollectPaymentsBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createPaymentLink', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createPaymentLink', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createPaymentLink', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createPaymentLink', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPaymentLink', 'timestamp', timestamp)
            const localVarPath = `/v1/hosted/collect/payments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectPaymentsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a payment link.
         * @summary Gwt Payment Link
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentLink ID of the payment link. String starting with **hp_reuse_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentLink: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentLink: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('paymentLink', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('paymentLink', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('paymentLink', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('paymentLink', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('paymentLink', 'timestamp', timestamp)
            // verify required parameter 'paymentLink' is not null or undefined
            assertParamExists('paymentLink', 'paymentLink', paymentLink)
            const localVarPath = `/v1/hosted/collect/payments/{paymentLink}`
                .replace(`{${"paymentLink"}}`, encodeURIComponent(String(paymentLink)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentLinkApi - functional programming interface
 * @export
 */
export const PaymentLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a reusable link for a hosted payment page. <BR> A customer can use the link and the hosted payment page multiple times. After providing required information, the customer is redirected seamlessly to a Rapyd Checkout page to complete the payment.You can create the link for everyone or for a specific customer. You can make the payment amount fixed, editable, or open.
         * @summary Create Payment Link
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CollectPaymentsBody} [collectPaymentsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentLink(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectPaymentsBody?: CollectPaymentsBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentLink(accessKey, contentType, salt, signature, timestamp, idempotency, collectPaymentsBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentLinkApi.createPaymentLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a payment link.
         * @summary Gwt Payment Link
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentLink ID of the payment link. String starting with **hp_reuse_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentLink(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentLink: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentLink(accessKey, contentType, salt, signature, timestamp, paymentLink, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentLinkApi.paymentLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentLinkApi - factory interface
 * @export
 */
export const PaymentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentLinkApiFp(configuration)
    return {
        /**
         * Creates a reusable link for a hosted payment page. <BR> A customer can use the link and the hosted payment page multiple times. After providing required information, the customer is redirected seamlessly to a Rapyd Checkout page to complete the payment.You can create the link for everyone or for a specific customer. You can make the payment amount fixed, editable, or open.
         * @summary Create Payment Link
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CollectPaymentsBody} [collectPaymentsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLink(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectPaymentsBody?: CollectPaymentsBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20026> {
            return localVarFp.createPaymentLink(accessKey, contentType, salt, signature, timestamp, idempotency, collectPaymentsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a payment link.
         * @summary Gwt Payment Link
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} paymentLink ID of the payment link. String starting with **hp_reuse_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentLink(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentLink: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20026> {
            return localVarFp.paymentLink(accessKey, contentType, salt, signature, timestamp, paymentLink, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentLinkApi - object-oriented interface
 * @export
 * @class PaymentLinkApi
 * @extends {BaseAPI}
 */
export class PaymentLinkApi extends BaseAPI {
    /**
     * Creates a reusable link for a hosted payment page. <BR> A customer can use the link and the hosted payment page multiple times. After providing required information, the customer is redirected seamlessly to a Rapyd Checkout page to complete the payment.You can create the link for everyone or for a specific customer. You can make the payment amount fixed, editable, or open.
     * @summary Create Payment Link
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {CollectPaymentsBody} [collectPaymentsBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public createPaymentLink(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, collectPaymentsBody?: CollectPaymentsBody, options?: RawAxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).createPaymentLink(accessKey, contentType, salt, signature, timestamp, idempotency, collectPaymentsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a payment link.
     * @summary Gwt Payment Link
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} paymentLink ID of the payment link. String starting with **hp_reuse_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public paymentLink(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentLink: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).paymentLink(accessKey, contentType, salt, signature, timestamp, paymentLink, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentMethodTypeApi - axios parameter creator
 * @export
 */
export const PaymentMethodTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the required fields for a payment method. The fields are returned as a list of objects. The name of each field appears in the `name` field of the response.
         * @summary Get Payment Method Required Fields.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} pmtId Payment method type Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodTypeRequiredFields: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pmtId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getPaymentMethodTypeRequiredFields', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPaymentMethodTypeRequiredFields', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getPaymentMethodTypeRequiredFields', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getPaymentMethodTypeRequiredFields', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPaymentMethodTypeRequiredFields', 'timestamp', timestamp)
            // verify required parameter 'pmtId' is not null or undefined
            assertParamExists('getPaymentMethodTypeRequiredFields', 'pmtId', pmtId)
            const localVarPath = `/v1/payment_methods/{pmtId}/required_fields`
                .replace(`{${"pmtId"}}`, encodeURIComponent(String(pmtId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all payment methods available for a country. You can filter the results by specifying the `currency` query parameter
         * @summary List Payment Methods by Country.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} countryId Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsTypesByCountry: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, countryId: string, idempotency?: string, currency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getPaymentMethodsTypesByCountry', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPaymentMethodsTypesByCountry', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getPaymentMethodsTypesByCountry', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getPaymentMethodsTypesByCountry', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPaymentMethodsTypesByCountry', 'timestamp', timestamp)
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('getPaymentMethodsTypesByCountry', 'countryId', countryId)
            const localVarPath = `/v1/payment_methods/countries/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodTypeApi - functional programming interface
 * @export
 */
export const PaymentMethodTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentMethodTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the required fields for a payment method. The fields are returned as a list of objects. The name of each field appears in the `name` field of the response.
         * @summary Get Payment Method Required Fields.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} pmtId Payment method type Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodTypeRequiredFields(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodTypeRequiredFields(accessKey, contentType, salt, signature, timestamp, pmtId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentMethodTypeApi.getPaymentMethodTypeRequiredFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all payment methods available for a country. You can filter the results by specifying the `currency` query parameter
         * @summary List Payment Methods by Country.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} countryId Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodsTypesByCountry(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, countryId: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodsTypesByCountry(accessKey, contentType, salt, signature, timestamp, countryId, idempotency, currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentMethodTypeApi.getPaymentMethodsTypesByCountry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentMethodTypeApi - factory interface
 * @export
 */
export const PaymentMethodTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentMethodTypeApiFp(configuration)
    return {
        /**
         * Retrieve the required fields for a payment method. The fields are returned as a list of objects. The name of each field appears in the `name` field of the response.
         * @summary Get Payment Method Required Fields.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} pmtId Payment method type Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodTypeRequiredFields(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2001> {
            return localVarFp.getPaymentMethodTypeRequiredFields(accessKey, contentType, salt, signature, timestamp, pmtId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all payment methods available for a country. You can filter the results by specifying the `currency` query parameter
         * @summary List Payment Methods by Country.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} countryId Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsTypesByCountry(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, countryId: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200> {
            return localVarFp.getPaymentMethodsTypesByCountry(accessKey, contentType, salt, signature, timestamp, countryId, idempotency, currency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentMethodTypeApi - object-oriented interface
 * @export
 * @class PaymentMethodTypeApi
 * @extends {BaseAPI}
 */
export class PaymentMethodTypeApi extends BaseAPI {
    /**
     * Retrieve the required fields for a payment method. The fields are returned as a list of objects. The name of each field appears in the `name` field of the response.
     * @summary Get Payment Method Required Fields.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} pmtId Payment method type Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodTypeApi
     */
    public getPaymentMethodTypeRequiredFields(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, pmtId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return PaymentMethodTypeApiFp(this.configuration).getPaymentMethodTypeRequiredFields(accessKey, contentType, salt, signature, timestamp, pmtId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all payment methods available for a country. You can filter the results by specifying the `currency` query parameter
     * @summary List Payment Methods by Country.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} countryId Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [currency] currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodTypeApi
     */
    public getPaymentMethodsTypesByCountry(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, countryId: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig) {
        return PaymentMethodTypeApiFp(this.configuration).getPaymentMethodsTypesByCountry(accessKey, contentType, salt, signature, timestamp, countryId, idempotency, currency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RefundApi - axios parameter creator
 * @export
 */
export const RefundApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all refunds.
         * @summary List Refunds
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the refund created after the last refund you want to retrieve. String starting with refund_.
         * @param {string} [limit] The maximum number of refunds to return. Range, 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the refund created before the first refund you want to retrieve. String starting with **refund_**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allRefunds: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('allRefunds', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('allRefunds', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('allRefunds', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('allRefunds', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('allRefunds', 'timestamp', timestamp)
            const localVarPath = `/v1/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a refund object.
         * @summary Retrieve Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundByToken: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('refundByToken', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('refundByToken', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('refundByToken', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('refundByToken', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('refundByToken', 'timestamp', timestamp)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('refundByToken', 'refundId', refundId)
            const localVarPath = `/v1/refunds/{refundId}`
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a group payment when the status of the group payment is closed. The refund is credited against a specific group payment. The money is returned to the payment methods that were used for the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook for each payment method.
         * @summary Create Group Refund
         * @param {RefundsGroupPaymentsBody} refundsGroupPaymentsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment: async (refundsGroupPaymentsBody: RefundsGroupPaymentsBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundsGroupPaymentsBody' is not null or undefined
            assertParamExists('refundGroupPayment', 'refundsGroupPaymentsBody', refundsGroupPaymentsBody)
            const localVarPath = `/v1/refunds/group_payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundsGroupPaymentsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund of a payment. The refund is credited against a specific payment. The money is returned to the payment method that was used for the payment, and the currency is the same as what was used in the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook. This webhook contains the same information as the response.
         * @summary Create Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1RefundsBody} v1RefundsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTotalCreateRefund: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1RefundsBody: V1RefundsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('requestTotalCreateRefund', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('requestTotalCreateRefund', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('requestTotalCreateRefund', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('requestTotalCreateRefund', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('requestTotalCreateRefund', 'timestamp', timestamp)
            // verify required parameter 'v1RefundsBody' is not null or undefined
            assertParamExists('requestTotalCreateRefund', 'v1RefundsBody', v1RefundsBody)
            const localVarPath = `/v1/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1RefundsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulate the action of a third party that is required for completing the refund process. Relevant to sandbox. Use this method when a payment was made with a payment method such as cash, bank redirect or bank transfer, and the payment was completed by an action taken by the customer.
         * @summary Complete Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {RefundsCompleteBody} refundsCompleteBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCompleteRefund: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundsCompleteBody: RefundsCompleteBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateCompleteRefund', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateCompleteRefund', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateCompleteRefund', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateCompleteRefund', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateCompleteRefund', 'timestamp', timestamp)
            // verify required parameter 'refundsCompleteBody' is not null or undefined
            assertParamExists('simulateCompleteRefund', 'refundsCompleteBody', refundsCompleteBody)
            const localVarPath = `/v1/refunds/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundsCompleteBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify the metadata in a refund object.
         * @summary Update Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
         * @param {RefundsRefundIdBody} refundsRefundIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRefund: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, refundsRefundIdBody: RefundsRefundIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateRefund', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateRefund', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateRefund', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateRefund', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateRefund', 'timestamp', timestamp)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('updateRefund', 'refundId', refundId)
            // verify required parameter 'refundsRefundIdBody' is not null or undefined
            assertParamExists('updateRefund', 'refundsRefundIdBody', refundsRefundIdBody)
            const localVarPath = `/v1/refunds/{refundId}`
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundsRefundIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundApi - functional programming interface
 * @export
 */
export const RefundApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all refunds.
         * @summary List Refunds
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the refund created after the last refund you want to retrieve. String starting with refund_.
         * @param {string} [limit] The maximum number of refunds to return. Range, 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the refund created before the first refund you want to retrieve. String starting with **refund_**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allRefunds(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allRefunds(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundApi.allRefunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a refund object.
         * @summary Retrieve Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundByToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundByToken(accessKey, contentType, salt, signature, timestamp, refundId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundApi.refundByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refund a group payment when the status of the group payment is closed. The refund is credited against a specific group payment. The money is returned to the payment methods that were used for the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook for each payment method.
         * @summary Create Group Refund
         * @param {RefundsGroupPaymentsBody} refundsGroupPaymentsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundGroupPayment(refundsGroupPaymentsBody: RefundsGroupPaymentsBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundGroupPayment(refundsGroupPaymentsBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundApi.refundGroupPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refund of a payment. The refund is credited against a specific payment. The money is returned to the payment method that was used for the payment, and the currency is the same as what was used in the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook. This webhook contains the same information as the response.
         * @summary Create Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1RefundsBody} v1RefundsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTotalCreateRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1RefundsBody: V1RefundsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTotalCreateRefund(accessKey, contentType, salt, signature, timestamp, v1RefundsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundApi.requestTotalCreateRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simulate the action of a third party that is required for completing the refund process. Relevant to sandbox. Use this method when a payment was made with a payment method such as cash, bank redirect or bank transfer, and the payment was completed by an action taken by the customer.
         * @summary Complete Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {RefundsCompleteBody} refundsCompleteBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateCompleteRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundsCompleteBody: RefundsCompleteBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateCompleteRefund(accessKey, contentType, salt, signature, timestamp, refundsCompleteBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundApi.simulateCompleteRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify the metadata in a refund object.
         * @summary Update Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
         * @param {RefundsRefundIdBody} refundsRefundIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, refundsRefundIdBody: RefundsRefundIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRefund(accessKey, contentType, salt, signature, timestamp, refundId, refundsRefundIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundApi.updateRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RefundApi - factory interface
 * @export
 */
export const RefundApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundApiFp(configuration)
    return {
        /**
         * Retrieve a list of all refunds.
         * @summary List Refunds
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the refund created after the last refund you want to retrieve. String starting with refund_.
         * @param {string} [limit] The maximum number of refunds to return. Range, 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the refund created before the first refund you want to retrieve. String starting with **refund_**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allRefunds(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20030> {
            return localVarFp.allRefunds(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a refund object.
         * @summary Retrieve Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundByToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20031> {
            return localVarFp.refundByToken(accessKey, contentType, salt, signature, timestamp, refundId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a group payment when the status of the group payment is closed. The refund is credited against a specific group payment. The money is returned to the payment methods that were used for the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook for each payment method.
         * @summary Create Group Refund
         * @param {RefundsGroupPaymentsBody} refundsGroupPaymentsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment(refundsGroupPaymentsBody: RefundsGroupPaymentsBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20032> {
            return localVarFp.refundGroupPayment(refundsGroupPaymentsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund of a payment. The refund is credited against a specific payment. The money is returned to the payment method that was used for the payment, and the currency is the same as what was used in the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook. This webhook contains the same information as the response.
         * @summary Create Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1RefundsBody} v1RefundsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTotalCreateRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1RefundsBody: V1RefundsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20031> {
            return localVarFp.requestTotalCreateRefund(accessKey, contentType, salt, signature, timestamp, v1RefundsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulate the action of a third party that is required for completing the refund process. Relevant to sandbox. Use this method when a payment was made with a payment method such as cash, bank redirect or bank transfer, and the payment was completed by an action taken by the customer.
         * @summary Complete Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {RefundsCompleteBody} refundsCompleteBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateCompleteRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundsCompleteBody: RefundsCompleteBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20031> {
            return localVarFp.simulateCompleteRefund(accessKey, contentType, salt, signature, timestamp, refundsCompleteBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify the metadata in a refund object.
         * @summary Update Refund
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
         * @param {RefundsRefundIdBody} refundsRefundIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, refundsRefundIdBody: RefundsRefundIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20031> {
            return localVarFp.updateRefund(accessKey, contentType, salt, signature, timestamp, refundId, refundsRefundIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundApi - object-oriented interface
 * @export
 * @class RefundApi
 * @extends {BaseAPI}
 */
export class RefundApi extends BaseAPI {
    /**
     * Retrieve a list of all refunds.
     * @summary List Refunds
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [endingBefore] The ID of the refund created after the last refund you want to retrieve. String starting with refund_.
     * @param {string} [limit] The maximum number of refunds to return. Range, 1-100. Default is 10.
     * @param {string} [startingAfter] The ID of the refund created before the first refund you want to retrieve. String starting with **refund_**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public allRefunds(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig) {
        return RefundApiFp(this.configuration).allRefunds(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a refund object.
     * @summary Retrieve Refund
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public refundByToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return RefundApiFp(this.configuration).refundByToken(accessKey, contentType, salt, signature, timestamp, refundId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a group payment when the status of the group payment is closed. The refund is credited against a specific group payment. The money is returned to the payment methods that were used for the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook for each payment method.
     * @summary Create Group Refund
     * @param {RefundsGroupPaymentsBody} refundsGroupPaymentsBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public refundGroupPayment(refundsGroupPaymentsBody: RefundsGroupPaymentsBody, options?: RawAxiosRequestConfig) {
        return RefundApiFp(this.configuration).refundGroupPayment(refundsGroupPaymentsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund of a payment. The refund is credited against a specific payment. The money is returned to the payment method that was used for the payment, and the currency is the same as what was used in the payment. If the action of a third party is not required, this method triggers the Refund Completed webhook. This webhook contains the same information as the response.
     * @summary Create Refund
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1RefundsBody} v1RefundsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public requestTotalCreateRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1RefundsBody: V1RefundsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return RefundApiFp(this.configuration).requestTotalCreateRefund(accessKey, contentType, salt, signature, timestamp, v1RefundsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulate the action of a third party that is required for completing the refund process. Relevant to sandbox. Use this method when a payment was made with a payment method such as cash, bank redirect or bank transfer, and the payment was completed by an action taken by the customer.
     * @summary Complete Refund
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {RefundsCompleteBody} refundsCompleteBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public simulateCompleteRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundsCompleteBody: RefundsCompleteBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return RefundApiFp(this.configuration).simulateCompleteRefund(accessKey, contentType, salt, signature, timestamp, refundsCompleteBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify the metadata in a refund object.
     * @summary Update Refund
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} refundId ID of the \&#39;refund\&#39; object you want to retrieve. String starting with **refund_**.
     * @param {RefundsRefundIdBody} refundsRefundIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public updateRefund(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, refundId: string, refundsRefundIdBody: RefundsRefundIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return RefundApiFp(this.configuration).updateRefund(accessKey, contentType, salt, signature, timestamp, refundId, refundsRefundIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SKUApi - axios parameter creator
 * @export
 */
export const SKUApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an SKU and attach it to a product.
         * @summary Create SKU
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1SkusBody} [v1SkusBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSKU: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1SkusBody?: V1SkusBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createSKU', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createSKU', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createSKU', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createSKU', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSKU', 'timestamp', timestamp)
            const localVarPath = `/v1/skus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1SkusBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an SKU from the Rapyd platform.
         * @summary Delete SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSKU: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteSKU', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteSKU', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteSKU', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteSKU', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteSKU', 'timestamp', timestamp)
            // verify required parameter 'skuId' is not null or undefined
            assertParamExists('deleteSKU', 'skuId', skuId)
            const localVarPath = `/v1/skus/{skuId}`
                .replace(`{${"skuId"}}`, encodeURIComponent(String(skuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all SKUs.
         * @summary List SKUs.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {boolean} [active] Determines whether the query returns active SKUs or inactive SKUs. Default is true.
         * @param {number} [startingAfter] The ID of the SKU created before the first SKU you want to retrieve.
         * @param {number} [endingBefore] The ID of the SKU created after the last SKU you want to retrieve.
         * @param {number} [limit] The maximum number of SKUs to return. Range 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSKU: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, active?: boolean, startingAfter?: number, endingBefore?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listSKU', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listSKU', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listSKU', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listSKU', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listSKU', 'timestamp', timestamp)
            const localVarPath = `/v1/skus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of an SKU.
         * @summary Retrieve SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSKU: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveSKU', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveSKU', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveSKU', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveSKU', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveSKU', 'timestamp', timestamp)
            // verify required parameter 'skuId' is not null or undefined
            assertParamExists('retrieveSKU', 'skuId', skuId)
            const localVarPath = `/v1/skus/{skuId}`
                .replace(`{${"skuId"}}`, encodeURIComponent(String(skuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify an SKU.
         * @summary Update SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with sku_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {SkusSkuIdBody} [skusSkuIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSKU: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, skusSkuIdBody?: SkusSkuIdBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateSKU', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateSKU', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateSKU', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateSKU', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateSKU', 'timestamp', timestamp)
            // verify required parameter 'skuId' is not null or undefined
            assertParamExists('updateSKU', 'skuId', skuId)
            const localVarPath = `/v1/skus/{skuId}`
                .replace(`{${"skuId"}}`, encodeURIComponent(String(skuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skusSkuIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SKUApi - functional programming interface
 * @export
 */
export const SKUApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SKUApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an SKU and attach it to a product.
         * @summary Create SKU
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1SkusBody} [v1SkusBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1SkusBody?: V1SkusBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSKU(accessKey, contentType, salt, signature, timestamp, idempotency, v1SkusBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SKUApi.createSKU']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an SKU from the Rapyd platform.
         * @summary Delete SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SKUApi.deleteSKU']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all SKUs.
         * @summary List SKUs.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {boolean} [active] Determines whether the query returns active SKUs or inactive SKUs. Default is true.
         * @param {number} [startingAfter] The ID of the SKU created before the first SKU you want to retrieve.
         * @param {number} [endingBefore] The ID of the SKU created after the last SKU you want to retrieve.
         * @param {number} [limit] The maximum number of SKUs to return. Range 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, active?: boolean, startingAfter?: number, endingBefore?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSKU(accessKey, contentType, salt, signature, timestamp, idempotency, active, startingAfter, endingBefore, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SKUApi.listSKU']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of an SKU.
         * @summary Retrieve SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SKUApi.retrieveSKU']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify an SKU.
         * @summary Update SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with sku_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {SkusSkuIdBody} [skusSkuIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, skusSkuIdBody?: SkusSkuIdBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, skusSkuIdBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SKUApi.updateSKU']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SKUApi - factory interface
 * @export
 */
export const SKUApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SKUApiFp(configuration)
    return {
        /**
         * Create an SKU and attach it to a product.
         * @summary Create SKU
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1SkusBody} [v1SkusBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1SkusBody?: V1SkusBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20044> {
            return localVarFp.createSKU(accessKey, contentType, salt, signature, timestamp, idempotency, v1SkusBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an SKU from the Rapyd platform.
         * @summary Delete SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20023> {
            return localVarFp.deleteSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all SKUs.
         * @summary List SKUs.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {boolean} [active] Determines whether the query returns active SKUs or inactive SKUs. Default is true.
         * @param {number} [startingAfter] The ID of the SKU created before the first SKU you want to retrieve.
         * @param {number} [endingBefore] The ID of the SKU created after the last SKU you want to retrieve.
         * @param {number} [limit] The maximum number of SKUs to return. Range 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, active?: boolean, startingAfter?: number, endingBefore?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20045> {
            return localVarFp.listSKU(accessKey, contentType, salt, signature, timestamp, idempotency, active, startingAfter, endingBefore, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of an SKU.
         * @summary Retrieve SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20044> {
            return localVarFp.retrieveSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify an SKU.
         * @summary Update SKU.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with sku_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {SkusSkuIdBody} [skusSkuIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, skusSkuIdBody?: SkusSkuIdBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20044> {
            return localVarFp.updateSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, skusSkuIdBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SKUApi - object-oriented interface
 * @export
 * @class SKUApi
 * @extends {BaseAPI}
 */
export class SKUApi extends BaseAPI {
    /**
     * Create an SKU and attach it to a product.
     * @summary Create SKU
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {V1SkusBody} [v1SkusBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SKUApi
     */
    public createSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1SkusBody?: V1SkusBody, options?: RawAxiosRequestConfig) {
        return SKUApiFp(this.configuration).createSKU(accessKey, contentType, salt, signature, timestamp, idempotency, v1SkusBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an SKU from the Rapyd platform.
     * @summary Delete SKU.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SKUApi
     */
    public deleteSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SKUApiFp(this.configuration).deleteSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all SKUs.
     * @summary List SKUs.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {boolean} [active] Determines whether the query returns active SKUs or inactive SKUs. Default is true.
     * @param {number} [startingAfter] The ID of the SKU created before the first SKU you want to retrieve.
     * @param {number} [endingBefore] The ID of the SKU created after the last SKU you want to retrieve.
     * @param {number} [limit] The maximum number of SKUs to return. Range 1-100. Default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SKUApi
     */
    public listSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, active?: boolean, startingAfter?: number, endingBefore?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return SKUApiFp(this.configuration).listSKU(accessKey, contentType, salt, signature, timestamp, idempotency, active, startingAfter, endingBefore, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of an SKU.
     * @summary Retrieve SKU.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with **sku_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SKUApi
     */
    public retrieveSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SKUApiFp(this.configuration).retrieveSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify an SKU.
     * @summary Update SKU.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} skuId ID of the \&#39;sku\&#39; object. String starting with sku_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {SkusSkuIdBody} [skusSkuIdBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SKUApi
     */
    public updateSKU(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, skuId: string, idempotency?: string, skusSkuIdBody?: SkusSkuIdBody, options?: RawAxiosRequestConfig) {
        return SKUApiFp(this.configuration).updateSKU(accessKey, contentType, salt, signature, timestamp, skuId, idempotency, skusSkuIdBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a subscription.
         * @summary Cancel Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('cancelSubscription', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('cancelSubscription', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('cancelSubscription', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('cancelSubscription', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cancelSubscription', 'timestamp', timestamp)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/payments/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the subscription and create an invoice. This method is for testing purposes and runs only in the sandbox.
         * @summary Complete a Cycle
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSubscriptionCycle: async (subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('completeSubscriptionCycle', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/payments/subscriptions/{subscriptionId}/complete_cycle`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription for regular, automatic payments.
         * @summary Create Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PaymentsSubscriptionsBody} paymentsSubscriptionsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsSubscriptionsBody: PaymentsSubscriptionsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createSubscription', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createSubscription', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createSubscription', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createSubscription', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSubscription', 'timestamp', timestamp)
            // verify required parameter 'paymentsSubscriptionsBody' is not null or undefined
            assertParamExists('createSubscription', 'paymentsSubscriptionsBody', paymentsSubscriptionsBody)
            const localVarPath = `/v1/payments/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsSubscriptionsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription using a hosted page. Relevant to card payments.
         * @summary Create Subscription by Hosted Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CheckoutSubscriptionsBody} [checkoutSubscriptionsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionByHostedPage: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, checkoutSubscriptionsBody?: CheckoutSubscriptionsBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createSubscriptionByHostedPage', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createSubscriptionByHostedPage', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createSubscriptionByHostedPage', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createSubscriptionByHostedPage', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSubscriptionByHostedPage', 'timestamp', timestamp)
            const localVarPath = `/v1/checkout/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSubscriptionsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the discount that was assigned to a subscription. This method does not affect the coupon that the discount was derived from.
         * @summary Delete Discount from Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionDiscount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteSubscriptionDiscount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteSubscriptionDiscount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteSubscriptionDiscount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteSubscriptionDiscount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteSubscriptionDiscount', 'timestamp', timestamp)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteSubscriptionDiscount', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/payments/subscriptions/{subscriptionId}/discount`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a subscription.
         * @summary Retrieve Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getSubscription', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getSubscription', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getSubscription', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getSubscription', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getSubscription', 'timestamp', timestamp)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/payments/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a discount for a subscription.
         * @summary Retrieve a discount of subscription.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} discountId discount Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDiscountById: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getSubscriptionDiscountById', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getSubscriptionDiscountById', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getSubscriptionDiscountById', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getSubscriptionDiscountById', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getSubscriptionDiscountById', 'timestamp', timestamp)
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('getSubscriptionDiscountById', 'discountId', discountId)
            const localVarPath = `/v1/subscriptions/discount/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of subscriptions. You can filter the list with query parameters.
         * @summary List Subscriptions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [billing] Method of billing. One of the following, pay_automatically, send_invoice.
         * @param {string} [customer] ID of the customer. String starting with cus_
         * @param {string} [status] Status of the subscription. One of the following, active, canceled, trialing
         * @param {string} [product] ID of a \&#39;product\&#39; object. The product must have type set to service. String starting with product_. Filter for one product at a time.
         * @param {string} [startingAfter] The ID of a record in the list. The list begins with the record that was created next after the record with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used.
         * @param {string} [endingBefore] The ID of a record in the list. The list ends with the last record that was created before the record with this ID. Use this filter to get the previous page of results.
         * @param {string} [limit] The maximum number of subscriptions to return. Range, 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionList: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, billing?: string, customer?: string, status?: string, product?: string, startingAfter?: string, endingBefore?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getSubscriptionList', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getSubscriptionList', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getSubscriptionList', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getSubscriptionList', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getSubscriptionList', 'timestamp', timestamp)
            const localVarPath = `/v1/payments/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (billing !== undefined) {
                localVarQueryParameter['billing'] = billing;
            }

            if (customer !== undefined) {
                localVarQueryParameter['customer'] = customer;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End a subscription cycle, create an invoice and move the subscription to the next cycle. This method is for testing purposes and runs only in the sandbox.
         * @summary Start a New Cycle
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateStartNewCycle: async (subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('simulateStartNewCycle', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/payments/subscriptions/{subscriptionId}/start_new_cycle`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a subscription.
         * @summary Update Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {SubscriptionsSubscriptionIdBody} subscriptionsSubscriptionIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, subscriptionsSubscriptionIdBody: SubscriptionsSubscriptionIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateSubscription', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateSubscription', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateSubscription', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateSubscription', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateSubscription', 'timestamp', timestamp)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionId', subscriptionId)
            // verify required parameter 'subscriptionsSubscriptionIdBody' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionsSubscriptionIdBody', subscriptionsSubscriptionIdBody)
            const localVarPath = `/v1/payments/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionsSubscriptionIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a subscription.
         * @summary Cancel Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.cancelSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel the subscription and create an invoice. This method is for testing purposes and runs only in the sandbox.
         * @summary Complete a Cycle
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeSubscriptionCycle(subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeSubscriptionCycle(subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.completeSubscriptionCycle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a subscription for regular, automatic payments.
         * @summary Create Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PaymentsSubscriptionsBody} paymentsSubscriptionsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsSubscriptionsBody: PaymentsSubscriptionsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(accessKey, contentType, salt, signature, timestamp, paymentsSubscriptionsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.createSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a subscription using a hosted page. Relevant to card payments.
         * @summary Create Subscription by Hosted Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CheckoutSubscriptionsBody} [checkoutSubscriptionsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionByHostedPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, checkoutSubscriptionsBody?: CheckoutSubscriptionsBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionByHostedPage(accessKey, contentType, salt, signature, timestamp, idempotency, checkoutSubscriptionsBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.createSubscriptionByHostedPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the discount that was assigned to a subscription. This method does not affect the coupon that the discount was derived from.
         * @summary Delete Discount from Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionDiscount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriptionDiscount(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.deleteSubscriptionDiscount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a subscription.
         * @summary Retrieve Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.getSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a discount for a subscription.
         * @summary Retrieve a discount of subscription.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} discountId discount Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionDiscountById(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionDiscountById(accessKey, contentType, salt, signature, timestamp, discountId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.getSubscriptionDiscountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of subscriptions. You can filter the list with query parameters.
         * @summary List Subscriptions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [billing] Method of billing. One of the following, pay_automatically, send_invoice.
         * @param {string} [customer] ID of the customer. String starting with cus_
         * @param {string} [status] Status of the subscription. One of the following, active, canceled, trialing
         * @param {string} [product] ID of a \&#39;product\&#39; object. The product must have type set to service. String starting with product_. Filter for one product at a time.
         * @param {string} [startingAfter] The ID of a record in the list. The list begins with the record that was created next after the record with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used.
         * @param {string} [endingBefore] The ID of a record in the list. The list ends with the last record that was created before the record with this ID. Use this filter to get the previous page of results.
         * @param {string} [limit] The maximum number of subscriptions to return. Range, 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, billing?: string, customer?: string, status?: string, product?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionList(accessKey, contentType, salt, signature, timestamp, idempotency, billing, customer, status, product, startingAfter, endingBefore, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.getSubscriptionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End a subscription cycle, create an invoice and move the subscription to the next cycle. This method is for testing purposes and runs only in the sandbox.
         * @summary Start a New Cycle
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateStartNewCycle(subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateStartNewCycle(subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.simulateStartNewCycle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a subscription.
         * @summary Update Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {SubscriptionsSubscriptionIdBody} subscriptionsSubscriptionIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, subscriptionsSubscriptionIdBody: SubscriptionsSubscriptionIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, subscriptionsSubscriptionIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.updateSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * Cancel a subscription.
         * @summary Cancel Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2006> {
            return localVarFp.cancelSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel the subscription and create an invoice. This method is for testing purposes and runs only in the sandbox.
         * @summary Complete a Cycle
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSubscriptionCycle(subscriptionId: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2009> {
            return localVarFp.completeSubscriptionCycle(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription for regular, automatic payments.
         * @summary Create Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {PaymentsSubscriptionsBody} paymentsSubscriptionsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsSubscriptionsBody: PaymentsSubscriptionsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2006> {
            return localVarFp.createSubscription(accessKey, contentType, salt, signature, timestamp, paymentsSubscriptionsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription using a hosted page. Relevant to card payments.
         * @summary Create Subscription by Hosted Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {CheckoutSubscriptionsBody} [checkoutSubscriptionsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionByHostedPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, checkoutSubscriptionsBody?: CheckoutSubscriptionsBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2008> {
            return localVarFp.createSubscriptionByHostedPage(accessKey, contentType, salt, signature, timestamp, idempotency, checkoutSubscriptionsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the discount that was assigned to a subscription. This method does not affect the coupon that the discount was derived from.
         * @summary Delete Discount from Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionDiscount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2007> {
            return localVarFp.deleteSubscriptionDiscount(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a subscription.
         * @summary Retrieve Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2006> {
            return localVarFp.getSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a discount for a subscription.
         * @summary Retrieve a discount of subscription.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} discountId discount Id
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDiscountById(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20020> {
            return localVarFp.getSubscriptionDiscountById(accessKey, contentType, salt, signature, timestamp, discountId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of subscriptions. You can filter the list with query parameters.
         * @summary List Subscriptions
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [billing] Method of billing. One of the following, pay_automatically, send_invoice.
         * @param {string} [customer] ID of the customer. String starting with cus_
         * @param {string} [status] Status of the subscription. One of the following, active, canceled, trialing
         * @param {string} [product] ID of a \&#39;product\&#39; object. The product must have type set to service. String starting with product_. Filter for one product at a time.
         * @param {string} [startingAfter] The ID of a record in the list. The list begins with the record that was created next after the record with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used.
         * @param {string} [endingBefore] The ID of a record in the list. The list ends with the last record that was created before the record with this ID. Use this filter to get the previous page of results.
         * @param {string} [limit] The maximum number of subscriptions to return. Range, 1-100. Default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, billing?: string, customer?: string, status?: string, product?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2005> {
            return localVarFp.getSubscriptionList(accessKey, contentType, salt, signature, timestamp, idempotency, billing, customer, status, product, startingAfter, endingBefore, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * End a subscription cycle, create an invoice and move the subscription to the next cycle. This method is for testing purposes and runs only in the sandbox.
         * @summary Start a New Cycle
         * @param {string} subscriptionId ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateStartNewCycle(subscriptionId: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2009> {
            return localVarFp.simulateStartNewCycle(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a subscription.
         * @summary Update Subscription
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
         * @param {SubscriptionsSubscriptionIdBody} subscriptionsSubscriptionIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, subscriptionsSubscriptionIdBody: SubscriptionsSubscriptionIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse2006> {
            return localVarFp.updateSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, subscriptionsSubscriptionIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * Cancel a subscription.
     * @summary Cancel Subscription
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public cancelSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).cancelSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel the subscription and create an invoice. This method is for testing purposes and runs only in the sandbox.
     * @summary Complete a Cycle
     * @param {string} subscriptionId ID of the subscription. String starting with sub_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public completeSubscriptionCycle(subscriptionId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).completeSubscriptionCycle(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription for regular, automatic payments.
     * @summary Create Subscription
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {PaymentsSubscriptionsBody} paymentsSubscriptionsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, paymentsSubscriptionsBody: PaymentsSubscriptionsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscription(accessKey, contentType, salt, signature, timestamp, paymentsSubscriptionsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription using a hosted page. Relevant to card payments.
     * @summary Create Subscription by Hosted Page
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {CheckoutSubscriptionsBody} [checkoutSubscriptionsBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionByHostedPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, checkoutSubscriptionsBody?: CheckoutSubscriptionsBody, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscriptionByHostedPage(accessKey, contentType, salt, signature, timestamp, idempotency, checkoutSubscriptionsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the discount that was assigned to a subscription. This method does not affect the coupon that the discount was derived from.
     * @summary Delete Discount from Subscription
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public deleteSubscriptionDiscount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).deleteSubscriptionDiscount(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a subscription.
     * @summary Retrieve Subscription
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionId ID of the subscription. String starting with sub_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a discount for a subscription.
     * @summary Retrieve a discount of subscription.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} discountId discount Id
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionDiscountById(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, discountId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionDiscountById(accessKey, contentType, salt, signature, timestamp, discountId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of subscriptions. You can filter the list with query parameters.
     * @summary List Subscriptions
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [billing] Method of billing. One of the following, pay_automatically, send_invoice.
     * @param {string} [customer] ID of the customer. String starting with cus_
     * @param {string} [status] Status of the subscription. One of the following, active, canceled, trialing
     * @param {string} [product] ID of a \&#39;product\&#39; object. The product must have type set to service. String starting with product_. Filter for one product at a time.
     * @param {string} [startingAfter] The ID of a record in the list. The list begins with the record that was created next after the record with this ID. Use this filter to get the next page of results. Relevant when ending_before is not used.
     * @param {string} [endingBefore] The ID of a record in the list. The list ends with the last record that was created before the record with this ID. Use this filter to get the previous page of results.
     * @param {string} [limit] The maximum number of subscriptions to return. Range, 1-100. Default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, billing?: string, customer?: string, status?: string, product?: string, startingAfter?: string, endingBefore?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionList(accessKey, contentType, salt, signature, timestamp, idempotency, billing, customer, status, product, startingAfter, endingBefore, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End a subscription cycle, create an invoice and move the subscription to the next cycle. This method is for testing purposes and runs only in the sandbox.
     * @summary Start a New Cycle
     * @param {string} subscriptionId ID of the subscription. String starting with sub_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public simulateStartNewCycle(subscriptionId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).simulateStartNewCycle(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a subscription.
     * @summary Update Subscription
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionId ID of the subscription. String starting with **sub_**.
     * @param {SubscriptionsSubscriptionIdBody} subscriptionsSubscriptionIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateSubscription(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionId: string, subscriptionsSubscriptionIdBody: SubscriptionsSubscriptionIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updateSubscription(accessKey, contentType, salt, signature, timestamp, subscriptionId, subscriptionsSubscriptionIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionInvoiceApi - axios parameter creator
 * @export
 */
export const SubscriptionInvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an invoice to add a one-time charge to a subscription.<BR>After you create the invoice with this method, create invoice items and assign them to the invoice with Create Invoice Item. <BR> This method triggers the Invoice Created Webhook. This webhook contains the same information as the response. <BR> The following asynchronous webhook provides information about later changes to the Invoice object:Retrieve the basic data of an invoice, with individual invoice lines.<BR> * Invoice Payment Succeeded Webhook <BR>* Invoice Updated Webhook
         * @summary Create Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1InvoicesBody} [v1InvoicesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoicesBody?: V1InvoicesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createInvoice', 'timestamp', timestamp)
            const localVarPath = `/v1/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1InvoicesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an invoice. You can delete an invoice when status is draft.
         * @summary Delete invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to delete.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteInvoice', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('deleteInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize an invoice.Invoices are initially created with a draft status, and this is the only state in which an invoice can be finalized. When an invoice is ready to be paid, finalize it. This sets its status to open. Subscriptions automatically create draft invoices during each billing cycle, which are then automatically finalized. When an invoice is finalized, it can no longer be deleted and its final status can be one of the following - Paid Uncollectible* Void. An invoice can be finalized only one time.
         * @summary Finalize Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to pay.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('finalizeInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('finalizeInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('finalizeInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('finalizeInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('finalizeInvoice', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('finalizeInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}/finalize`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve invoice lines from an invoice. <BR>Invoice lines are subscription items or invoice items.
         * @summary Retrieve Invoice Lines from Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice. String starting with **invoice_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLines: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getInvoiceLines', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getInvoiceLines', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getInvoiceLines', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getInvoiceLines', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getInvoiceLines', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoiceLines', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}/lines`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve invoice lines from the upcoming invoice for a customer. <BR> If a customer has more than one subscription, this method retrieves the invoice lines of the invoice that is due first.<BR> This method is relevant to invoices that are automatically generated out of subscriptions.
         * @summary Retrieve Invoice Lines from Upcoming Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customer ID of the customer whose invoice you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLinesUpcomingInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getInvoiceLinesUpcomingInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getInvoiceLinesUpcomingInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getInvoiceLinesUpcomingInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getInvoiceLinesUpcomingInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getInvoiceLinesUpcomingInvoice', 'timestamp', timestamp)
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('getInvoiceLinesUpcomingInvoice', 'customer', customer)
            const localVarPath = `/v1/invoices/upcoming/lines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customer !== undefined) {
                localVarQueryParameter['customer'] = customer;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a preview of the basic data of the upcoming invoice for a customer, with individual invoice lines.<BR> To get the invoice lines of the invoice, use \'Retrieve Invoice Lines from Invoice\'.<BR> The response generated cannot be used to generate a payment authorization.
         * @summary Retrieve Upcoming Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customer ID of the customer whose invoice you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getUpcomingInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getUpcomingInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getUpcomingInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getUpcomingInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUpcomingInvoice', 'timestamp', timestamp)
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('getUpcomingInvoice', 'customer', customer)
            const localVarPath = `/v1/invoices/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customer !== undefined) {
                localVarQueryParameter['customer'] = customer;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary List Invoices
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {Customer} [customer] ID of the customer. String starting with **cus_**.
         * @param {string} [date] Date that the invoice was created.
         * @param {string} [dueDate] The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the days_until_due field. Format is in Unix time.
         * @param {string} [endingBefore] The ID of the invoice created after the last invoice you want to retrieve. card.
         * @param {string} [limit] The maximum number of invoices to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the invoice created before the first invoice you want to retrieve.
         * @param {string} [subscription] ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, customer?: Customer, date?: string, dueDate?: string, endingBefore?: string, limit?: string, startingAfter?: string, subscription?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listInvoices', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listInvoices', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listInvoices', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listInvoices', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listInvoices', 'timestamp', timestamp)
            const localVarPath = `/v1/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customer !== undefined) {
                for (const [key, value] of Object.entries(customer)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['due_date'] = dueDate;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (subscription !== undefined) {
                localVarQueryParameter['subscription'] = subscription;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an invoice to **uncollectible** status. <BR> This status indicates that the invoice cannot be paid by the customer.
         * @summary Mark Invoice Uncollectible
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to mark uncollectible. String starting with **invoice_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markInvoiceUncollectible: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('markInvoiceUncollectible', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('markInvoiceUncollectible', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('markInvoiceUncollectible', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('markInvoiceUncollectible', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('markInvoiceUncollectible', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('markInvoiceUncollectible', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}/mark_uncollectible`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a payment against an invoice.
         * @summary Pay invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to pay.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoiceIdPayBody} [invoiceIdPayBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoiceIdPayBody?: InvoiceIdPayBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('payInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('payInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('payInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('payInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('payInvoice', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('payInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}/pay`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceIdPayBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary Retrieve invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveInvoice', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('retrieveInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify an invoice. You can modify the invoice when its status is draft.
         * @summary Update invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to updated.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoicesInvoiceIdBody} [invoicesInvoiceIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoicesInvoiceIdBody?: InvoicesInvoiceIdBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateInvoice', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('updateInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoicesInvoiceIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an invoice to **void** status. <BR> Void invoices are similar to deleted invoices, but their records are kept for accounting purposes.Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary Void invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to void.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('voidInvoice', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('voidInvoice', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('voidInvoice', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('voidInvoice', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('voidInvoice', 'timestamp', timestamp)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('voidInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/v1/invoices/{invoiceId}/void`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionInvoiceApi - functional programming interface
 * @export
 */
export const SubscriptionInvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionInvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an invoice to add a one-time charge to a subscription.<BR>After you create the invoice with this method, create invoice items and assign them to the invoice with Create Invoice Item. <BR> This method triggers the Invoice Created Webhook. This webhook contains the same information as the response. <BR> The following asynchronous webhook provides information about later changes to the Invoice object:Retrieve the basic data of an invoice, with individual invoice lines.<BR> * Invoice Payment Succeeded Webhook <BR>* Invoice Updated Webhook
         * @summary Create Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1InvoicesBody} [v1InvoicesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoicesBody?: V1InvoicesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoice(accessKey, contentType, salt, signature, timestamp, idempotency, v1InvoicesBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.createInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an invoice. You can delete an invoice when status is draft.
         * @summary Delete invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to delete.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.deleteInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finalize an invoice.Invoices are initially created with a draft status, and this is the only state in which an invoice can be finalized. When an invoice is ready to be paid, finalize it. This sets its status to open. Subscriptions automatically create draft invoices during each billing cycle, which are then automatically finalized. When an invoice is finalized, it can no longer be deleted and its final status can be one of the following - Paid Uncollectible* Void. An invoice can be finalized only one time.
         * @summary Finalize Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to pay.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizeInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizeInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.finalizeInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve invoice lines from an invoice. <BR>Invoice lines are subscription items or invoice items.
         * @summary Retrieve Invoice Lines from Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice. String starting with **invoice_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceLines(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceLines(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.getInvoiceLines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve invoice lines from the upcoming invoice for a customer. <BR> If a customer has more than one subscription, this method retrieves the invoice lines of the invoice that is due first.<BR> This method is relevant to invoices that are automatically generated out of subscriptions.
         * @summary Retrieve Invoice Lines from Upcoming Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customer ID of the customer whose invoice you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceLinesUpcomingInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceLinesUpcomingInvoice(accessKey, contentType, salt, signature, timestamp, customer, idempotency, currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.getInvoiceLinesUpcomingInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a preview of the basic data of the upcoming invoice for a customer, with individual invoice lines.<BR> To get the invoice lines of the invoice, use \'Retrieve Invoice Lines from Invoice\'.<BR> The response generated cannot be used to generate a payment authorization.
         * @summary Retrieve Upcoming Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customer ID of the customer whose invoice you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpcomingInvoice(accessKey, contentType, salt, signature, timestamp, customer, idempotency, currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.getUpcomingInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary List Invoices
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {Customer} [customer] ID of the customer. String starting with **cus_**.
         * @param {string} [date] Date that the invoice was created.
         * @param {string} [dueDate] The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the days_until_due field. Format is in Unix time.
         * @param {string} [endingBefore] The ID of the invoice created after the last invoice you want to retrieve. card.
         * @param {string} [limit] The maximum number of invoices to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the invoice created before the first invoice you want to retrieve.
         * @param {string} [subscription] ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoices(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, customer?: Customer, date?: string, dueDate?: string, endingBefore?: string, limit?: string, startingAfter?: string, subscription?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoices(accessKey, contentType, salt, signature, timestamp, idempotency, customer, date, dueDate, endingBefore, limit, startingAfter, subscription, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.listInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set an invoice to **uncollectible** status. <BR> This status indicates that the invoice cannot be paid by the customer.
         * @summary Mark Invoice Uncollectible
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to mark uncollectible. String starting with **invoice_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markInvoiceUncollectible(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markInvoiceUncollectible(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.markInvoiceUncollectible']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Make a payment against an invoice.
         * @summary Pay invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to pay.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoiceIdPayBody} [invoiceIdPayBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoiceIdPayBody?: InvoiceIdPayBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, invoiceIdPayBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.payInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary Retrieve invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.retrieveInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify an invoice. You can modify the invoice when its status is draft.
         * @summary Update invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to updated.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoicesInvoiceIdBody} [invoicesInvoiceIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoicesInvoiceIdBody?: InvoicesInvoiceIdBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, invoicesInvoiceIdBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.updateInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set an invoice to **void** status. <BR> Void invoices are similar to deleted invoices, but their records are kept for accounting purposes.Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary Void invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to void.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceApi.voidInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionInvoiceApi - factory interface
 * @export
 */
export const SubscriptionInvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionInvoiceApiFp(configuration)
    return {
        /**
         * Create an invoice to add a one-time charge to a subscription.<BR>After you create the invoice with this method, create invoice items and assign them to the invoice with Create Invoice Item. <BR> This method triggers the Invoice Created Webhook. This webhook contains the same information as the response. <BR> The following asynchronous webhook provides information about later changes to the Invoice object:Retrieve the basic data of an invoice, with individual invoice lines.<BR> * Invoice Payment Succeeded Webhook <BR>* Invoice Updated Webhook
         * @summary Create Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1InvoicesBody} [v1InvoicesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoicesBody?: V1InvoicesBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20021> {
            return localVarFp.createInvoice(accessKey, contentType, salt, signature, timestamp, idempotency, v1InvoicesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an invoice. You can delete an invoice when status is draft.
         * @summary Delete invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to delete.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20023> {
            return localVarFp.deleteInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Finalize an invoice.Invoices are initially created with a draft status, and this is the only state in which an invoice can be finalized. When an invoice is ready to be paid, finalize it. This sets its status to open. Subscriptions automatically create draft invoices during each billing cycle, which are then automatically finalized. When an invoice is finalized, it can no longer be deleted and its final status can be one of the following - Paid Uncollectible* Void. An invoice can be finalized only one time.
         * @summary Finalize Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to pay.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.finalizeInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve invoice lines from an invoice. <BR>Invoice lines are subscription items or invoice items.
         * @summary Retrieve Invoice Lines from Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice. String starting with **invoice_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLines(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.getInvoiceLines(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve invoice lines from the upcoming invoice for a customer. <BR> If a customer has more than one subscription, this method retrieves the invoice lines of the invoice that is due first.<BR> This method is relevant to invoices that are automatically generated out of subscriptions.
         * @summary Retrieve Invoice Lines from Upcoming Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customer ID of the customer whose invoice you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLinesUpcomingInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.getInvoiceLinesUpcomingInvoice(accessKey, contentType, salt, signature, timestamp, customer, idempotency, currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a preview of the basic data of the upcoming invoice for a customer, with individual invoice lines.<BR> To get the invoice lines of the invoice, use \'Retrieve Invoice Lines from Invoice\'.<BR> The response generated cannot be used to generate a payment authorization.
         * @summary Retrieve Upcoming Invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} customer ID of the customer whose invoice you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.getUpcomingInvoice(accessKey, contentType, salt, signature, timestamp, customer, idempotency, currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary List Invoices
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {Customer} [customer] ID of the customer. String starting with **cus_**.
         * @param {string} [date] Date that the invoice was created.
         * @param {string} [dueDate] The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the days_until_due field. Format is in Unix time.
         * @param {string} [endingBefore] The ID of the invoice created after the last invoice you want to retrieve. card.
         * @param {string} [limit] The maximum number of invoices to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the invoice created before the first invoice you want to retrieve.
         * @param {string} [subscription] ID of the subscription. String starting with sub_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, customer?: Customer, date?: string, dueDate?: string, endingBefore?: string, limit?: string, startingAfter?: string, subscription?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20021> {
            return localVarFp.listInvoices(accessKey, contentType, salt, signature, timestamp, idempotency, customer, date, dueDate, endingBefore, limit, startingAfter, subscription, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an invoice to **uncollectible** status. <BR> This status indicates that the invoice cannot be paid by the customer.
         * @summary Mark Invoice Uncollectible
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to mark uncollectible. String starting with **invoice_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markInvoiceUncollectible(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.markInvoiceUncollectible(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a payment against an invoice.
         * @summary Pay invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId ID of the invoice you want to pay.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoiceIdPayBody} [invoiceIdPayBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoiceIdPayBody?: InvoiceIdPayBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.payInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, invoiceIdPayBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary Retrieve invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to retrieve.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.retrieveInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify an invoice. You can modify the invoice when its status is draft.
         * @summary Update invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to updated.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoicesInvoiceIdBody} [invoicesInvoiceIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoicesInvoiceIdBody?: InvoicesInvoiceIdBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.updateInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, invoicesInvoiceIdBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an invoice to **void** status. <BR> Void invoices are similar to deleted invoices, but their records are kept for accounting purposes.Retrieve the basic data of an invoice, with individual invoice lines.
         * @summary Void invoice
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} invoiceId The ID of the invoice that you want to void.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20022> {
            return localVarFp.voidInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionInvoiceApi - object-oriented interface
 * @export
 * @class SubscriptionInvoiceApi
 * @extends {BaseAPI}
 */
export class SubscriptionInvoiceApi extends BaseAPI {
    /**
     * Create an invoice to add a one-time charge to a subscription.<BR>After you create the invoice with this method, create invoice items and assign them to the invoice with Create Invoice Item. <BR> This method triggers the Invoice Created Webhook. This webhook contains the same information as the response. <BR> The following asynchronous webhook provides information about later changes to the Invoice object:Retrieve the basic data of an invoice, with individual invoice lines.<BR> * Invoice Payment Succeeded Webhook <BR>* Invoice Updated Webhook
     * @summary Create Invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {V1InvoicesBody} [v1InvoicesBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public createInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoicesBody?: V1InvoicesBody, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).createInvoice(accessKey, contentType, salt, signature, timestamp, idempotency, v1InvoicesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an invoice. You can delete an invoice when status is draft.
     * @summary Delete invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId The ID of the invoice that you want to delete.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public deleteInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).deleteInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finalize an invoice.Invoices are initially created with a draft status, and this is the only state in which an invoice can be finalized. When an invoice is ready to be paid, finalize it. This sets its status to open. Subscriptions automatically create draft invoices during each billing cycle, which are then automatically finalized. When an invoice is finalized, it can no longer be deleted and its final status can be one of the following - Paid Uncollectible* Void. An invoice can be finalized only one time.
     * @summary Finalize Invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId ID of the invoice you want to pay.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public finalizeInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).finalizeInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve invoice lines from an invoice. <BR>Invoice lines are subscription items or invoice items.
     * @summary Retrieve Invoice Lines from Invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId ID of the invoice. String starting with **invoice_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public getInvoiceLines(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).getInvoiceLines(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve invoice lines from the upcoming invoice for a customer. <BR> If a customer has more than one subscription, this method retrieves the invoice lines of the invoice that is due first.<BR> This method is relevant to invoices that are automatically generated out of subscriptions.
     * @summary Retrieve Invoice Lines from Upcoming Invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customer ID of the customer whose invoice you want to retrieve.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public getInvoiceLinesUpcomingInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).getInvoiceLinesUpcomingInvoice(accessKey, contentType, salt, signature, timestamp, customer, idempotency, currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a preview of the basic data of the upcoming invoice for a customer, with individual invoice lines.<BR> To get the invoice lines of the invoice, use \'Retrieve Invoice Lines from Invoice\'.<BR> The response generated cannot be used to generate a payment authorization.
     * @summary Retrieve Upcoming Invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} customer ID of the customer whose invoice you want to retrieve.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [currency] Three-letter ISO 4217 code for the currency. Required when the invoice is not linked to a specific subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public getUpcomingInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, customer: string, idempotency?: string, currency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).getUpcomingInvoice(accessKey, contentType, salt, signature, timestamp, customer, idempotency, currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the basic data of an invoice, with individual invoice lines.
     * @summary List Invoices
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {Customer} [customer] ID of the customer. String starting with **cus_**.
     * @param {string} [date] Date that the invoice was created.
     * @param {string} [dueDate] The date payment is due on this invoice. This value is calculated from the date the invoice is created, plus the number of days specified in the days_until_due field. Format is in Unix time.
     * @param {string} [endingBefore] The ID of the invoice created after the last invoice you want to retrieve. card.
     * @param {string} [limit] The maximum number of invoices to return. Range 1-100. Default is 10.
     * @param {string} [startingAfter] The ID of the invoice created before the first invoice you want to retrieve.
     * @param {string} [subscription] ID of the subscription. String starting with sub_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public listInvoices(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, customer?: Customer, date?: string, dueDate?: string, endingBefore?: string, limit?: string, startingAfter?: string, subscription?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).listInvoices(accessKey, contentType, salt, signature, timestamp, idempotency, customer, date, dueDate, endingBefore, limit, startingAfter, subscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an invoice to **uncollectible** status. <BR> This status indicates that the invoice cannot be paid by the customer.
     * @summary Mark Invoice Uncollectible
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId ID of the invoice you want to mark uncollectible. String starting with **invoice_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public markInvoiceUncollectible(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).markInvoiceUncollectible(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a payment against an invoice.
     * @summary Pay invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId ID of the invoice you want to pay.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {InvoiceIdPayBody} [invoiceIdPayBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public payInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoiceIdPayBody?: InvoiceIdPayBody, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).payInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, invoiceIdPayBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the basic data of an invoice, with individual invoice lines.
     * @summary Retrieve invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId The ID of the invoice that you want to retrieve.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public retrieveInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).retrieveInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify an invoice. You can modify the invoice when its status is draft.
     * @summary Update invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId The ID of the invoice that you want to updated.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {InvoicesInvoiceIdBody} [invoicesInvoiceIdBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public updateInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, invoicesInvoiceIdBody?: InvoicesInvoiceIdBody, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).updateInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, invoicesInvoiceIdBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an invoice to **void** status. <BR> Void invoices are similar to deleted invoices, but their records are kept for accounting purposes.Retrieve the basic data of an invoice, with individual invoice lines.
     * @summary Void invoice
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} invoiceId The ID of the invoice that you want to void.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceApi
     */
    public voidInvoice(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, invoiceId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceApiFp(this.configuration).voidInvoice(accessKey, contentType, salt, signature, timestamp, invoiceId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionInvoiceItemApi - axios parameter creator
 * @export
 */
export const SubscriptionInvoiceItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an invoice item and add it to an invoice or subscription.<BR>**Note**: If you create an invoice item without specifying the invoice ID or subscription ID, it is attached to the customer’s next invoice that has the same currency.<BR> This method triggers the following webhooks:<BR> * **Invoice Item Created** - This webhook contains the same information as the response. <BR>* Invoice Updated Webhook
         * @summary Create Invoice Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1InvoiceItemsBody} [v1InvoiceItemsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItem: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoiceItemsBody?: V1InvoiceItemsBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createInvoiceItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createInvoiceItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createInvoiceItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createInvoiceItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createInvoiceItem', 'timestamp', timestamp)
            const localVarPath = `/v1/invoice_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1InvoiceItemsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an invoice item from the upcoming invoice.<BR> Use this method in the following situations:<BR> * The invoice item is attached to an invoice.<BR> * The invoice item is not attached to an invoice.<BR> This method triggers the **Invoice Item Deleted webhook**. This webhook contains the same information as the response.Retrieve the details of an invoice item.
         * @summary Delete Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItem: async (invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItem' is not null or undefined
            assertParamExists('deleteInvoiceItem', 'invoiceItem', invoiceItem)
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteInvoiceItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteInvoiceItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteInvoiceItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteInvoiceItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteInvoiceItem', 'timestamp', timestamp)
            const localVarPath = `/v1/invoice_items/{invoiceItem}`
                .replace(`{${"invoiceItem"}}`, encodeURIComponent(String(invoiceItem)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of an invoice item.
         * @summary Retrieve Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItem: async (invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItem' is not null or undefined
            assertParamExists('getInvoiceItem', 'invoiceItem', invoiceItem)
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getInvoiceItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getInvoiceItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getInvoiceItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getInvoiceItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getInvoiceItem', 'timestamp', timestamp)
            const localVarPath = `/v1/invoice_items/{invoiceItem}`
                .replace(`{${"invoiceItem"}}`, encodeURIComponent(String(invoiceItem)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all invoice items. <BR> You can filter the list with query parameters.
         * @summary List Invoice Items
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [created] Date of creation of the invoice items.
         * @param {string} [customer] ID of the customer.
         * @param {string} [invoice] ID of the invoice.
         * @param {string} [limit] The maximum number of invoice items to return. Range: 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the invoice item created after the last invoice item you want to retrieve.
         * @param {string} [startingAfter] The ID of the invoice item created before the first invoice item you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoiceItems: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, created?: string, customer?: string, invoice?: string, limit?: string, endingBefore?: string, startingAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listInvoiceItems', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listInvoiceItems', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listInvoiceItems', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listInvoiceItems', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listInvoiceItems', 'timestamp', timestamp)
            const localVarPath = `/v1/invoice_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (customer !== undefined) {
                localVarQueryParameter['customer'] = customer;
            }

            if (invoice !== undefined) {
                localVarQueryParameter['invoice'] = invoice;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify an invoice item.<BR> You can update an invoice item at any time before the corresponding subscription generates an invoice.<BR> This method triggers the **Invoice Item Updated** webhook. This webhook contains the same information as the response.
         * @summary Update Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoiceItemsInvoiceItemBody} [invoiceItemsInvoiceItemBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceItem: async (invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, invoiceItemsInvoiceItemBody?: InvoiceItemsInvoiceItemBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItem' is not null or undefined
            assertParamExists('updateInvoiceItem', 'invoiceItem', invoiceItem)
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateInvoiceItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateInvoiceItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateInvoiceItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateInvoiceItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateInvoiceItem', 'timestamp', timestamp)
            const localVarPath = `/v1/invoice_items/{invoiceItem}`
                .replace(`{${"invoiceItem"}}`, encodeURIComponent(String(invoiceItem)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceItemsInvoiceItemBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionInvoiceItemApi - functional programming interface
 * @export
 */
export const SubscriptionInvoiceItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionInvoiceItemApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an invoice item and add it to an invoice or subscription.<BR>**Note**: If you create an invoice item without specifying the invoice ID or subscription ID, it is attached to the customer’s next invoice that has the same currency.<BR> This method triggers the following webhooks:<BR> * **Invoice Item Created** - This webhook contains the same information as the response. <BR>* Invoice Updated Webhook
         * @summary Create Invoice Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1InvoiceItemsBody} [v1InvoiceItemsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoiceItemsBody?: V1InvoiceItemsBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceItem(accessKey, contentType, salt, signature, timestamp, idempotency, v1InvoiceItemsBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceItemApi.createInvoiceItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an invoice item from the upcoming invoice.<BR> Use this method in the following situations:<BR> * The invoice item is attached to an invoice.<BR> * The invoice item is not attached to an invoice.<BR> This method triggers the **Invoice Item Deleted webhook**. This webhook contains the same information as the response.Retrieve the details of an invoice item.
         * @summary Delete Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceItemApi.deleteInvoiceItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of an invoice item.
         * @summary Retrieve Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceItemApi.getInvoiceItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all invoice items. <BR> You can filter the list with query parameters.
         * @summary List Invoice Items
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [created] Date of creation of the invoice items.
         * @param {string} [customer] ID of the customer.
         * @param {string} [invoice] ID of the invoice.
         * @param {string} [limit] The maximum number of invoice items to return. Range: 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the invoice item created after the last invoice item you want to retrieve.
         * @param {string} [startingAfter] The ID of the invoice item created before the first invoice item you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoiceItems(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, created?: string, customer?: string, invoice?: string, limit?: string, endingBefore?: string, startingAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoiceItems(accessKey, contentType, salt, signature, timestamp, idempotency, created, customer, invoice, limit, endingBefore, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceItemApi.listInvoiceItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify an invoice item.<BR> You can update an invoice item at any time before the corresponding subscription generates an invoice.<BR> This method triggers the **Invoice Item Updated** webhook. This webhook contains the same information as the response.
         * @summary Update Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoiceItemsInvoiceItemBody} [invoiceItemsInvoiceItemBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, invoiceItemsInvoiceItemBody?: InvoiceItemsInvoiceItemBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, invoiceItemsInvoiceItemBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionInvoiceItemApi.updateInvoiceItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionInvoiceItemApi - factory interface
 * @export
 */
export const SubscriptionInvoiceItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionInvoiceItemApiFp(configuration)
    return {
        /**
         * Create an invoice item and add it to an invoice or subscription.<BR>**Note**: If you create an invoice item without specifying the invoice ID or subscription ID, it is attached to the customer’s next invoice that has the same currency.<BR> This method triggers the following webhooks:<BR> * **Invoice Item Created** - This webhook contains the same information as the response. <BR>* Invoice Updated Webhook
         * @summary Create Invoice Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {V1InvoiceItemsBody} [v1InvoiceItemsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoiceItemsBody?: V1InvoiceItemsBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20024> {
            return localVarFp.createInvoiceItem(accessKey, contentType, salt, signature, timestamp, idempotency, v1InvoiceItemsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an invoice item from the upcoming invoice.<BR> Use this method in the following situations:<BR> * The invoice item is attached to an invoice.<BR> * The invoice item is not attached to an invoice.<BR> This method triggers the **Invoice Item Deleted webhook**. This webhook contains the same information as the response.Retrieve the details of an invoice item.
         * @summary Delete Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20025> {
            return localVarFp.deleteInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of an invoice item.
         * @summary Retrieve Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20024> {
            return localVarFp.getInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all invoice items. <BR> You can filter the list with query parameters.
         * @summary List Invoice Items
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [created] Date of creation of the invoice items.
         * @param {string} [customer] ID of the customer.
         * @param {string} [invoice] ID of the invoice.
         * @param {string} [limit] The maximum number of invoice items to return. Range: 1-100. Default is 10.
         * @param {string} [endingBefore] The ID of the invoice item created after the last invoice item you want to retrieve.
         * @param {string} [startingAfter] The ID of the invoice item created before the first invoice item you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoiceItems(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, created?: string, customer?: string, invoice?: string, limit?: string, endingBefore?: string, startingAfter?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20024> {
            return localVarFp.listInvoiceItems(accessKey, contentType, salt, signature, timestamp, idempotency, created, customer, invoice, limit, endingBefore, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify an invoice item.<BR> You can update an invoice item at any time before the corresponding subscription generates an invoice.<BR> This method triggers the **Invoice Item Updated** webhook. This webhook contains the same information as the response.
         * @summary Update Invoice Item
         * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {InvoiceItemsInvoiceItemBody} [invoiceItemsInvoiceItemBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, invoiceItemsInvoiceItemBody?: InvoiceItemsInvoiceItemBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20024> {
            return localVarFp.updateInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, invoiceItemsInvoiceItemBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionInvoiceItemApi - object-oriented interface
 * @export
 * @class SubscriptionInvoiceItemApi
 * @extends {BaseAPI}
 */
export class SubscriptionInvoiceItemApi extends BaseAPI {
    /**
     * Create an invoice item and add it to an invoice or subscription.<BR>**Note**: If you create an invoice item without specifying the invoice ID or subscription ID, it is attached to the customer’s next invoice that has the same currency.<BR> This method triggers the following webhooks:<BR> * **Invoice Item Created** - This webhook contains the same information as the response. <BR>* Invoice Updated Webhook
     * @summary Create Invoice Item
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {V1InvoiceItemsBody} [v1InvoiceItemsBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceItemApi
     */
    public createInvoiceItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, v1InvoiceItemsBody?: V1InvoiceItemsBody, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceItemApiFp(this.configuration).createInvoiceItem(accessKey, contentType, salt, signature, timestamp, idempotency, v1InvoiceItemsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an invoice item from the upcoming invoice.<BR> Use this method in the following situations:<BR> * The invoice item is attached to an invoice.<BR> * The invoice item is not attached to an invoice.<BR> This method triggers the **Invoice Item Deleted webhook**. This webhook contains the same information as the response.Retrieve the details of an invoice item.
     * @summary Delete Invoice Item
     * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceItemApi
     */
    public deleteInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceItemApiFp(this.configuration).deleteInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of an invoice item.
     * @summary Retrieve Invoice Item
     * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceItemApi
     */
    public getInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceItemApiFp(this.configuration).getInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all invoice items. <BR> You can filter the list with query parameters.
     * @summary List Invoice Items
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [created] Date of creation of the invoice items.
     * @param {string} [customer] ID of the customer.
     * @param {string} [invoice] ID of the invoice.
     * @param {string} [limit] The maximum number of invoice items to return. Range: 1-100. Default is 10.
     * @param {string} [endingBefore] The ID of the invoice item created after the last invoice item you want to retrieve.
     * @param {string} [startingAfter] The ID of the invoice item created before the first invoice item you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceItemApi
     */
    public listInvoiceItems(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, created?: string, customer?: string, invoice?: string, limit?: string, endingBefore?: string, startingAfter?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceItemApiFp(this.configuration).listInvoiceItems(accessKey, contentType, salt, signature, timestamp, idempotency, created, customer, invoice, limit, endingBefore, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify an invoice item.<BR> You can update an invoice item at any time before the corresponding subscription generates an invoice.<BR> This method triggers the **Invoice Item Updated** webhook. This webhook contains the same information as the response.
     * @summary Update Invoice Item
     * @param {string} invoiceItem Unique access key provided by Rapyd for each authorized user.
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {InvoiceItemsInvoiceItemBody} [invoiceItemsInvoiceItemBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionInvoiceItemApi
     */
    public updateInvoiceItem(invoiceItem: string, accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, invoiceItemsInvoiceItemBody?: InvoiceItemsInvoiceItemBody, options?: RawAxiosRequestConfig) {
        return SubscriptionInvoiceItemApiFp(this.configuration).updateInvoiceItem(invoiceItem, accessKey, contentType, salt, signature, timestamp, idempotency, invoiceItemsInvoiceItemBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionPlanApi - axios parameter creator
 * @export
 */
export const SubscriptionPlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a pricing plan for services.
         * @summary Create Plan Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PlansBody} v1PlansBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlan: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PlansBody: V1PlansBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createPlan', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createPlan', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createPlan', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createPlan', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPlan', 'timestamp', timestamp)
            // verify required parameter 'v1PlansBody' is not null or undefined
            assertParamExists('createPlan', 'v1PlansBody', v1PlansBody)
            const localVarPath = `/v1/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1PlansBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a pricing plan for services.
         * @summary Delete Plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deletePlan', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deletePlan', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deletePlan', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deletePlan', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deletePlan', 'timestamp', timestamp)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('deletePlan', 'planId', planId)
            const localVarPath = `/v1/plans/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all plans. Use the optional query parameters to filter the results. You can filter the results further by specifying one or more Plan fields as additional query parameters.
         * @summary List Plans
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the plan created after the last plan you want to retrieve.
         * @param {string} [limit] The maximum number of plans to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the plan created before the first plan you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlans: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listPlans', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listPlans', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listPlans', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listPlans', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listPlans', 'timestamp', timestamp)
            const localVarPath = `/v1/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a pricing plan for services.
         * @summary Retrieve plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePlan: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrievePlan', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrievePlan', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrievePlan', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrievePlan', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrievePlan', 'timestamp', timestamp)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('retrievePlan', 'planId', planId)
            const localVarPath = `/v1/plans/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a pricing plan for services. You can update a plan\'s nickname or metadata.
         * @summary Update Plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {PlansPlanIdBody} plansPlanIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, plansPlanIdBody: PlansPlanIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updatePlan', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updatePlan', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updatePlan', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updatePlan', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updatePlan', 'timestamp', timestamp)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('updatePlan', 'planId', planId)
            // verify required parameter 'plansPlanIdBody' is not null or undefined
            assertParamExists('updatePlan', 'plansPlanIdBody', plansPlanIdBody)
            const localVarPath = `/v1/plans/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plansPlanIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionPlanApi - functional programming interface
 * @export
 */
export const SubscriptionPlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionPlanApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a pricing plan for services.
         * @summary Create Plan Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PlansBody} v1PlansBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PlansBody: V1PlansBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlan(accessKey, contentType, salt, signature, timestamp, v1PlansBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionPlanApi.createPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a pricing plan for services.
         * @summary Delete Plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlan(accessKey, contentType, salt, signature, timestamp, planId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionPlanApi.deletePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all plans. Use the optional query parameters to filter the results. You can filter the results further by specifying one or more Plan fields as additional query parameters.
         * @summary List Plans
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the plan created after the last plan you want to retrieve.
         * @param {string} [limit] The maximum number of plans to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the plan created before the first plan you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlans(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlans(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionPlanApi.listPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a pricing plan for services.
         * @summary Retrieve plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePlan(accessKey, contentType, salt, signature, timestamp, planId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionPlanApi.retrievePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a pricing plan for services. You can update a plan\'s nickname or metadata.
         * @summary Update Plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {PlansPlanIdBody} plansPlanIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, plansPlanIdBody: PlansPlanIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlan(accessKey, contentType, salt, signature, timestamp, planId, plansPlanIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionPlanApi.updatePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionPlanApi - factory interface
 * @export
 */
export const SubscriptionPlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionPlanApiFp(configuration)
    return {
        /**
         * Create a pricing plan for services.
         * @summary Create Plan Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1PlansBody} v1PlansBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PlansBody: V1PlansBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20011> {
            return localVarFp.createPlan(accessKey, contentType, salt, signature, timestamp, v1PlansBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a pricing plan for services.
         * @summary Delete Plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20012> {
            return localVarFp.deletePlan(accessKey, contentType, salt, signature, timestamp, planId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all plans. Use the optional query parameters to filter the results. You can filter the results further by specifying one or more Plan fields as additional query parameters.
         * @summary List Plans
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the plan created after the last plan you want to retrieve.
         * @param {string} [limit] The maximum number of plans to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the plan created before the first plan you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlans(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20010> {
            return localVarFp.listPlans(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a pricing plan for services.
         * @summary Retrieve plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20011> {
            return localVarFp.retrievePlan(accessKey, contentType, salt, signature, timestamp, planId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a pricing plan for services. You can update a plan\'s nickname or metadata.
         * @summary Update Plan
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} planId ID of the plan.
         * @param {PlansPlanIdBody} plansPlanIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, plansPlanIdBody: PlansPlanIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20011> {
            return localVarFp.updatePlan(accessKey, contentType, salt, signature, timestamp, planId, plansPlanIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionPlanApi - object-oriented interface
 * @export
 * @class SubscriptionPlanApi
 * @extends {BaseAPI}
 */
export class SubscriptionPlanApi extends BaseAPI {
    /**
     * Create a pricing plan for services.
     * @summary Create Plan Item
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1PlansBody} v1PlansBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionPlanApi
     */
    public createPlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1PlansBody: V1PlansBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionPlanApiFp(this.configuration).createPlan(accessKey, contentType, salt, signature, timestamp, v1PlansBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a pricing plan for services.
     * @summary Delete Plan
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} planId ID of the plan.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionPlanApi
     */
    public deletePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionPlanApiFp(this.configuration).deletePlan(accessKey, contentType, salt, signature, timestamp, planId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all plans. Use the optional query parameters to filter the results. You can filter the results further by specifying one or more Plan fields as additional query parameters.
     * @summary List Plans
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [endingBefore] The ID of the plan created after the last plan you want to retrieve.
     * @param {string} [limit] The maximum number of plans to return. Range 1-100. Default is 10.
     * @param {string} [startingAfter] The ID of the plan created before the first plan you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionPlanApi
     */
    public listPlans(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionPlanApiFp(this.configuration).listPlans(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a pricing plan for services.
     * @summary Retrieve plan
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} planId ID of the plan.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionPlanApi
     */
    public retrievePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionPlanApiFp(this.configuration).retrievePlan(accessKey, contentType, salt, signature, timestamp, planId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a pricing plan for services. You can update a plan\'s nickname or metadata.
     * @summary Update Plan
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} planId ID of the plan.
     * @param {PlansPlanIdBody} plansPlanIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionPlanApi
     */
    public updatePlan(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, planId: string, plansPlanIdBody: PlansPlanIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionPlanApiFp(this.configuration).updatePlan(accessKey, contentType, salt, signature, timestamp, planId, plansPlanIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionProductApi - axios parameter creator
 * @export
 */
export const SubscriptionProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create goods or services.
         * @summary Create Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1ProductsBody} v1ProductsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1ProductsBody: V1ProductsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createProduct', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createProduct', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createProduct', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createProduct', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createProduct', 'timestamp', timestamp)
            // verify required parameter 'v1ProductsBody' is not null or undefined
            assertParamExists('createProduct', 'v1ProductsBody', v1ProductsBody)
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1ProductsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a product or service from the Rapyd platform. This action also deletes all associated plans.
         * @summary Delete Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteProduct', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteProduct', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteProduct', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteProduct', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteProduct', 'timestamp', timestamp)
            // verify required parameter 'productsId' is not null or undefined
            assertParamExists('deleteProduct', 'productsId', productsId)
            const localVarPath = `/v1/products/{productsId}`
                .replace(`{${"productsId"}}`, encodeURIComponent(String(productsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a product or service.
         * @summary Retrieve Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getProduct', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getProduct', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getProduct', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getProduct', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getProduct', 'timestamp', timestamp)
            // verify required parameter 'productsId' is not null or undefined
            assertParamExists('getProduct', 'productsId', productsId)
            const localVarPath = `/v1/products/{productsId}`
                .replace(`{${"productsId"}}`, encodeURIComponent(String(productsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all products.
         * @summary List Products
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the products created after the last product you want to retrieve.
         * @param {string} [limit] The maximum number of products to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the product created before the first products you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsList: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getProductsList', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getProductsList', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getProductsList', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getProductsList', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getProductsList', 'timestamp', timestamp)
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a product or service.
         * @summary Update Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {ProductsProductsIdBody} [productsProductsIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, productsProductsIdBody?: ProductsProductsIdBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateProduct', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateProduct', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateProduct', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateProduct', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateProduct', 'timestamp', timestamp)
            // verify required parameter 'productsId' is not null or undefined
            assertParamExists('updateProduct', 'productsId', productsId)
            const localVarPath = `/v1/products/{productsId}`
                .replace(`{${"productsId"}}`, encodeURIComponent(String(productsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productsProductsIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionProductApi - functional programming interface
 * @export
 */
export const SubscriptionProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Create goods or services.
         * @summary Create Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1ProductsBody} v1ProductsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1ProductsBody: V1ProductsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(accessKey, contentType, salt, signature, timestamp, v1ProductsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionProductApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a product or service from the Rapyd platform. This action also deletes all associated plans.
         * @summary Delete Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionProductApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a product or service.
         * @summary Retrieve Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionProductApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all products.
         * @summary List Products
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the products created after the last product you want to retrieve.
         * @param {string} [limit] The maximum number of products to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the product created before the first products you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsList(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionProductApi.getProductsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a product or service.
         * @summary Update Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {ProductsProductsIdBody} [productsProductsIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, productsProductsIdBody?: ProductsProductsIdBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, productsProductsIdBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionProductApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionProductApi - factory interface
 * @export
 */
export const SubscriptionProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionProductApiFp(configuration)
    return {
        /**
         * Create goods or services.
         * @summary Create Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1ProductsBody} v1ProductsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1ProductsBody: V1ProductsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20014> {
            return localVarFp.createProduct(accessKey, contentType, salt, signature, timestamp, v1ProductsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a product or service from the Rapyd platform. This action also deletes all associated plans.
         * @summary Delete Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20012> {
            return localVarFp.deleteProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a product or service.
         * @summary Retrieve Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20014> {
            return localVarFp.getProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all products.
         * @summary List Products
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {string} [endingBefore] The ID of the products created after the last product you want to retrieve.
         * @param {string} [limit] The maximum number of products to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the product created before the first products you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20013> {
            return localVarFp.getProductsList(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a product or service.
         * @summary Update Product
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} productsId ID of the product.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {ProductsProductsIdBody} [productsProductsIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, productsProductsIdBody?: ProductsProductsIdBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20014> {
            return localVarFp.updateProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, productsProductsIdBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionProductApi - object-oriented interface
 * @export
 * @class SubscriptionProductApi
 * @extends {BaseAPI}
 */
export class SubscriptionProductApi extends BaseAPI {
    /**
     * Create goods or services.
     * @summary Create Product
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1ProductsBody} v1ProductsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionProductApi
     */
    public createProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1ProductsBody: V1ProductsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionProductApiFp(this.configuration).createProduct(accessKey, contentType, salt, signature, timestamp, v1ProductsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a product or service from the Rapyd platform. This action also deletes all associated plans.
     * @summary Delete Product
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} productsId ID of the product.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionProductApi
     */
    public deleteProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionProductApiFp(this.configuration).deleteProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a product or service.
     * @summary Retrieve Product
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} productsId ID of the product.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionProductApi
     */
    public getProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionProductApiFp(this.configuration).getProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all products.
     * @summary List Products
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {string} [endingBefore] The ID of the products created after the last product you want to retrieve.
     * @param {string} [limit] The maximum number of products to return. Range 1-100. Default is 10.
     * @param {string} [startingAfter] The ID of the product created before the first products you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionProductApi
     */
    public getProductsList(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: string, limit?: string, startingAfter?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionProductApiFp(this.configuration).getProductsList(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a product or service.
     * @summary Update Product
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} productsId ID of the product.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {ProductsProductsIdBody} [productsProductsIdBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionProductApi
     */
    public updateProduct(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, productsId: string, idempotency?: string, productsProductsIdBody?: ProductsProductsIdBody, options?: RawAxiosRequestConfig) {
        return SubscriptionProductApiFp(this.configuration).updateProduct(accessKey, contentType, salt, signature, timestamp, productsId, idempotency, productsProductsIdBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionSubscriptionItemApi - axios parameter creator
 * @export
 */
export const SubscriptionSubscriptionItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a subscription item and add it to an existing subscription for recurring payment.
         * @summary Create Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1SubscriptionItemsBody} v1SubscriptionItemsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionItem: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1SubscriptionItemsBody: V1SubscriptionItemsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createSubscriptionItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createSubscriptionItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createSubscriptionItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createSubscriptionItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSubscriptionItem', 'timestamp', timestamp)
            // verify required parameter 'v1SubscriptionItemsBody' is not null or undefined
            assertParamExists('createSubscriptionItem', 'v1SubscriptionItemsBody', v1SubscriptionItemsBody)
            const localVarPath = `/v1/subscription_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1SubscriptionItemsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a usage record or update an existing usage record where its unique identifier is composed of timestamp and subscription_item
         * @summary Create Usage Record
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {SubscriptionItemIdUsageRecordsBody} subscriptionItemIdUsageRecordsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionItemUsageRecord: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemIdUsageRecordsBody: SubscriptionItemIdUsageRecordsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'timestamp', timestamp)
            // verify required parameter 'subscriptionItemId' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'subscriptionItemId', subscriptionItemId)
            // verify required parameter 'subscriptionItemIdUsageRecordsBody' is not null or undefined
            assertParamExists('createSubscriptionItemUsageRecord', 'subscriptionItemIdUsageRecordsBody', subscriptionItemIdUsageRecordsBody)
            const localVarPath = `/v1/subscription_items/{subscriptionItemId}/usage_records`
                .replace(`{${"subscriptionItemId"}}`, encodeURIComponent(String(subscriptionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionItemIdUsageRecordsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a subscription item from the Rapyd platform.
         * @summary Delete Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionItem: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('deleteSubscriptionItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteSubscriptionItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('deleteSubscriptionItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('deleteSubscriptionItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteSubscriptionItem', 'timestamp', timestamp)
            // verify required parameter 'subscriptionItemId' is not null or undefined
            assertParamExists('deleteSubscriptionItem', 'subscriptionItemId', subscriptionItemId)
            const localVarPath = `/v1/subscription_items/{subscriptionItemId}`
                .replace(`{${"subscriptionItemId"}}`, encodeURIComponent(String(subscriptionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all subscription items for a subscription.
         * @summary List Subscription Items
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [endingBefore] The ID of the subscription item created after the last subscription item you want to retrieve.
         * @param {number} [limit] The maximum number of subscription items to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the subscription item created before the first subscription item you want to retrieve.
         * @param {string} [subscription] ID of the subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionItem: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: number, limit?: number, startingAfter?: string, subscription?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('listSubscriptionItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('listSubscriptionItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('listSubscriptionItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('listSubscriptionItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('listSubscriptionItem', 'timestamp', timestamp)
            const localVarPath = `/v1/subscription_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (subscription !== undefined) {
                localVarQueryParameter['subscription'] = subscription;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a subscription item.
         * @summary Retrieve Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSubscriptionItem: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('retrieveSubscriptionItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('retrieveSubscriptionItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('retrieveSubscriptionItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('retrieveSubscriptionItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('retrieveSubscriptionItem', 'timestamp', timestamp)
            // verify required parameter 'subscriptionItemId' is not null or undefined
            assertParamExists('retrieveSubscriptionItem', 'subscriptionItemId', subscriptionItemId)
            const localVarPath = `/v1/subscription_items/{subscriptionItemId}`
                .replace(`{${"subscriptionItemId"}}`, encodeURIComponent(String(subscriptionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change or modify a subscription item.
         * @summary Update Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {SubscriptionItemsSubscriptionItemIdBody} subscriptionItemsSubscriptionItemIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionItem: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemsSubscriptionItemIdBody: SubscriptionItemsSubscriptionItemIdBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'timestamp', timestamp)
            // verify required parameter 'subscriptionItemId' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'subscriptionItemId', subscriptionItemId)
            // verify required parameter 'subscriptionItemsSubscriptionItemIdBody' is not null or undefined
            assertParamExists('updateSubscriptionItem', 'subscriptionItemsSubscriptionItemIdBody', subscriptionItemsSubscriptionItemIdBody)
            const localVarPath = `/v1/subscription_items/{subscriptionItemId}`
                .replace(`{${"subscriptionItemId"}}`, encodeURIComponent(String(subscriptionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionItemsSubscriptionItemIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of usage records for a subscription item
         * @summary Create Usage Record
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [limit] The maximum number of usage records that are returned. Range is 1-100. Default is 10.
         * @param {number} [endingBefore] The latest date and time of the returned usage records. Format is in Unix time.
         * @param {number} [startingAfter] The earliest date and time of the returned usage records. Format is in Unix time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageRecordSummaries: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, limit?: number, endingBefore?: number, startingAfter?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('usageRecordSummaries', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('usageRecordSummaries', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('usageRecordSummaries', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('usageRecordSummaries', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('usageRecordSummaries', 'timestamp', timestamp)
            // verify required parameter 'subscriptionItemId' is not null or undefined
            assertParamExists('usageRecordSummaries', 'subscriptionItemId', subscriptionItemId)
            const localVarPath = `/v1/subscription_items/{subscriptionItemId}/usage_record_summaries`
                .replace(`{${"subscriptionItemId"}}`, encodeURIComponent(String(subscriptionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionSubscriptionItemApi - functional programming interface
 * @export
 */
export const SubscriptionSubscriptionItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionSubscriptionItemApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a subscription item and add it to an existing subscription for recurring payment.
         * @summary Create Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1SubscriptionItemsBody} v1SubscriptionItemsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1SubscriptionItemsBody: V1SubscriptionItemsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionItem(accessKey, contentType, salt, signature, timestamp, v1SubscriptionItemsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.createSubscriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a usage record or update an existing usage record where its unique identifier is composed of timestamp and subscription_item
         * @summary Create Usage Record
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {SubscriptionItemIdUsageRecordsBody} subscriptionItemIdUsageRecordsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionItemUsageRecord(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemIdUsageRecordsBody: SubscriptionItemIdUsageRecordsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionItemUsageRecord(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, subscriptionItemIdUsageRecordsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.createSubscriptionItemUsageRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a subscription item from the Rapyd platform.
         * @summary Delete Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.deleteSubscriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all subscription items for a subscription.
         * @summary List Subscription Items
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [endingBefore] The ID of the subscription item created after the last subscription item you want to retrieve.
         * @param {number} [limit] The maximum number of subscription items to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the subscription item created before the first subscription item you want to retrieve.
         * @param {string} [subscription] ID of the subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: number, limit?: number, startingAfter?: string, subscription?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionItem(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, subscription, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.listSubscriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a subscription item.
         * @summary Retrieve Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.retrieveSubscriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change or modify a subscription item.
         * @summary Update Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {SubscriptionItemsSubscriptionItemIdBody} subscriptionItemsSubscriptionItemIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemsSubscriptionItemIdBody: SubscriptionItemsSubscriptionItemIdBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, subscriptionItemsSubscriptionItemIdBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.updateSubscriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of usage records for a subscription item
         * @summary Create Usage Record
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [limit] The maximum number of usage records that are returned. Range is 1-100. Default is 10.
         * @param {number} [endingBefore] The latest date and time of the returned usage records. Format is in Unix time.
         * @param {number} [startingAfter] The earliest date and time of the returned usage records. Format is in Unix time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageRecordSummaries(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, limit?: number, endingBefore?: number, startingAfter?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageRecordSummaries(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, limit, endingBefore, startingAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionSubscriptionItemApi.usageRecordSummaries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionSubscriptionItemApi - factory interface
 * @export
 */
export const SubscriptionSubscriptionItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionSubscriptionItemApiFp(configuration)
    return {
        /**
         * Create a subscription item and add it to an existing subscription for recurring payment.
         * @summary Create Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1SubscriptionItemsBody} v1SubscriptionItemsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1SubscriptionItemsBody: V1SubscriptionItemsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20016> {
            return localVarFp.createSubscriptionItem(accessKey, contentType, salt, signature, timestamp, v1SubscriptionItemsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a usage record or update an existing usage record where its unique identifier is composed of timestamp and subscription_item
         * @summary Create Usage Record
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {SubscriptionItemIdUsageRecordsBody} subscriptionItemIdUsageRecordsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionItemUsageRecord(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemIdUsageRecordsBody: SubscriptionItemIdUsageRecordsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20019> {
            return localVarFp.createSubscriptionItemUsageRecord(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, subscriptionItemIdUsageRecordsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a subscription item from the Rapyd platform.
         * @summary Delete Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20017> {
            return localVarFp.deleteSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all subscription items for a subscription.
         * @summary List Subscription Items
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [endingBefore] The ID of the subscription item created after the last subscription item you want to retrieve.
         * @param {number} [limit] The maximum number of subscription items to return. Range 1-100. Default is 10.
         * @param {string} [startingAfter] The ID of the subscription item created before the first subscription item you want to retrieve.
         * @param {string} [subscription] ID of the subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: number, limit?: number, startingAfter?: string, subscription?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20015> {
            return localVarFp.listSubscriptionItem(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, subscription, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a subscription item.
         * @summary Retrieve Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20016> {
            return localVarFp.retrieveSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Change or modify a subscription item.
         * @summary Update Subscription Item
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {SubscriptionItemsSubscriptionItemIdBody} subscriptionItemsSubscriptionItemIdBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemsSubscriptionItemIdBody: SubscriptionItemsSubscriptionItemIdBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20016> {
            return localVarFp.updateSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, subscriptionItemsSubscriptionItemIdBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of usage records for a subscription item
         * @summary Create Usage Record
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {number} [limit] The maximum number of usage records that are returned. Range is 1-100. Default is 10.
         * @param {number} [endingBefore] The latest date and time of the returned usage records. Format is in Unix time.
         * @param {number} [startingAfter] The earliest date and time of the returned usage records. Format is in Unix time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageRecordSummaries(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, limit?: number, endingBefore?: number, startingAfter?: number, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20018> {
            return localVarFp.usageRecordSummaries(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, limit, endingBefore, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionSubscriptionItemApi - object-oriented interface
 * @export
 * @class SubscriptionSubscriptionItemApi
 * @extends {BaseAPI}
 */
export class SubscriptionSubscriptionItemApi extends BaseAPI {
    /**
     * Create a subscription item and add it to an existing subscription for recurring payment.
     * @summary Create Subscription Item
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1SubscriptionItemsBody} v1SubscriptionItemsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public createSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1SubscriptionItemsBody: V1SubscriptionItemsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).createSubscriptionItem(accessKey, contentType, salt, signature, timestamp, v1SubscriptionItemsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a usage record or update an existing usage record where its unique identifier is composed of timestamp and subscription_item
     * @summary Create Usage Record
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
     * @param {SubscriptionItemIdUsageRecordsBody} subscriptionItemIdUsageRecordsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public createSubscriptionItemUsageRecord(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemIdUsageRecordsBody: SubscriptionItemIdUsageRecordsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).createSubscriptionItemUsageRecord(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, subscriptionItemIdUsageRecordsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a subscription item from the Rapyd platform.
     * @summary Delete Subscription Item
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public deleteSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).deleteSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all subscription items for a subscription.
     * @summary List Subscription Items
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {number} [endingBefore] The ID of the subscription item created after the last subscription item you want to retrieve.
     * @param {number} [limit] The maximum number of subscription items to return. Range 1-100. Default is 10.
     * @param {string} [startingAfter] The ID of the subscription item created before the first subscription item you want to retrieve.
     * @param {string} [subscription] ID of the subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public listSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, endingBefore?: number, limit?: number, startingAfter?: string, subscription?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).listSubscriptionItem(accessKey, contentType, salt, signature, timestamp, idempotency, endingBefore, limit, startingAfter, subscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a subscription item.
     * @summary Retrieve Subscription Item
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public retrieveSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).retrieveSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change or modify a subscription item.
     * @summary Update Subscription Item
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
     * @param {SubscriptionItemsSubscriptionItemIdBody} subscriptionItemsSubscriptionItemIdBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public updateSubscriptionItem(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, subscriptionItemsSubscriptionItemIdBody: SubscriptionItemsSubscriptionItemIdBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).updateSubscriptionItem(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, subscriptionItemsSubscriptionItemIdBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of usage records for a subscription item
     * @summary Create Usage Record
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} subscriptionItemId ID of the subscription item. String starting with **subi_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {number} [limit] The maximum number of usage records that are returned. Range is 1-100. Default is 10.
     * @param {number} [endingBefore] The latest date and time of the returned usage records. Format is in Unix time.
     * @param {number} [startingAfter] The earliest date and time of the returned usage records. Format is in Unix time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionSubscriptionItemApi
     */
    public usageRecordSummaries(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, subscriptionItemId: string, idempotency?: string, limit?: number, endingBefore?: number, startingAfter?: number, options?: RawAxiosRequestConfig) {
        return SubscriptionSubscriptionItemApiFp(this.configuration).usageRecordSummaries(accessKey, contentType, salt, signature, timestamp, subscriptionItemId, idempotency, limit, endingBefore, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerifyApi - axios parameter creator
 * @export
 */
export const VerifyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an application for Rapyd Verify where the client (applicant) provides information directly to Rapyd. After the applicant submits the application on the hosted page, Rapyd verifies the information. When the status of the application changes, Rapyd sends you a webhook. 
         * @summary Create Hosted Verify Application
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {ApplicationsHostedBody} [applicationsHostedBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedApplicationToken: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, applicationsHostedBody?: ApplicationsHostedBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createHostedApplicationToken', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createHostedApplicationToken', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createHostedApplicationToken', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createHostedApplicationToken', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createHostedApplicationToken', 'timestamp', timestamp)
            const localVarPath = `/v1/verify/applications/hosted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationsHostedBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the status of an application for verification of identity. You can filter the list with query parameters.
         * @summary Retrieve verify Application Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} application ID of the application. String starting with app_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, application: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getApplicationStatus', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getApplicationStatus', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getApplicationStatus', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getApplicationStatus', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getApplicationStatus', 'timestamp', timestamp)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getApplicationStatus', 'application', application)
            const localVarPath = `/v1/verify/applications/status/{application}`
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a List types of identity verification applications by country. You can filter the list with query parameters.
         * @summary List Verify Application Types
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTypesByCountry: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getApplicationTypesByCountry', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getApplicationTypesByCountry', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getApplicationTypesByCountry', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getApplicationTypesByCountry', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getApplicationTypesByCountry', 'timestamp', timestamp)
            // verify required parameter 'country' is not null or undefined
            assertParamExists('getApplicationTypesByCountry', 'country', country)
            const localVarPath = `/v1/verify/applications/types/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Rapyd Verify Application
         * @summary Get Verify Hosted Application
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} verifyAppId ID of the Rapyd Verify application. String starting with happ_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedApplicationByToken: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, verifyAppId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getHostedApplicationByToken', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getHostedApplicationByToken', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getHostedApplicationByToken', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getHostedApplicationByToken', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getHostedApplicationByToken', 'timestamp', timestamp)
            // verify required parameter 'verifyAppId' is not null or undefined
            assertParamExists('getHostedApplicationByToken', 'verifyAppId', verifyAppId)
            const localVarPath = `/v1/verify/applications/hosted/{verifyAppId}`
                .replace(`{${"verifyAppId"}}`, encodeURIComponent(String(verifyAppId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to determine the types of documents to use for identification purposes, and also whether you need the reverse side of the document. You can filter your search results by country with the country query parameter.
         * @summary List ID Documents
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycIdVerificationSupportedDocTypes: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getKycIdVerificationSupportedDocTypes', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getKycIdVerificationSupportedDocTypes', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getKycIdVerificationSupportedDocTypes', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getKycIdVerificationSupportedDocTypes', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getKycIdVerificationSupportedDocTypes', 'timestamp', timestamp)
            // verify required parameter 'country' is not null or undefined
            assertParamExists('getKycIdVerificationSupportedDocTypes', 'country', country)
            const localVarPath = `/v1/identities/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a hosted page for verifying the identity of a personal contact for a Rapyd Wallet.<BR>The customer completes the process by accessing the URL returned in the response.<BR>After the customer submits the identity verification request on the hosted page, Rapyd verifies the information and sends you a webhook with a summary of the identity check. See:<BR>* Identity Verification Webhook - Sandbox Approved<BR>* Identity Verification Webhook - Production Approved<BR>* Identity Verification Webhook - Production Not Approved<BR>**Prerequisites**<BR>* Rapyd Wallet
         * @summary Create Identity Verification Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {HostedIdvBody} hostedIdvBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityVerificationPage: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, hostedIdvBody: HostedIdvBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('identityVerificationPage', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('identityVerificationPage', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('identityVerificationPage', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('identityVerificationPage', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('identityVerificationPage', 'timestamp', timestamp)
            // verify required parameter 'hostedIdvBody' is not null or undefined
            assertParamExists('identityVerificationPage', 'hostedIdvBody', hostedIdvBody)
            const localVarPath = `/v1/hosted/idv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hostedIdvBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verification of the identity of a personal contact associated with a wallet.
         * @summary Verify Identity
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1IdentitiesBody} v1IdentitiesBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIdentity: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1IdentitiesBody: V1IdentitiesBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('verifyIdentity', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('verifyIdentity', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('verifyIdentity', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('verifyIdentity', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('verifyIdentity', 'timestamp', timestamp)
            // verify required parameter 'v1IdentitiesBody' is not null or undefined
            assertParamExists('verifyIdentity', 'v1IdentitiesBody', v1IdentitiesBody)
            const localVarPath = `/v1/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1IdentitiesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifyApi - functional programming interface
 * @export
 */
export const VerifyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerifyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an application for Rapyd Verify where the client (applicant) provides information directly to Rapyd. After the applicant submits the application on the hosted page, Rapyd verifies the information. When the status of the application changes, Rapyd sends you a webhook. 
         * @summary Create Hosted Verify Application
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {ApplicationsHostedBody} [applicationsHostedBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHostedApplicationToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, applicationsHostedBody?: ApplicationsHostedBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200115>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHostedApplicationToken(accessKey, contentType, salt, signature, timestamp, idempotency, applicationsHostedBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.createHostedApplicationToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the status of an application for verification of identity. You can filter the list with query parameters.
         * @summary Retrieve verify Application Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} application ID of the application. String starting with app_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, application: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200114>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(accessKey, contentType, salt, signature, timestamp, application, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.getApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a List types of identity verification applications by country. You can filter the list with query parameters.
         * @summary List Verify Application Types
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationTypesByCountry(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200113>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationTypesByCountry(accessKey, contentType, salt, signature, timestamp, country, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.getApplicationTypesByCountry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Rapyd Verify Application
         * @summary Get Verify Hosted Application
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} verifyAppId ID of the Rapyd Verify application. String starting with happ_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHostedApplicationByToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, verifyAppId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200116>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHostedApplicationByToken(accessKey, contentType, salt, signature, timestamp, verifyAppId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.getHostedApplicationByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method to determine the types of documents to use for identification purposes, and also whether you need the reverse side of the document. You can filter your search results by country with the country query parameter.
         * @summary List ID Documents
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycIdVerificationSupportedDocTypes(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200112>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycIdVerificationSupportedDocTypes(accessKey, contentType, salt, signature, timestamp, country, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.getKycIdVerificationSupportedDocTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a hosted page for verifying the identity of a personal contact for a Rapyd Wallet.<BR>The customer completes the process by accessing the URL returned in the response.<BR>After the customer submits the identity verification request on the hosted page, Rapyd verifies the information and sends you a webhook with a summary of the identity check. See:<BR>* Identity Verification Webhook - Sandbox Approved<BR>* Identity Verification Webhook - Production Approved<BR>* Identity Verification Webhook - Production Not Approved<BR>**Prerequisites**<BR>* Rapyd Wallet
         * @summary Create Identity Verification Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {HostedIdvBody} hostedIdvBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityVerificationPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, hostedIdvBody: HostedIdvBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200117>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityVerificationPage(accessKey, contentType, salt, signature, timestamp, hostedIdvBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.identityVerificationPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verification of the identity of a personal contact associated with a wallet.
         * @summary Verify Identity
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1IdentitiesBody} v1IdentitiesBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyIdentity(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1IdentitiesBody: V1IdentitiesBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200111>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyIdentity(accessKey, contentType, salt, signature, timestamp, v1IdentitiesBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerifyApi.verifyIdentity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerifyApi - factory interface
 * @export
 */
export const VerifyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerifyApiFp(configuration)
    return {
        /**
         * Create an application for Rapyd Verify where the client (applicant) provides information directly to Rapyd. After the applicant submits the application on the hosted page, Rapyd verifies the information. When the status of the application changes, Rapyd sends you a webhook. 
         * @summary Create Hosted Verify Application
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {ApplicationsHostedBody} [applicationsHostedBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedApplicationToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, applicationsHostedBody?: ApplicationsHostedBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200115> {
            return localVarFp.createHostedApplicationToken(accessKey, contentType, salt, signature, timestamp, idempotency, applicationsHostedBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the status of an application for verification of identity. You can filter the list with query parameters.
         * @summary Retrieve verify Application Status
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} application ID of the application. String starting with app_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, application: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200114> {
            return localVarFp.getApplicationStatus(accessKey, contentType, salt, signature, timestamp, application, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a List types of identity verification applications by country. You can filter the list with query parameters.
         * @summary List Verify Application Types
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTypesByCountry(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200113> {
            return localVarFp.getApplicationTypesByCountry(accessKey, contentType, salt, signature, timestamp, country, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Rapyd Verify Application
         * @summary Get Verify Hosted Application
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} verifyAppId ID of the Rapyd Verify application. String starting with happ_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedApplicationByToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, verifyAppId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200116> {
            return localVarFp.getHostedApplicationByToken(accessKey, contentType, salt, signature, timestamp, verifyAppId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to determine the types of documents to use for identification purposes, and also whether you need the reverse side of the document. You can filter your search results by country with the country query parameter.
         * @summary List ID Documents
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycIdVerificationSupportedDocTypes(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200112> {
            return localVarFp.getKycIdVerificationSupportedDocTypes(accessKey, contentType, salt, signature, timestamp, country, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a hosted page for verifying the identity of a personal contact for a Rapyd Wallet.<BR>The customer completes the process by accessing the URL returned in the response.<BR>After the customer submits the identity verification request on the hosted page, Rapyd verifies the information and sends you a webhook with a summary of the identity check. See:<BR>* Identity Verification Webhook - Sandbox Approved<BR>* Identity Verification Webhook - Production Approved<BR>* Identity Verification Webhook - Production Not Approved<BR>**Prerequisites**<BR>* Rapyd Wallet
         * @summary Create Identity Verification Page
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {HostedIdvBody} hostedIdvBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityVerificationPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, hostedIdvBody: HostedIdvBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200117> {
            return localVarFp.identityVerificationPage(accessKey, contentType, salt, signature, timestamp, hostedIdvBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Verification of the identity of a personal contact associated with a wallet.
         * @summary Verify Identity
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1IdentitiesBody} v1IdentitiesBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIdentity(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1IdentitiesBody: V1IdentitiesBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200111> {
            return localVarFp.verifyIdentity(accessKey, contentType, salt, signature, timestamp, v1IdentitiesBody, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerifyApi - object-oriented interface
 * @export
 * @class VerifyApi
 * @extends {BaseAPI}
 */
export class VerifyApi extends BaseAPI {
    /**
     * Create an application for Rapyd Verify where the client (applicant) provides information directly to Rapyd. After the applicant submits the application on the hosted page, Rapyd verifies the information. When the status of the application changes, Rapyd sends you a webhook. 
     * @summary Create Hosted Verify Application
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {ApplicationsHostedBody} [applicationsHostedBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public createHostedApplicationToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, idempotency?: string, applicationsHostedBody?: ApplicationsHostedBody, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).createHostedApplicationToken(accessKey, contentType, salt, signature, timestamp, idempotency, applicationsHostedBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the status of an application for verification of identity. You can filter the list with query parameters.
     * @summary Retrieve verify Application Status
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} application ID of the application. String starting with app_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public getApplicationStatus(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, application: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).getApplicationStatus(accessKey, contentType, salt, signature, timestamp, application, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a List types of identity verification applications by country. You can filter the list with query parameters.
     * @summary List Verify Application Types
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public getApplicationTypesByCountry(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).getApplicationTypesByCountry(accessKey, contentType, salt, signature, timestamp, country, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Rapyd Verify Application
     * @summary Get Verify Hosted Application
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} verifyAppId ID of the Rapyd Verify application. String starting with happ_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public getHostedApplicationByToken(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, verifyAppId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).getHostedApplicationByToken(accessKey, contentType, salt, signature, timestamp, verifyAppId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to determine the types of documents to use for identification purposes, and also whether you need the reverse side of the document. You can filter your search results by country with the country query parameter.
     * @summary List ID Documents
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code for the country. Uppercase.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public getKycIdVerificationSupportedDocTypes(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).getKycIdVerificationSupportedDocTypes(accessKey, contentType, salt, signature, timestamp, country, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a hosted page for verifying the identity of a personal contact for a Rapyd Wallet.<BR>The customer completes the process by accessing the URL returned in the response.<BR>After the customer submits the identity verification request on the hosted page, Rapyd verifies the information and sends you a webhook with a summary of the identity check. See:<BR>* Identity Verification Webhook - Sandbox Approved<BR>* Identity Verification Webhook - Production Approved<BR>* Identity Verification Webhook - Production Not Approved<BR>**Prerequisites**<BR>* Rapyd Wallet
     * @summary Create Identity Verification Page
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {HostedIdvBody} hostedIdvBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public identityVerificationPage(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, hostedIdvBody: HostedIdvBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).identityVerificationPage(accessKey, contentType, salt, signature, timestamp, hostedIdvBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verification of the identity of a personal contact associated with a wallet.
     * @summary Verify Identity
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1IdentitiesBody} v1IdentitiesBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyApi
     */
    public verifyIdentity(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1IdentitiesBody: V1IdentitiesBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VerifyApiFp(this.configuration).verifyIdentity(accessKey, contentType, salt, signature, timestamp, v1IdentitiesBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsApi - axios parameter creator
 * @export
 */
export const VirtualAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of the capabilities of virtual accounts you can issue to a Rapyd Wallet.<BR> The list is filtered by country.
         * @summary Issue Virtual Account Number
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code of the country.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capabilitiesOfVirtualAccounts: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('capabilitiesOfVirtualAccounts', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('capabilitiesOfVirtualAccounts', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('capabilitiesOfVirtualAccounts', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('capabilitiesOfVirtualAccounts', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('capabilitiesOfVirtualAccounts', 'timestamp', timestamp)
            // verify required parameter 'country' is not null or undefined
            assertParamExists('capabilitiesOfVirtualAccounts', 'country', country)
            const localVarPath = `/v1/virtual_accounts/capabilities/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a virtual account number of an existing wallet. In order to close a virtual account its status must be ACT.
         * @summary Close VA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the virtual account. String starting with issuing_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeIssuing: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('closeIssuing', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('closeIssuing', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('closeIssuing', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('closeIssuing', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('closeIssuing', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('closeIssuing', 'virtualAccountId', virtualAccountId)
            const localVarPath = `/v1/virtual_accounts/{virtualAccountId}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue a virtual account number to an existing wallet.
         * @summary Issue Virtual Account Number to Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1VirtualAccountsBody} v1VirtualAccountsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1VirtualAccountsBody: V1VirtualAccountsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('createVirtualAccount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createVirtualAccount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('createVirtualAccount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('createVirtualAccount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createVirtualAccount', 'timestamp', timestamp)
            // verify required parameter 'v1VirtualAccountsBody' is not null or undefined
            assertParamExists('createVirtualAccount', 'v1VirtualAccountsBody', v1VirtualAccountsBody)
            const localVarPath = `/v1/virtual_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1VirtualAccountsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a Virtual Account Number object for a wallet.
         * @summary Retrieve Virtual Account History
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with issuing_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveVirtualAccount: async (virtualAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('retrieveVirtualAccount', 'virtualAccountId', virtualAccountId)
            const localVarPath = `/v1/virtual_accounts/{virtualAccountId}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
         * @summary Simulate a Bank Transfer to a Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {VirtualAccountsTransactionsBody} virtualAccountsTransactionsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateBankTransferToVirtualAccount: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountsTransactionsBody: VirtualAccountsTransactionsBody, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('simulateBankTransferToVirtualAccount', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateBankTransferToVirtualAccount', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('simulateBankTransferToVirtualAccount', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('simulateBankTransferToVirtualAccount', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('simulateBankTransferToVirtualAccount', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountsTransactionsBody' is not null or undefined
            assertParamExists('simulateBankTransferToVirtualAccount', 'virtualAccountsTransactionsBody', virtualAccountsTransactionsBody)
            const localVarPath = `/v1/virtual_accounts/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountsTransactionsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
         * @summary Update Requested Currency
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {VirtualAccountsVirtualAccountIdBody} [virtualAccountsVirtualAccountIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRequestedCurrency: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, virtualAccountsVirtualAccountIdBody?: VirtualAccountsVirtualAccountIdBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('updateRequestedCurrency', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('updateRequestedCurrency', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('updateRequestedCurrency', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('updateRequestedCurrency', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateRequestedCurrency', 'timestamp', timestamp)
            // verify required parameter 'virtualAccountId' is not null or undefined
            assertParamExists('updateRequestedCurrency', 'virtualAccountId', virtualAccountId)
            const localVarPath = `/v1/virtual_accounts/{virtualAccountId}`
                .replace(`{${"virtualAccountId"}}`, encodeURIComponent(String(virtualAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountsVirtualAccountIdBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsApi - functional programming interface
 * @export
 */
export const VirtualAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of the capabilities of virtual accounts you can issue to a Rapyd Wallet.<BR> The list is filtered by country.
         * @summary Issue Virtual Account Number
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code of the country.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capabilitiesOfVirtualAccounts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20095>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capabilitiesOfVirtualAccounts(accessKey, contentType, salt, signature, timestamp, country, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.capabilitiesOfVirtualAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a virtual account number of an existing wallet. In order to close a virtual account its status must be ACT.
         * @summary Close VA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the virtual account. String starting with issuing_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeIssuing(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20094>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeIssuing(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.closeIssuing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issue a virtual account number to an existing wallet.
         * @summary Issue Virtual Account Number to Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1VirtualAccountsBody} v1VirtualAccountsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1VirtualAccountsBody: V1VirtualAccountsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20090>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccount(accessKey, contentType, salt, signature, timestamp, v1VirtualAccountsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a Virtual Account Number object for a wallet.
         * @summary Retrieve Virtual Account History
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with issuing_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveVirtualAccount(virtualAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20092>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveVirtualAccount(virtualAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.retrieveVirtualAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
         * @summary Simulate a Bank Transfer to a Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {VirtualAccountsTransactionsBody} virtualAccountsTransactionsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateBankTransferToVirtualAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountsTransactionsBody: VirtualAccountsTransactionsBody, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20091>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateBankTransferToVirtualAccount(accessKey, contentType, salt, signature, timestamp, virtualAccountsTransactionsBody, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.simulateBankTransferToVirtualAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
         * @summary Update Requested Currency
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {VirtualAccountsVirtualAccountIdBody} [virtualAccountsVirtualAccountIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRequestedCurrency(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, virtualAccountsVirtualAccountIdBody?: VirtualAccountsVirtualAccountIdBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20093>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRequestedCurrency(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, virtualAccountsVirtualAccountIdBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.updateRequestedCurrency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsApi - factory interface
 * @export
 */
export const VirtualAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsApiFp(configuration)
    return {
        /**
         * Retrieve a list of the capabilities of virtual accounts you can issue to a Rapyd Wallet.<BR> The list is filtered by country.
         * @summary Issue Virtual Account Number
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code of the country.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capabilitiesOfVirtualAccounts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20095> {
            return localVarFp.capabilitiesOfVirtualAccounts(accessKey, contentType, salt, signature, timestamp, country, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a virtual account number of an existing wallet. In order to close a virtual account its status must be ACT.
         * @summary Close VA
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the virtual account. String starting with issuing_.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeIssuing(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20094> {
            return localVarFp.closeIssuing(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Issue a virtual account number to an existing wallet.
         * @summary Issue Virtual Account Number to Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {V1VirtualAccountsBody} v1VirtualAccountsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1VirtualAccountsBody: V1VirtualAccountsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20090> {
            return localVarFp.createVirtualAccount(accessKey, contentType, salt, signature, timestamp, v1VirtualAccountsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a Virtual Account Number object for a wallet.
         * @summary Retrieve Virtual Account History
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with issuing_.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveVirtualAccount(virtualAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20092> {
            return localVarFp.retrieveVirtualAccount(virtualAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
         * @summary Simulate a Bank Transfer to a Wallet
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {VirtualAccountsTransactionsBody} virtualAccountsTransactionsBody 
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateBankTransferToVirtualAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountsTransactionsBody: VirtualAccountsTransactionsBody, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20091> {
            return localVarFp.simulateBankTransferToVirtualAccount(accessKey, contentType, salt, signature, timestamp, virtualAccountsTransactionsBody, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
         * @summary Update Requested Currency
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {VirtualAccountsVirtualAccountIdBody} [virtualAccountsVirtualAccountIdBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRequestedCurrency(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, virtualAccountsVirtualAccountIdBody?: VirtualAccountsVirtualAccountIdBody, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse20093> {
            return localVarFp.updateRequestedCurrency(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, virtualAccountsVirtualAccountIdBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsApi - object-oriented interface
 * @export
 * @class VirtualAccountsApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsApi extends BaseAPI {
    /**
     * Retrieve a list of the capabilities of virtual accounts you can issue to a Rapyd Wallet.<BR> The list is filtered by country.
     * @summary Issue Virtual Account Number
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} country Two-letter ISO 3166-1 ALPHA-2 code of the country.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public capabilitiesOfVirtualAccounts(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, country: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).capabilitiesOfVirtualAccounts(accessKey, contentType, salt, signature, timestamp, country, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a virtual account number of an existing wallet. In order to close a virtual account its status must be ACT.
     * @summary Close VA
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} virtualAccountId ID of the virtual account. String starting with issuing_.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public closeIssuing(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).closeIssuing(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issue a virtual account number to an existing wallet.
     * @summary Issue Virtual Account Number to Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {V1VirtualAccountsBody} v1VirtualAccountsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, v1VirtualAccountsBody: V1VirtualAccountsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccount(accessKey, contentType, salt, signature, timestamp, v1VirtualAccountsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a Virtual Account Number object for a wallet.
     * @summary Retrieve Virtual Account History
     * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with issuing_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public retrieveVirtualAccount(virtualAccountId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).retrieveVirtualAccount(virtualAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulate a deposit to a virtual account number that was issued to a wallet. This method is relevant only for testing in the sandbox. The currency of the transfer must be supported by the specific virtual account. This method triggers the Deposit Completed webhook.
     * @summary Simulate a Bank Transfer to a Wallet
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {VirtualAccountsTransactionsBody} virtualAccountsTransactionsBody 
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public simulateBankTransferToVirtualAccount(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountsTransactionsBody: VirtualAccountsTransactionsBody, idempotency?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).simulateBankTransferToVirtualAccount(accessKey, contentType, salt, signature, timestamp, virtualAccountsTransactionsBody, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define, change, or cancel the currency to which funds received by a virtual account are converted.<BR>The status of the virtual account must be **ACT** (active) or **PEN** (pending).<BR>To cancel a previously defined currency conversion, set `requested_currency` to **null**.<BR> Prerequisites:<BR>* Create Wallet<BR>* Verify Identity<BR> * Issue Virtual Account to Wallet
     * @summary Update Requested Currency
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} virtualAccountId ID of the Virtual Account Number object. String starting with **issuing_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {VirtualAccountsVirtualAccountIdBody} [virtualAccountsVirtualAccountIdBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public updateRequestedCurrency(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, virtualAccountId: string, idempotency?: string, virtualAccountsVirtualAccountIdBody?: VirtualAccountsVirtualAccountIdBody, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).updateRequestedCurrency(accessKey, contentType, salt, signature, timestamp, virtualAccountId, idempotency, virtualAccountsVirtualAccountIdBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookMethodsApi - axios parameter creator
 * @export
 */
export const WebhookMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a webhook. Use \'List Webhooks\' to find the IDs of webhooks.
         * @summary Retrieve Webhook
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} webhook The webhook ID. String starting with **wh_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('getWebhook', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getWebhook', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('getWebhook', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('getWebhook', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getWebhook', 'timestamp', timestamp)
            // verify required parameter 'webhook' is not null or undefined
            assertParamExists('getWebhook', 'webhook', webhook)
            const localVarPath = `/v1/webhooks/{webhook}`
                .replace(`{${"webhook"}}`, encodeURIComponent(String(webhook)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all webhooks that were sent. You can filter the list with query parameters.
         * @summary List Webhooks
         * @param {string} [fromCreatedAt] The earliest date and time when the object was created, in Unix time (seconds).
         * @param {number} [limit] The maximum number of objects to return. Range: 1-1000.
         * @param {string} [page] Page number for pagination.
         * @param {string} [status] Status of the webhook. One of the following: &lt;BR&gt; * **NEW** (new) - The webhook was created and has not yet been sent successfully. &lt;BR&gt; * **CLO** (closed) - The webhook was sent successfully.&lt;BR&gt; * **ERR** (error) - Attempts were made to send the webhook, but the maximum number of retries was  reached. The automatic retry process failed. The webhook was not sent. &lt;BR&gt; * **RET** (retried) - The webhook was resent.
         * @param {string} [type] The type of webhook.
         * @param {number} [toCreatedAt] The latest date and time when the object was created, in Unix time (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (fromCreatedAt?: string, limit?: number, page?: string, status?: string, type?: string, toCreatedAt?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromCreatedAt !== undefined) {
                localVarQueryParameter['from_created_at'] = fromCreatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = (status as any instanceof Date) ?
                    (status as any).toISOString().substring(0,10) :
                    status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (toCreatedAt !== undefined) {
                localVarQueryParameter['to_created_at'] = toCreatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend a webhook that was not sent successfully. Use \'List Webhooks\' to find the IDs of webhooks. You can resend a webhook that is in status **ERR**.
         * @summary Resend Webhook
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} webhook The webhook ID. String starting with **wh_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhook: async (accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKey' is not null or undefined
            assertParamExists('resendWebhook', 'accessKey', accessKey)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('resendWebhook', 'contentType', contentType)
            // verify required parameter 'salt' is not null or undefined
            assertParamExists('resendWebhook', 'salt', salt)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('resendWebhook', 'signature', signature)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('resendWebhook', 'timestamp', timestamp)
            // verify required parameter 'webhook' is not null or undefined
            assertParamExists('resendWebhook', 'webhook', webhook)
            const localVarPath = `/v1/webhooks/{webhook}`
                .replace(`{${"webhook"}}`, encodeURIComponent(String(webhook)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accessKey != null) {
                localVarHeaderParameter['access_key'] = String(accessKey);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (idempotency != null) {
                localVarHeaderParameter['idempotency'] = String(idempotency);
            }
            if (salt != null) {
                localVarHeaderParameter['salt'] = String(salt);
            }
            if (signature != null) {
                localVarHeaderParameter['signature'] = String(signature);
            }
            if (timestamp != null) {
                localVarHeaderParameter['timestamp'] = String(timestamp);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookMethodsApi - functional programming interface
 * @export
 */
export const WebhookMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a webhook. Use \'List Webhooks\' to find the IDs of webhooks.
         * @summary Retrieve Webhook
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} webhook The webhook ID. String starting with **wh_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200105>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(accessKey, contentType, salt, signature, timestamp, webhook, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookMethodsApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all webhooks that were sent. You can filter the list with query parameters.
         * @summary List Webhooks
         * @param {string} [fromCreatedAt] The earliest date and time when the object was created, in Unix time (seconds).
         * @param {number} [limit] The maximum number of objects to return. Range: 1-1000.
         * @param {string} [page] Page number for pagination.
         * @param {string} [status] Status of the webhook. One of the following: &lt;BR&gt; * **NEW** (new) - The webhook was created and has not yet been sent successfully. &lt;BR&gt; * **CLO** (closed) - The webhook was sent successfully.&lt;BR&gt; * **ERR** (error) - Attempts were made to send the webhook, but the maximum number of retries was  reached. The automatic retry process failed. The webhook was not sent. &lt;BR&gt; * **RET** (retried) - The webhook was resent.
         * @param {string} [type] The type of webhook.
         * @param {number} [toCreatedAt] The latest date and time when the object was created, in Unix time (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(fromCreatedAt?: string, limit?: number, page?: string, status?: string, type?: string, toCreatedAt?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200106>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(fromCreatedAt, limit, page, status, type, toCreatedAt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookMethodsApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend a webhook that was not sent successfully. Use \'List Webhooks\' to find the IDs of webhooks. You can resend a webhook that is in status **ERR**.
         * @summary Resend Webhook
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} webhook The webhook ID. String starting with **wh_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhook(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200105>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhook(accessKey, contentType, salt, signature, timestamp, webhook, idempotency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookMethodsApi.resendWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookMethodsApi - factory interface
 * @export
 */
export const WebhookMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookMethodsApiFp(configuration)
    return {
        /**
         * Retrieve a webhook. Use \'List Webhooks\' to find the IDs of webhooks.
         * @summary Retrieve Webhook
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} webhook The webhook ID. String starting with **wh_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200105> {
            return localVarFp.getWebhook(accessKey, contentType, salt, signature, timestamp, webhook, idempotency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all webhooks that were sent. You can filter the list with query parameters.
         * @summary List Webhooks
         * @param {string} [fromCreatedAt] The earliest date and time when the object was created, in Unix time (seconds).
         * @param {number} [limit] The maximum number of objects to return. Range: 1-1000.
         * @param {string} [page] Page number for pagination.
         * @param {string} [status] Status of the webhook. One of the following: &lt;BR&gt; * **NEW** (new) - The webhook was created and has not yet been sent successfully. &lt;BR&gt; * **CLO** (closed) - The webhook was sent successfully.&lt;BR&gt; * **ERR** (error) - Attempts were made to send the webhook, but the maximum number of retries was  reached. The automatic retry process failed. The webhook was not sent. &lt;BR&gt; * **RET** (retried) - The webhook was resent.
         * @param {string} [type] The type of webhook.
         * @param {number} [toCreatedAt] The latest date and time when the object was created, in Unix time (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(fromCreatedAt?: string, limit?: number, page?: string, status?: string, type?: string, toCreatedAt?: number, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200106> {
            return localVarFp.listWebhooks(fromCreatedAt, limit, page, status, type, toCreatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend a webhook that was not sent successfully. Use \'List Webhooks\' to find the IDs of webhooks. You can resend a webhook that is in status **ERR**.
         * @summary Resend Webhook
         * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
         * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
         * @param {string} salt Random string. Recommended length: 8-16 characters.
         * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
         * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
         * @param {string} webhook The webhook ID. String starting with **wh_**.
         * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhook(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineResponse200105> {
            return localVarFp.resendWebhook(accessKey, contentType, salt, signature, timestamp, webhook, idempotency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookMethodsApi - object-oriented interface
 * @export
 * @class WebhookMethodsApi
 * @extends {BaseAPI}
 */
export class WebhookMethodsApi extends BaseAPI {
    /**
     * Retrieve a webhook. Use \'List Webhooks\' to find the IDs of webhooks.
     * @summary Retrieve Webhook
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} webhook The webhook ID. String starting with **wh_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookMethodsApi
     */
    public getWebhook(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return WebhookMethodsApiFp(this.configuration).getWebhook(accessKey, contentType, salt, signature, timestamp, webhook, idempotency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all webhooks that were sent. You can filter the list with query parameters.
     * @summary List Webhooks
     * @param {string} [fromCreatedAt] The earliest date and time when the object was created, in Unix time (seconds).
     * @param {number} [limit] The maximum number of objects to return. Range: 1-1000.
     * @param {string} [page] Page number for pagination.
     * @param {string} [status] Status of the webhook. One of the following: &lt;BR&gt; * **NEW** (new) - The webhook was created and has not yet been sent successfully. &lt;BR&gt; * **CLO** (closed) - The webhook was sent successfully.&lt;BR&gt; * **ERR** (error) - Attempts were made to send the webhook, but the maximum number of retries was  reached. The automatic retry process failed. The webhook was not sent. &lt;BR&gt; * **RET** (retried) - The webhook was resent.
     * @param {string} [type] The type of webhook.
     * @param {number} [toCreatedAt] The latest date and time when the object was created, in Unix time (seconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookMethodsApi
     */
    public listWebhooks(fromCreatedAt?: string, limit?: number, page?: string, status?: string, type?: string, toCreatedAt?: number, options?: RawAxiosRequestConfig) {
        return WebhookMethodsApiFp(this.configuration).listWebhooks(fromCreatedAt, limit, page, status, type, toCreatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend a webhook that was not sent successfully. Use \'List Webhooks\' to find the IDs of webhooks. You can resend a webhook that is in status **ERR**.
     * @summary Resend Webhook
     * @param {string} accessKey Unique access key provided by Rapyd for each authorized user.
     * @param {string} contentType Indicates that the data appears in JSON format. Set to **application/json**.
     * @param {string} salt Random string. Recommended length: 8-16 characters.
     * @param {string} signature Signature calculated for each request individually. See [Request Signatures](https://docs.rapyd.net/en/request-signatures.html).
     * @param {string} timestamp Timestamp for the request, in Unix time (seconds).
     * @param {string} webhook The webhook ID. String starting with **wh_**.
     * @param {string} [idempotency] A unique key that prevents the platform from creating the same object twice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookMethodsApi
     */
    public resendWebhook(accessKey: string, contentType: string, salt: string, signature: string, timestamp: string, webhook: string, idempotency?: string, options?: RawAxiosRequestConfig) {
        return WebhookMethodsApiFp(this.configuration).resendWebhook(accessKey, contentType, salt, signature, timestamp, webhook, idempotency, options).then((request) => request(this.axios, this.basePath));
    }
}



